#include <linux/streamline_annotate.h>
#include <linux/kthread.h>
#include <linux/slab.h>
#include <linux/version.h>
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
#include <uapi/linux/sched/types.h>
#endif
#include "cvi_vip_isp.h"
#include "cvi_vip_isp_proc.h"
#include "cvi_vip_vi_proc.h"
#include "tee_cv_private.h"

#define ISP_TUN_CFG(_name) \
	{\
		struct cvi_vip_isp_##_name##_config *cfg;\
		cfg = (struct cvi_vip_isp_##_name##_config *)ext_ctrls[i].ptr;\
		ispblk_##_name##_tun_cfg(ctx, cfg);\
		rc = 0;\
	}

#define BE_RUNTIME_TUN(_name) \
	{\
		struct cvi_vip_isp_##_name##_config *cfg;\
		cfg = &be_tun->_name##_cfg;\
		ispblk_##_name##_tun_cfg(ctx, cfg, raw_num);\
	}

#define POST_RUNTIME_TUN(_name) \
	{\
		struct cvi_vip_isp_##_name##_config *cfg;\
		cfg = &post_tun->_name##_cfg;\
		ispblk_##_name##_tun_cfg(ctx, cfg, raw_num);\
	}


#define VI_DBG_PROC_NAME "cvitek/vi_dbg"
#define VI_SHARE_MEM_SIZE     (0x2000)

//#define ISP_PERF_MEASURE
#ifdef ISP_PERF_MEASURE
#define ISP_MEASURE_FRM 100
#define STOUS 1000000

struct isp_perf_chk {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	struct timespec64 sof_time[ISP_MEASURE_FRM];
	struct timespec64 pre_fe_eof[ISP_MEASURE_FRM];
	struct timespec64 pre_be_eof[ISP_MEASURE_FRM];
	struct timespec64 post_trig[ISP_MEASURE_FRM];
	struct timespec64 post_eof[ISP_MEASURE_FRM];
#else
	struct timeval sof_time[ISP_MEASURE_FRM];
	struct timeval pre_fe_eof[ISP_MEASURE_FRM];
	struct timeval pre_be_eof[ISP_MEASURE_FRM];
	struct timeval post_trig[ISP_MEASURE_FRM];
	struct timeval post_eof[ISP_MEASURE_FRM];
#endif
	u8 sof_end;
	u8 pre_fe_end;
	u8 pre_be_end;
	u8 post_end;
};

static struct isp_perf_chk time_chk;
#endif //ISP_PERF_MEASURE


struct isp_buffer {
	enum cvi_isp_raw  raw_num;
	enum cvi_isp_chn_num chn_num;
	uint64_t          addr;
	struct vip_rect   crop_le;
	struct vip_rect   crop_se;
	struct isp_grid_s_info rgbmap_i;
	struct isp_grid_s_info lmap_i;
	uint32_t          byr_size;
	struct list_head  list;
	uint32_t          ir_idx;
	uint32_t          is_yuv_frm : 1;
};

struct isp_queue {
	struct list_head rdy_queue;
	uint32_t num_rdy;
	enum cvi_isp_raw raw_num;
} pre_out_queue[ISP_CHN_MAX], pre_out_se_queue[ISP_CHN_MAX],
	raw_dump_b_q[ISP_PRERAW_MAX], raw_dump_b_se_q[ISP_PRERAW_MAX],
	raw_dump_b_dq[ISP_PRERAW_MAX], raw_dump_b_se_dq[ISP_PRERAW_MAX],
	post_in_queue, post_in_se_queue,
	pre_be_in_q, pre_be_in_se_q[ISP_PRERAW_MAX],
	pre_be_out_q, pre_be_out_se_q;

struct _isp_snr_i2c_node {
	struct snsr_regs_s n;
	struct list_head list;
};

struct _isp_snr_cfg_queue {
	struct list_head	list;
} isp_snr_i2c_queue[ISP_PRERAW_MAX];

struct _isp_raw_num_n {
	enum cvi_isp_raw raw_num;
	struct list_head list;
};

struct _isp_sof_raw_num_q {
	struct list_head	list;
} pre_raw_num_q;

static spinlock_t raw_num_lock;

struct _isp_dqbuf_n {
	u8	chn_id;
	u32	frm_num;
	struct list_head list;
};

struct _isp_dqbuf_q {
	struct list_head	list;
} dqbuf_q;

static spinlock_t dq_lock;

#define OFFLINE_RAW_BUF_NUM	2
#define OFFLINE_PRE_BE_BUF_NUM	2
#define OFFLINE_YUV_BUF_NUM	2

#define MAX_RGBMAP_BUF_NUM	3
static u8 RGBMAP_BUF_IDX      = 2;

/* struct mempool
 * @base: the address of the mempool
 * @size: the size of the mempool
 * @byteused: the number of bytes used
 * @sts_busy_idx: idx of sts_mem which is written
 * @sts_lock: if locked then sts_busy_idx won't be updated until lock released.
 */
struct _mempool {
	uint64_t base;
	uint32_t size;
	uint32_t byteused;
} isp_mempool;

struct _membuf {
	uint64_t bayer_le[OFFLINE_RAW_BUF_NUM];
	uint64_t bayer_se[OFFLINE_RAW_BUF_NUM];
	uint64_t prebe_le[OFFLINE_PRE_BE_BUF_NUM];
	uint64_t prebe_se[OFFLINE_PRE_BE_BUF_NUM];
	uint64_t yuv_yuyv[ISP_CHN_MAX][2];//yuv sensor is yuyv format
	uint64_t manr;
	uint64_t manr_rtile;
	uint64_t rgbmap_le[MAX_RGBMAP_BUF_NUM];
	uint64_t rgbmap_se[MAX_RGBMAP_BUF_NUM];
	uint64_t lmap_le;
	uint64_t lmap_se;
	uint64_t lsc;
	uint64_t tdnr[4];//0 for UV, 1 for Y, 2 for uv fbc double buffer, 3 for y fbc double buffer
	uint64_t tdnr_rtile[4];//tile
	uint64_t ir_le[OFFLINE_PRE_BE_BUF_NUM];
	uint64_t ir_se[OFFLINE_PRE_BE_BUF_NUM];
	struct cvi_vip_isp_fswdr_report *fswdr_rpt;

	struct cvi_isp_sts_mem sts_mem[2];
	uint8_t pre_fe_sts_busy_idx;
	uint8_t pre_be_sts_busy_idx;
	uint8_t post_sts_busy_idx;
	uint8_t awb_sts_busy_idx;
	uint8_t post_ir_busy_idx;

	spinlock_t pre_fe_sts_lock;
	uint8_t pre_fe_sts_in_use;
	spinlock_t pre_be_sts_lock;
	uint8_t pre_be_sts_in_use;
	spinlock_t post_sts_lock;
	uint8_t post_sts_in_use;
	spinlock_t awb_sts_lock;
	uint8_t awb_sts_in_use;
} isp_bufpool[ISP_PRERAW_MAX] = {0};


static struct task_struct *isp_pre_th;
static atomic_t            isp_pre_exit;
static int _isp_preraw_thread(void *arg);

static struct task_struct *isp_err_handler_th;
static atomic_t            isp_err_handler_exit;
static int _isp_err_handler_thread(void *arg);

static void *ptr[ISP_PRERAW_MAX];
struct isp_tuning_cfg tuning_buf_addr;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
typedef struct legacy_timer_emu {
	struct timer_list t;
	void (*function)(unsigned long);
	unsigned long data;
} _timer;
#else
typedef struct timer_list _timer;
#endif

_timer usr_pic_timer;

struct ip_info ip_info_list[IP_INFO_ID_MAX] = {
	//Pre_raw_be
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_PRE_RAW_BE, sizeof(struct REG_PRE_RAW_BE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP4, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP5, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BLC4, sizeof(struct REG_ISP_BLC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BLC5, sizeof(struct REG_ISP_BLC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_FPN, sizeof(struct REG_ISP_FPN_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_IR_PRE_PROC_LE, sizeof(struct REG_ISP_PREPROCESS_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_IR_PRE_PROC_SE, sizeof(struct REG_ISP_PREPROCESS_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_IR_PROC, sizeof(struct REG_IR_WDMA_PROC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_AEHIST0, sizeof(struct REG_ISP_AE_HIST_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_AEHIST1, sizeof(struct REG_ISP_AE_HIST_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_AWB0, sizeof(struct REG_ISP_AWB_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_GMS, sizeof(struct REG_ISP_GMS_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_AF, sizeof(struct REG_ISP_AF_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG0, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG1, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_DPC0, sizeof(struct REG_ISP_DPC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_DPC1, sizeof(struct REG_ISP_DPC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_INV_WBG0, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_INV_WBG1, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCR4, sizeof(struct REG_ISP_LSCR_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCR5, sizeof(struct REG_ISP_LSCR_T)},
	//Pre_raw_0_fe
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_PRE_RAW_FE0, sizeof(struct REG_PRE_RAW_FE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CSIBDG0, sizeof(struct REG_ISP_CSI_BDG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP0, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP1, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BLC0, sizeof(struct REG_ISP_BLC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BLC1, sizeof(struct REG_ISP_BLC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LMP0, sizeof(struct REG_ISP_LMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG11, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LMP1, sizeof(struct REG_ISP_LMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG12, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RGBMAP0, sizeof(struct REG_ISP_RGBMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG7, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RGBMAP1, sizeof(struct REG_ISP_RGBMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG8, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCR0, sizeof(struct REG_ISP_LSCR_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCR1, sizeof(struct REG_ISP_LSCR_T)},
	//Pre_raw_1_fe
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_PRE_RAW_FE1, sizeof(struct REG_PRE_RAW_FE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CSIBDG1_R1, sizeof(struct REG_ISP_CSI_BDG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP2, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP3, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BLC2, sizeof(struct REG_ISP_BLC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BLC3, sizeof(struct REG_ISP_BLC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LMP2, sizeof(struct REG_ISP_LMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG13, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LMP3, sizeof(struct REG_ISP_LMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG14, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RGBMAP2, sizeof(struct REG_ISP_RGBMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG9, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RGBMAP3, sizeof(struct REG_ISP_RGBMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_WBG10, sizeof(struct REG_ISP_WBG_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCR2, sizeof(struct REG_ISP_LSCR_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCR3, sizeof(struct REG_ISP_LSCR_T)},
	//Rawtop
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RAWTOP, sizeof(struct REG_RAW_TOP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CFA, sizeof(struct REG_ISP_CFA_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_BNR, sizeof(struct REG_ISP_BNR_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP6, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP7, sizeof(struct REG_ISP_CROP_T)},
	//Rgbtop
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RGBTOP, sizeof(struct REG_ISP_RGB_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_LSCM0, sizeof(struct REG_ISP_LSC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CCM0, sizeof(struct REG_ISP_CCM_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CCM1, sizeof(struct REG_ISP_CCM_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CCM2, sizeof(struct REG_ISP_CCM_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CCM3, sizeof(struct REG_ISP_CCM_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CCM4, sizeof(struct REG_ISP_CCM_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_MANR, sizeof(struct REG_ISP_MMAP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_GAMMA, sizeof(struct REG_ISP_GAMMA_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CLUT, sizeof(struct REG_ISP_CLUT_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_DHZ, sizeof(struct REG_ISP_DHZ_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_R2Y4, sizeof(struct REG_ISP_CSC_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_RGBDITHER, sizeof(struct REG_ISP_RGBDITHER_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_PREYEE, sizeof(struct REG_ISP_EE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_DCI, sizeof(struct REG_ISP_DCI_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_HIST_EDGE_V, sizeof(struct REG_HIST_EDGE_V_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_HDRFUSION, sizeof(struct REG_ISP_FUSION_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_HDRLTM, sizeof(struct REG_ISP_LTM_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_AWB2, sizeof(struct REG_ISP_AWB_T)},
	//Yuvtop
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_YUVTOP, sizeof(struct REG_YUV_TOP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_444422, sizeof(struct REG_ISP_444_422_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_FBCE, sizeof(struct REG_FBCE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_FBCD, sizeof(struct REG_FBCD_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_YUVDITHER, sizeof(struct REG_ISP_YUVDITHER_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_YNR, sizeof(struct REG_ISP_YNR_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CNR, sizeof(struct REG_ISP_CNR_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_EE, sizeof(struct REG_ISP_EE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_YCURVE, sizeof(struct REG_ISP_YCURVE_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP8, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CROP9, sizeof(struct REG_ISP_CROP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_ISPTOP, sizeof(struct REG_ISP_TOP_T)},
	{ISP_TOP_PHY_REG_BASE + ISP_BLK_BA_CSIBDG_LITE, sizeof(struct REG_ISP_CSI_BDG_T)},
};

static struct isp_buffer *isp_byr[ISP_PRERAW_MAX], *isp_byr_se[ISP_PRERAW_MAX];

static spinlock_t buf_lock;
static spinlock_t snr_node_lock[ISP_PRERAW_MAX];

static const char *const CLK_ISP_NAME[] = {
	"clk_sys_0", "clk_sys_1", "clk_sys_2",
	"clk_axi", "clk_csi_be", "clk_isp_top"
};
static const char *const CLK_MAC_NAME[] = {
	"clk_csi_mac0", "clk_csi_mac1"
};

/* vi_proc control */
static int viproc_en[2] = {1, 0};
static int count;
module_param_array(viproc_en, int, &count, 0664);

static int csi_patgen_en[ISP_PRERAW_MAX] = {0, 0};
int cif_auto = 1;
int isp_v4l2_debug;
int burst_i2c_en;
int tile_en;
/* To define the output of proc.
 *
 * 0: default info
 * 1: preraw0 reg-dump
 * 2: preraw1 reg-dump
 * 3: postraw reg-dump
 */
int proc_isp_mode;
/* control internal patgen
 *
 * 1: enable
 * 0: disable
 */
module_param_array(csi_patgen_en, int, &count, 0644);
module_param(cif_auto, int, 0644);
/* v4l2 debug level of isp video device
 * Bigger, more v4l2 debug message.
 */
module_param(isp_v4l2_debug, int, 0644);
module_param(burst_i2c_en, int, 0644);

/* runtime tuning control
 * ctrl:
 *	0: all ch stop update.
 *	1: stop after apply ch1 setting
 *	2: stop after apply ch2 setting
 */
static int tuning_dis[4] = {0, 0, 0, 0}; //ctrl, fe, be, post
module_param_array(tuning_dis, int, &count, 0664);

module_param(tile_en, int, 0644);

/*************************************************************************
 *      Init once tuning parameter
 *************************************************************************/

u16 dci_map_lut[] = {
2,    3,    3,    5,    6,    7,    8,   10,   11,   13,   15,   16,   18,   20,   22,   25,
27,   29,   32,   34,   37,   39,   41,   44,   46,   50,   52,   55,   59,   62,   65,   69,
72,   75,   79,   84,   89,   93,   97,  100,  105,  109,  114,  119,  124,  128,  135,  140,
143,  149,  155,  159,  165,  170,  175,  181,  187,  194,  199,  205,  210,  217,  222,  229,
234,  239,  245,  250,  257,  263,  270,  276,  283,  289,  297,  304,  310,  318,  324,  330,
337,  344,  350,  356,  361,  368,  374,  381,  387,  394,  401,  408,  417,  425,  435,  442,
451,  459,  469,  477,  486,  496,  504,  515,  525,  535,  546,  557,  568,  579,  590,  601,
612,  623,  634,  645,  656,  668,  679,  690,  701,  712,  723,  734,  745,  757,  768,  779,
790,  801,  812,  823,  834, 845,  857,  868,  879,  890,  901,  911,  922,  929,  936,  942,
948,  953,  959,  963,  966,  969,  971,  973,  975,  977,  979,  980,  981,  982,  982,  983,
984,  984,  985,  985,  986,  986,  987,  987,  988,  988,  989,  989,  990,  990,  991,  991,
992,  992,  993,  993,  994,  994,  995,  995,  996,  996,  997,  997,  998,  998,  999,  999,
999, 1000, 1000, 1001, 1001, 1001, 1002, 1002, 1002, 1003, 1003, 1004, 1004, 1004, 1005, 1005,
1005, 1006, 1006, 1007, 1007, 1007, 1008, 1008, 1008, 1009, 1009, 1010, 1010, 1010, 1011, 1011,
1011, 1012, 1012, 1013, 1013, 1013, 1014, 1014, 1014, 1015, 1015, 1016, 1016, 1016, 1017, 1017,
1017, 1018, 1018, 1019, 1019, 1019, 1020, 1020, 1020, 1021, 1021, 1022, 1022, 1022, 1023, 1023
};

u16 dci_map_lut_50[] = {
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50
};

uint16_t lscr_lut[] = {
0x300,   0x310,  0x320,  0x330,  0x340,  0x350,  0x360,  0x370,
0x400,  0x410, 0x420, 0x430, 0x440, 0x450, 0x460, 0x470,
0x500, 0x510, 0x520, 0x530, 0x540, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
};

/* for imx327 tuning */
struct isp_ccm_cfg ccm_hw_cfg = {
	.coef = {
			{1024, 0, 0},
			{0, 0, 0},
			{0, 0, 0},
		},
};

uint16_t gamma_data[] = {
0, 120, 220, 310, 390, 470, 540, 610, 670, 730, 786, 842, 894, 944, 994, 1050, 1096, 1138, 1178,
1218, 1254, 1280, 1314, 1346, 1378, 1408, 1438, 1467, 1493, 1519, 1543, 1568, 1592, 1615, 1638,
1661, 1683, 1705, 1726, 1748, 1769, 1789, 1810, 1830, 1849, 1869, 1888, 1907, 1926, 1945, 1963,
1981, 1999, 2017, 2034, 2052, 2069, 2086, 2102, 2119, 2136, 2152, 2168, 2184, 2200, 2216, 2231,
2247, 2262, 2277, 2292, 2307, 2322, 2337, 2351, 2366, 2380, 2394, 2408, 2422, 2436, 2450, 2464,
2477, 2491, 2504, 2518, 2531, 2544, 2557, 2570, 2583, 2596, 2609, 2621, 2634, 2646, 2659, 2671,
2683, 2696, 2708, 2720, 2732, 2744, 2756, 2767, 2779, 2791, 2802, 2814, 2825, 2837, 2848, 2859,
2871, 2882, 2893, 2904, 2915, 2926, 2937, 2948, 2959, 2969, 2980, 2991, 3001, 3012, 3023, 3033,
3043, 3054, 3064, 3074, 3085, 3095, 3105, 3115, 3125, 3135, 3145, 3155, 3165, 3175, 3185, 3194,
3204, 3214, 3224, 3233, 3243, 3252, 3262, 3271, 3281, 3290, 3300, 3309, 3318, 3327, 3337, 3346,
3355, 3364, 3373, 3382, 3391, 3400, 3409, 3418, 3427, 3436, 3445, 3454, 3463, 3471, 3480, 3489,
3498, 3506, 3515, 3523, 3532, 3540, 3549, 3557, 3566, 3574, 3583, 3591, 3600, 3608, 3616, 3624,
3633, 3641, 3649, 3657, 3665, 3674, 3682, 3690, 3698, 3706, 3714, 3722, 3730, 3738, 3746, 3754,
3762, 3769, 3777, 3785, 3793, 3801, 3808, 3816, 3824, 3832, 3839, 3847, 3855, 3862, 3870, 3877,
3885, 3892, 3900, 3907, 3915, 3922, 3930, 3937, 3945, 3952, 3959, 3967, 3974, 3981, 3989, 3996,
4003, 4010, 4018, 4025, 4032, 4039, 4046, 4054, 4061, 4068, 4075, 4082, 4089, 4095
};
#if 0
uint16_t ycur_data[] = {
0,    4,    8,   12,   16,   20,   24,   28,   32,   36,   40,   44,   48,   52,   56,   60,
64,   68,   72,   76,   80,   84,   88,   92,   96,  100,  104,  108,  112,  116,  120,  124,
128,  132,  136,  140,  144,  148,  152,  156,  160,  164,  168,  172,  176,  180,  184,  188,
192,  196,  200,  204,  208,  212,  216,  220,  224,  228,  232,  236,  240,  244,  248,  252,
255,
};
#else
uint16_t ycur_data[] = {
255,  252,  248,  244,  240,  236,  232,  228,  224,  220,  216,  212,  208,  204,  200,  196,
192,  188,  184,  180,  176,  172,  168,  164,  160,  156,  152,  148,  144,  140,  136,  132,
128,  124,  120,  116,  112,  108,  104,  100,  96,   92,   88,   84,   80,   76,   72,   68,
64,   60,   56,   52,   48,   44,   40,   36,   32,   28,   24,   20,   16,   12,   8,    4,
0,
};
#endif

uint16_t ltm_d_lut[] = {
0,    172,  317,  422,  489,  538,  581,  622,  661,  697,  731,  764,  795,
826,  854,  881,  907,  932,  957,  980,  1004, 1027, 1050, 1072, 1093, 1112,
1129, 1146, 1163, 1180, 1197, 1214, 1230, 1247, 1263, 1279, 1295, 1311, 1327,
1343, 1358, 1373, 1389, 1404, 1419, 1433, 1448, 1463, 1477, 1492, 1506, 1520,
1534, 1548, 1561, 1575, 1589, 1602, 1615, 1628, 1641, 1654, 1667, 1680, 1693,
1705, 1718, 1730, 1742, 1754, 1766, 1778, 1790, 1802, 1813, 1825, 1836, 1848,
1859, 1870, 1881, 1892, 1903, 1914, 1925, 1936, 1946, 1957, 1967, 1977, 1988,
1998, 2008, 2018, 2028, 2038, 2048, 2058, 2067, 2077, 2087, 2096, 2106, 2115,
2125, 2134, 2144, 2153, 2163, 2173, 2182, 2192, 2202, 2211, 2221, 2230, 2240,
2250, 2259, 2269, 2278, 2288, 2298, 2307, 2317, 2326, 2336, 2345, 2355, 2364,
2374, 2383, 2393, 2402, 2412, 2421, 2431, 2440, 2449, 2459, 2468, 2478, 2487,
2496, 2505, 2515, 2524, 2533, 2542, 2551, 2560, 2569, 2578, 2587, 2596, 2605,
2614, 2623, 2632, 2641, 2650, 2658, 2667, 2676, 2684, 2693, 2701, 2710, 2718,
2727, 2735, 2743, 2752, 2760, 2768, 2776, 2784, 2792, 2800, 2808, 2816, 2824,
2832, 2839, 2847, 2854, 2862, 2870, 2877, 2884, 2892, 2899, 2906, 2913, 2920,
2927, 2934, 2941, 2948, 2954, 2961, 2968, 2974, 2981, 2987, 2993, 3000, 3006,
3012, 3018, 3024, 3030, 3035, 3041, 3047, 3052, 3058, 3063, 3068, 3073, 3079,
3084, 3088, 3093, 3098, 3103, 3107, 3112, 3116, 3121, 3125, 3129, 3133, 3137,
3141, 3145, 3148, 3152, 3155, 3159, 3162, 3165, 3168, 3171, 3174, 3177, 3179,
3182, 3184, 3186, 3189, 3191, 3193, 3195, 3196, 3198, 4001,
};

uint16_t ltm_b_lut[] = {
0,    115,  230,  346,  458,  575,  694,  813,  927,  1033, 1129, 1211, 1275,
1321, 1363, 1402, 1438, 1473, 1505, 1536, 1565, 1592, 1617, 1641, 1663, 1684,
1703, 1722, 1739, 1755, 1771, 1786, 1800, 1813, 1827, 1840, 1853, 1866, 1879,
1891, 1904, 1916, 1928, 1940, 1951, 1963, 1974, 1986, 1997, 2007, 2018, 2029,
2039, 2049, 2059, 2069, 2079, 2089, 2098, 2108, 2117, 2126, 2135, 2144, 2153,
2162, 2170, 2178, 2187, 2195, 2203, 2211, 2219, 2227, 2234, 2242, 2249, 2257,
2264, 2271, 2278, 2285, 2292, 2299, 2306, 2312, 2319, 2326, 2332, 2339, 2345,
2351, 2357, 2364, 2370, 2376, 2382, 2388, 2394, 2400, 2405, 2411, 2417, 2423,
2429, 2434, 2440, 2445, 2451, 2457, 2462, 2468, 2473, 2479, 2484, 2490, 2495,
2501, 2507, 2512, 2518, 2523, 2529, 2534, 2540, 2545, 2551, 2557, 2562, 2568,
2573, 2579, 2584, 2589, 2595, 2600, 2605, 2610, 2616, 2621, 2626, 2631, 2636,
2641, 2646, 2651, 2656, 2661, 2665, 2670, 2675, 2680, 2685, 2689, 2694, 2699,
2703, 2708, 2712, 2717, 2721, 2726, 2730, 2735, 2739, 2743, 2748, 2752, 2756,
2761, 2765, 2769, 2773, 2778, 2782, 2786, 2790, 2794, 2798, 2802, 2807, 2811,
2815, 2819, 2823, 2827, 2831, 2835, 2839, 2843, 2846, 2850, 2854, 2858, 2862,
2866, 2870, 2874, 2877, 2881, 2885, 2889, 2893, 2897, 2900, 2904, 2908, 2912,
2915, 2919, 2923, 2927, 2931, 2934, 2938, 2942, 2946, 2949, 2953, 2957, 2961,
2964, 2968, 2972, 2976, 2979, 2983, 2987, 2991, 2994, 2998, 3002, 3006, 3010,
3013, 3017, 3021, 3025, 3029, 3032, 3036, 3040, 3044, 3048, 3052, 3056, 3060,
3064, 3067, 3071, 3075, 3079, 3083, 3087, 3091, 3095, 3100, 3104, 3108, 3112,
3116, 3120, 3124, 3128, 3132, 3136, 3140, 3144, 3148, 3152, 3156, 3160, 3164,
3168, 3173, 3177, 3181, 3185, 3189, 3193, 3197, 3201, 3205, 3209, 3213, 3217,
3221, 3225, 3229, 3233, 3237, 3241, 3245, 3249, 3253, 3257, 3261, 3265, 3269,
3273, 3277, 3281, 3285, 3289, 3293, 3297, 3301, 3305, 3309, 3313, 3317, 3321,
3325, 3329, 3333, 3337, 3341, 3345, 3349, 3353, 3357, 3361, 3365, 3369, 3373,
3377, 3381, 3385, 3389, 3393, 3397, 3401, 3405, 3409, 3413, 3417, 3421, 3425,
3429, 3433, 3437, 3441, 3445, 3449, 3453, 3457, 3461, 3465, 3469, 3472, 3476,
3480, 3484, 3488, 3492, 3496, 3500, 3504, 3508, 3512, 3516, 3520, 3524, 3528,
3532, 3536, 3539, 3543, 3547, 3551, 3555, 3559, 3563, 3567, 3571, 3575, 3579,
3583, 3586, 3590, 3594, 3598, 3602, 3606, 3610, 3614, 3618, 3622, 3625, 3629,
3633, 3637, 3641, 3645, 3649, 3653, 3657, 3660, 3664, 3668, 3672, 3676, 3680,
3684, 3687, 3691, 3695, 3699, 3703, 3707, 3711, 3714, 3718, 3722, 3726, 3730,
3734, 3738, 3741, 3745, 3749, 3753, 3757, 3761, 3764, 3768, 3772, 3776, 3780,
3784, 3787, 3791, 3795, 3799, 3803, 3806, 3810, 3814, 3818, 3822, 3826, 3829,
3833, 3837, 3841, 3845, 3848, 3852, 3856, 3860, 3863, 3867, 3871, 3875, 3879,
3882, 3886, 3890, 3894, 3897, 3901, 3905, 3909, 3913, 3916, 3920, 3924, 3928,
3931, 3935, 3939, 3943, 3946, 3950, 3954, 3958, 3961, 3965, 3969, 3972, 3976,
3980, 3984, 3987, 3991, 3995, 3999, 4002, 4006, 4010, 4013, 4017, 4021, 4025,
4028, 4032, 4036, 4039, 4043, 4047, 4050, 4054, 4058, 4061, 4065, 4069, 4073,
4076, 4080, 4084, 4087, 4091, 4095,
};

uint16_t ltm_g_lut[] = {
0,    48,   96,   142,  187,  231,  273,  313,  352,  389,  425,  458,  490,
520,  549,  577,  605,  632,  659,  686,  714,  741,  769,  796,  824,  851,
878,  905,  932,  959,  986,  1013, 1039, 1066, 1092, 1118, 1144, 1170, 1196,
1222, 1247, 1272, 1297, 1322, 1347, 1371, 1395, 1420, 1443, 1467, 1490, 1513,
1536, 1558, 1581, 1603, 1625, 1647, 1668, 1690, 1711, 1732, 1754, 1775, 1796,
1817, 1839, 1860, 1880, 1901, 1922, 1942, 1962, 1982, 2001, 2020, 2039, 2057,
2075, 2092, 2110, 2126, 2142, 2158, 2174, 2190, 2205, 2220, 2234, 2249, 2263,
2277, 2290, 2304, 2317, 2330, 2342, 2355, 2367, 2380, 2392, 2405, 2417, 2429,
2441, 2453, 2465, 2477, 2489, 2500, 2511, 2522, 2533, 2544, 2555, 2565, 2575,
2585, 2595, 2605, 2614, 2623, 2632, 2641, 2649, 2658, 2665, 2673, 2681, 2688,
2695, 2703, 2709, 2716, 2723, 2729, 2736, 2742, 2748, 2754, 2759, 2765, 2770,
2776, 2781, 2786, 2791, 2796, 2801, 2806, 2811, 2816, 2821, 2826, 2831, 2836,
2841, 2846, 2851, 2856, 2861, 2866, 2871, 2876, 2881, 2885, 2890, 2895, 2900,
2905, 2910, 2914, 2919, 2924, 2928, 2933, 2938, 2942, 2947, 2952, 2956, 2961,
2965, 2970, 2974, 2979, 2983, 2988, 2992, 2996, 3001, 3005, 3009, 3013, 3018,
3022, 3026, 3030, 3034, 3038, 3042, 3046, 3050, 3054, 3058, 3062, 3066, 3069,
3073, 3077, 3080, 3084, 3088, 3091, 3095, 3098, 3102, 3105, 3108, 3112, 3115,
3118, 3121, 3124, 3127, 3130, 3133, 3136, 3139, 3142, 3145, 3148, 3150, 3153,
3156, 3158, 3161, 3163, 3166, 3168, 3170, 3173, 3175, 3177, 3179, 3181, 3183,
3185, 3187, 3189, 3190, 3192, 3194, 3195, 3197, 3198, 3200, 3210, 3221, 3232,
3242, 3252, 3262, 3272, 3282, 3291, 3300, 3310, 3319, 3327, 3336, 3345, 3353,
3361, 3369, 3377, 3385, 3393, 3400, 3408, 3415, 3422, 3429, 3436, 3443, 3450,
3456, 3462, 3469, 3475, 3481, 3487, 3493, 3498, 3504, 3509, 3515, 3520, 3525,
3530, 3535, 3540, 3545, 3549, 3554, 3559, 3563, 3567, 3572, 3576, 3580, 3584,
3588, 3592, 3595, 3599, 3603, 3606, 3610, 3613, 3617, 3620, 3624, 3627, 3630,
3633, 3636, 3639, 3642, 3645, 3648, 3651, 3654, 3656, 3659, 3662, 3665, 3667,
3670, 3673, 3675, 3678, 3680, 3683, 3685, 3688, 3690, 3693, 3695, 3698, 3700,
3703, 3705, 3707, 3710, 3712, 3715, 3717, 3719, 3721, 3724, 3726, 3728, 3730,
3733, 3735, 3737, 3739, 3741, 3743, 3745, 3747, 3749, 3751, 3753, 3755, 3757,
3759, 3761, 3763, 3765, 3767, 3769, 3771, 3772, 3774, 3776, 3778, 3780, 3781,
3783, 3785, 3787, 3788, 3790, 3792, 3793, 3795, 3797, 3798, 3800, 3801, 3803,
3805, 3806, 3808, 3809, 3811, 3812, 3814, 3815, 3817, 3818, 3820, 3821, 3823,
3824, 3825, 3827, 3828, 3829, 3831, 3832, 3834, 3835, 3836, 3838, 3839, 3840,
3841, 3843, 3844, 3845, 3847, 3848, 3849, 3850, 3851, 3853, 3854, 3855, 3856,
3858, 3859, 3860, 3861, 3862, 3863, 3865, 3866, 3867, 3868, 3869, 3870, 3871,
3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3884, 3885, 3886,
3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3900,
3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913,
3914, 3915, 3916, 3917, 3918, 3919, 3920, 3922, 3923, 3924, 3925, 3926, 3927,
3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940,
3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953,
3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966,
3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979,
3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991,
3992, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4002,
4003, 4004, 4005, 4006, 4007, 4008, 4009, 4009, 4010, 4011, 4012, 4013, 4014,
4015, 4015, 4016, 4017, 4018, 4019, 4020, 4020, 4021, 4022, 4023, 4024, 4024,
4025, 4026, 4027, 4028, 4028, 4029, 4030, 4031, 4032, 4032, 4033, 4034, 4035,
4035, 4036, 4037, 4038, 4039, 4039, 4040, 4041, 4041, 4042, 4043, 4044, 4044,
4045, 4046, 4047, 4047, 4048, 4049, 4049, 4050, 4051, 4051, 4052, 4053, 4053,
4054, 4055, 4055, 4056, 4057, 4057, 4058, 4059, 4059, 4060, 4061, 4061, 4062,
4062, 4063, 4064, 4064, 4065, 4065, 4066, 4067, 4067, 4068, 4068, 4069, 4069,
4070, 4071, 4071, 4072, 4072, 4073, 4073, 4074, 4074, 4075, 4075, 4076, 4076,
4077, 4077, 4078, 4078, 4079, 4079, 4080, 4080, 4081, 4081, 4082, 4082, 4082,
4083, 4083, 4084, 4084, 4085, 4085, 4085, 4086, 4086, 4087, 4087, 4087, 4088,
4088, 4088, 4089, 4089, 4089, 4090, 4090, 4090, 4091, 4091, 4091, 4092, 4092,
4092, 4093, 4093, 4093, 4093, 4094, 4094, 4094, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
4095, 4095,
};
#if 0
uint16_t c_lut_r_lut[] = {
0,   64,	128,  192,  256,  320,	384,  448,  512,  575,	639,  703,  767,  831,	895,  959,
1023,   64,	 90,  143,  202,  264,	326,  389,  452,  515,	579,  643,  706,  770,	834,  897,
961, 1023,	128,  143,  181,  231,	286,  344,  404,  465,	527,  589,  652,  715,	778,  841,
904,  968, 1023,  192,  202,  231,	271,  320,  373,  429,	487,  546,  607,  668,	729,  791,
853,  915,	978, 1023,  256,  264,	286,  320,  362,  409,	461,  515,  572,  630,	689,  748,
809,  870,	931,  993, 1023,  320,	326,  344,  373,  409,	452,  499,  550,  603,	658,  715,
773,  831,	891,  950, 1011, 1023,	384,  389,  404,  429,	461,  499,  543,  589,	639,  692,
746,  801,	858,  915,  974, 1023, 1023,  448,  452,  465,	487,  515,  550,  589,	633,  680,
729,  780,	834,  888,  944, 1001, 1023, 1023,  512,  515,	527,  546,  572,  603,	639,  680,
723,  770,	819,  870,  922,  976, 1023, 1023, 1023,  575,	579,  589,  607,  630,	658,  692,
729,  770,	814,  860,  909,  959, 1011, 1023, 1023, 1023,	639,  643,  652,  668,	689,  715,
746,  780,	819,  860,  904,  950,	999, 1023, 1023, 1023, 1023,  703,  706,  715,	729,  748,
773,  801,	834,  870,  909,  950,	995, 1023, 1023, 1023, 1023, 1023,  767,  770,	778,  791,
809,  831,	858,  888,  922,  959,	999, 1023, 1023, 1023, 1023, 1023, 1023,  831,	834,  841,
853,  870,	891,  915,  944,  976, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023,	895,  897,
904,  915,	931,  950,  974, 1001, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  959,
961,  968,	978,  993, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,   64,	 90,  143,  202,  264,	326,  389,  452,  515,	579,  643,  706,  770,	834,  897,
961, 1023,	 90,  111,  157,  212,	271,  332,  394,  457,	519,  582,  646,  709,	773,  836,
900,  963, 1023,  143,  157,  192,	239,  293,  350,  409,	470,  531,  593,  655,	718,  780,
843,  906,	970, 1023,  202,  212,	239,  279,  326,  378,	434,  491,  550,  610,	671,  732,
793,  855,	918,  980, 1023,  264,	271,  293,  326,  367,	414,  465,  519,  575,	633,  692,
751,  811,	872,  933,  995, 1023,	326,  332,  350,  378,	414,  457,  503,  554,	607,  661,
718,  775,	834,  893,  953, 1013, 1023,  389,  394,  409,	434,  465,  503,  546,	593,  643,
695,  748,	804,  860,  918,  976, 1023, 1023,  452,  457,	470,  491,  519,  554,	593,  636,
683,  732,	783,  836,  891,  946, 1003, 1023, 1023,  515,	519,  531,  550,  575,	607,  643,
683,  726,	773,  821,  872,  924,	978, 1023, 1023, 1023,	579,  582,  593,  610,	633,  661,
695,  732,	773,  816,  863,  911,	961, 1013, 1023, 1023, 1023,  643,  646,  655,	671,  692,
718,  748,	783,  821,  863,  906,	953, 1001, 1023, 1023, 1023, 1023,  706,  709,	718,  732,
751,  775,	804,  836,  872,  911,	953,  997, 1023, 1023, 1023, 1023, 1023,  770,	773,  780,
793,  811,	834,  860,  891,  924,	961, 1001, 1023, 1023, 1023, 1023, 1023, 1023,	834,  836,
843,  855,	872,  893,  918,  946,	978, 1013, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  897,
900,  906,	918,  933,  953,  976, 1003, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
961,  963,	970,  980,  995, 1013, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	128,  143,  181,  231,	286,  344,  404,  465,	527,  589,  652,  715,	778,  841,
904,  968, 1023,  143,  157,  192,	239,  293,  350,  409,	470,  531,  593,  655,	718,  780,
843,  906,	970, 1023,  181,  192,	221,  264,  313,  367,	424,  483,  543,  603,	664,  726,
788,  851,	913,  976, 1023,  231,	239,  264,  300,  344,	394,  448,  503,  561,	620,  680,
740,  801,	863,  924,  986, 1023,	286,  293,  313,  344,	384,  429,  478,  531,	586,  643,
700,  759,	819,  879,  940, 1001, 1023,  344,  350,  367,	394,  429,  470,  515,	565,  617,
671,  726,	783,  841,  900,  959, 1019, 1023,  404,  409,	424,  448,  478,  515,	557,  603,
652,  703,	757,  811,  867,  924,	982, 1023, 1023,  465,	470,  483,  503,  531,	565,  603,
646,  692,	740,  791,  843,  897,	953, 1009, 1023, 1023,	527,  531,  543,  561,	586,  617,
652,  692,	735,  780,  829,  879,	931,  984, 1023, 1023, 1023,  589,  593,  603,	620,  643,
671,  703,	740,  780,  824,  870,	918,  968, 1019, 1023, 1023, 1023,  652,  655,	664,  680,
700,  726,	757,  791,  829,  870,	913,  959, 1007, 1023, 1023, 1023, 1023,  715,	718,  726,
740,  759,	783,  811,  843,  879,	918,  959, 1003, 1023, 1023, 1023, 1023, 1023,	778,  780,
788,  801,	819,  841,  867,  897,	931,  968, 1007, 1023, 1023, 1023, 1023, 1023, 1023,  841,
843,  851,	863,  879,  900,  924,	953,  984, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
904,  906,	913,  924,  940,  959,	982, 1009, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  968,	970,  976,  986, 1001, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  192,  202,  231,	271,  320,  373,  429,	487,  546,  607,  668,	729,  791,
853,  915,	978, 1023,  202,  212,	239,  279,  326,  378,	434,  491,  550,  610,	671,  732,
793,  855,	918,  980, 1023,  231,	239,  264,  300,  344,	394,  448,  503,  561,	620,  680,
740,  801,	863,  924,  986, 1023,	271,  279,  300,  332,	373,  419,  470,  523,	579,  636,
695,  754,	814,  874,  935,  997, 1023,  320,  326,  344,	373,  409,  452,  499,	550,  603,
658,  715,	773,  831,  891,  950, 1011, 1023,  373,  378,	394,  419,  452,  491,	535,  582,
633,  686,	740,  796,  853,  911,	970, 1023, 1023,  429,	434,  448,  470,  499,	535,  575,
620,  668,	718,  770,  824,  879,	935,  993, 1023, 1023,	487,  491,  503,  523,	550,  582,
620,  661,	706,  754,  804,  855,	909,  963, 1019, 1023, 1023,  546,  550,  561,	579,  603,
633,  668,	706,  748,  793,  841,	891,  942,  995, 1023, 1023, 1023,  607,  610,	620,  636,
658,  686,	718,  754,  793,  836,	881,  929,  978, 1023, 1023, 1023, 1023,  668,	671,  680,
695,  715,	740,  770,  804,  841,	881,  924,  970, 1017, 1023, 1023, 1023, 1023,	729,  732,
740,  754,	773,  796,  824,  855,	891,  929,  970, 1013, 1023, 1023, 1023, 1023, 1023,  791,
793,  801,	814,  831,  853,  879,	909,  942,  978, 1017, 1023, 1023, 1023, 1023, 1023, 1023,
853,  855,	863,  874,  891,  911,	935,  963,  995, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  915,	918,  924,  935,  950,	970,  993, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	978,  980,  986,  997, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  256,  264,	286,  320,  362,  409,	461,  515,  572,  630,	689,  748,
809,  870,	931,  993, 1023,  264,	271,  293,  326,  367,	414,  465,  519,  575,	633,  692,
751,  811,	872,  933,  995, 1023,	286,  293,  313,  344,	384,  429,  478,  531,	586,  643,
700,  759,	819,  879,  940, 1001, 1023,  320,  326,  344,	373,  409,  452,  499,	550,  603,
658,  715,	773,  831,  891,  950, 1011, 1023,  362,  367,	384,  409,  443,  483,	527,  575,
626,  680,	735,  791,  848,  906,	965, 1023, 1023,  409,	414,  429,  452,  483,	519,  561,
607,  655,	706,  759,  814,  870,	927,  984, 1023, 1023,	461,  465,  478,  499,	527,  561,
600,  643,	689,  737,  788,  841,	895,  950, 1007, 1023, 1023,  515,  519,  531,	550,  575,
607,  643,	683,  726,  773,  821,	872,  924,  978, 1023, 1023, 1023,  572,  575,	586,  603,
626,  655,	689,  726,  767,  811,	858,  906,  957, 1009, 1023, 1023, 1023,  630,	633,  643,
658,  680,	706,  737,  773,  811,	853,  897,  944,  993, 1023, 1023, 1023, 1023,	689,  692,
700,  715,	735,  759,  788,  821,	858,  897,  940,  984, 1023, 1023, 1023, 1023, 1023,  748,
751,  759,	773,  791,  814,  841,	872,  906,  944,  984, 1023, 1023, 1023, 1023, 1023, 1023,
809,  811,	819,  831,  848,  870,	895,  924,  957,  993, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  870,	872,  879,  891,  906,	927,  950,  978, 1009, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	931,  933,  940,  950,	965,  984, 1007, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  993,  995, 1001, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  320,	326,  344,  373,  409,	452,  499,  550,  603,	658,  715,
773,  831,	891,  950, 1011, 1023,	326,  332,  350,  378,	414,  457,  503,  554,	607,  661,
718,  775,	834,  893,  953, 1013, 1023,  344,  350,  367,	394,  429,  470,  515,	565,  617,
671,  726,	783,  841,  900,  959, 1019, 1023,  373,  378,	394,  419,  452,  491,	535,  582,
633,  686,	740,  796,  853,  911,	970, 1023, 1023,  409,	414,  429,  452,  483,	519,  561,
607,  655,	706,  759,  814,  870,	927,  984, 1023, 1023,	452,  457,  470,  491,	519,  554,
593,  636,	683,  732,  783,  836,	891,  946, 1003, 1023, 1023,  499,  503,  515,	535,  561,
593,  630,	671,  715,  762,  811,	863,  915,  970, 1023, 1023, 1023,  550,  554,	565,  582,
607,  636,	671,  709,  751,  796,	843,  893,  944,  997, 1023, 1023, 1023,  603,	607,  617,
633,  655,	683,  715,  751,  791,	834,  879,  927,  976, 1023, 1023, 1023, 1023,	658,  661,
671,  686,	706,  732,  762,  796,	834,  874,  918,  963, 1011, 1023, 1023, 1023, 1023,  715,
718,  726,	740,  759,  783,  811,	843,  879,  918,  959, 1003, 1023, 1023, 1023, 1023, 1023,
773,  775,	783,  796,  814,  836,	863,  893,  927,  963, 1003, 1023, 1023, 1023, 1023, 1023,
1023,  831,	834,  841,  853,  870,	891,  915,  944,  976, 1011, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	891,  893,  900,  911,	927,  946,  970,  997, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  950,  953,  959,	970,  984, 1003, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1011, 1013, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023,	384,  389,  404,  429,	461,  499,  543,  589,	639,  692,
746,  801,	858,  915,  974, 1023, 1023,  389,  394,  409,	434,  465,  503,  546,	593,  643,
695,  748,	804,  860,  918,  976, 1023, 1023,  404,  409,	424,  448,  478,  515,	557,  603,
652,  703,	757,  811,  867,  924,	982, 1023, 1023,  429,	434,  448,  470,  499,	535,  575,
620,  668,	718,  770,  824,  879,	935,  993, 1023, 1023,	461,  465,  478,  499,	527,  561,
600,  643,	689,  737,  788,  841,	895,  950, 1007, 1023, 1023,  499,  503,  515,	535,  561,
593,  630,	671,  715,  762,  811,	863,  915,  970, 1023, 1023, 1023,  543,  546,	557,  575,
600,  630,	664,  703,  746,  791,	839,  888,  940,  993, 1023, 1023, 1023,  589,	593,  603,
620,  643,	671,  703,  740,  780,	824,  870,  918,  968, 1019, 1023, 1023, 1023,	639,  643,
652,  668,	689,  715,  746,  780,	819,  860,  904,  950,	999, 1023, 1023, 1023, 1023,  692,
695,  703,	718,  737,  762,  791,	824,  860,  900,  942,	986, 1023, 1023, 1023, 1023, 1023,
746,  748,	757,  770,  788,  811,	839,  870,  904,  942,	982, 1023, 1023, 1023, 1023, 1023,
1023,  801,	804,  811,  824,  841,	863,  888,  918,  950,	986, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	858,  860,  867,  879,	895,  915,  940,  968,	999, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  915,  918,  924,	935,  950,  970,  993, 1019, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  974,  976,	982,  993, 1007, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023,  448,  452,  465,	487,  515,  550,  589,	633,  680,
729,  780,	834,  888,  944, 1001, 1023, 1023,  452,  457,	470,  491,  519,  554,	593,  636,
683,  732,	783,  836,  891,  946, 1003, 1023, 1023,  465,	470,  483,  503,  531,	565,  603,
646,  692,	740,  791,  843,  897,	953, 1009, 1023, 1023,	487,  491,  503,  523,	550,  582,
620,  661,	706,  754,  804,  855,	909,  963, 1019, 1023, 1023,  515,  519,  531,	550,  575,
607,  643,	683,  726,  773,  821,	872,  924,  978, 1023, 1023, 1023,  550,  554,	565,  582,
607,  636,	671,  709,  751,  796,	843,  893,  944,  997, 1023, 1023, 1023,  589,	593,  603,
620,  643,	671,  703,  740,  780,	824,  870,  918,  968, 1019, 1023, 1023, 1023,	633,  636,
646,  661,	683,  709,  740,  775,	814,  855,  900,  946,	995, 1023, 1023, 1023, 1023,  680,
683,  692,	706,  726,  751,  780,	814,  851,  891,  933,	978, 1023, 1023, 1023, 1023, 1023,
729,  732,	740,  754,  773,  796,	824,  855,  891,  929,	970, 1013, 1023, 1023, 1023, 1023,
1023,  780,	783,  791,  804,  821,	843,  870,  900,  933,	970, 1009, 1023, 1023, 1023, 1023,
1023, 1023,	834,  836,  843,  855,	872,  893,  918,  946,	978, 1013, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  888,  891,  897,	909,  924,  944,  968,	995, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  944,  946,	953,  963,  978,  997, 1019, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1001, 1003, 1009, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  512,  515,	527,  546,  572,  603,	639,  680,
723,  770,	819,  870,  922,  976, 1023, 1023, 1023,  515,	519,  531,  550,  575,	607,  643,
683,  726,	773,  821,  872,  924,	978, 1023, 1023, 1023,	527,  531,  543,  561,	586,  617,
652,  692,	735,  780,  829,  879,	931,  984, 1023, 1023, 1023,  546,  550,  561,	579,  603,
633,  668,	706,  748,  793,  841,	891,  942,  995, 1023, 1023, 1023,  572,  575,	586,  603,
626,  655,	689,  726,  767,  811,	858,  906,  957, 1009, 1023, 1023, 1023,  603,	607,  617,
633,  655,	683,  715,  751,  791,	834,  879,  927,  976, 1023, 1023, 1023, 1023,	639,  643,
652,  668,	689,  715,  746,  780,	819,  860,  904,  950,	999, 1023, 1023, 1023, 1023,  680,
683,  692,	706,  726,  751,  780,	814,  851,  891,  933,	978, 1023, 1023, 1023, 1023, 1023,
723,  726,	735,  748,  767,  791,	819,  851,  886,  924,	965, 1009, 1023, 1023, 1023, 1023,
1023,  770,	773,  780,  793,  811,	834,  860,  891,  924,	961, 1001, 1023, 1023, 1023, 1023,
1023, 1023,	819,  821,  829,  841,	858,  879,  904,  933,	965, 1001, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  870,  872,  879,	891,  906,  927,  950,	978, 1009, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  922,  924,	931,  942,  957,  976,	999, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  976,	978,  984,  995, 1009, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  575,	579,  589,  607,  630,	658,  692,
729,  770,	814,  860,  909,  959, 1011, 1023, 1023, 1023,	579,  582,  593,  610,	633,  661,
695,  732,	773,  816,  863,  911,	961, 1013, 1023, 1023, 1023,  589,  593,  603,	620,  643,
671,  703,	740,  780,  824,  870,	918,  968, 1019, 1023, 1023, 1023,  607,  610,	620,  636,
658,  686,	718,  754,  793,  836,	881,  929,  978, 1023, 1023, 1023, 1023,  630,	633,  643,
658,  680,	706,  737,  773,  811,	853,  897,  944,  993, 1023, 1023, 1023, 1023,	658,  661,
671,  686,	706,  732,  762,  796,	834,  874,  918,  963, 1011, 1023, 1023, 1023, 1023,  692,
695,  703,	718,  737,  762,  791,	824,  860,  900,  942,	986, 1023, 1023, 1023, 1023, 1023,
729,  732,	740,  754,  773,  796,	824,  855,  891,  929,	970, 1013, 1023, 1023, 1023, 1023,
1023,  770,	773,  780,  793,  811,	834,  860,  891,  924,	961, 1001, 1023, 1023, 1023, 1023,
1023, 1023,	814,  816,  824,  836,	853,  874,  900,  929,	961,  997, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  860,  863,  870,	881,  897,  918,  942,	970, 1001, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  909,  911,	918,  929,  944,  963,	986, 1013, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  959,	961,  968,  978,  993, 1011, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1011, 1013, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,	639,  643,  652,  668,	689,  715,
746,  780,	819,  860,  904,  950,	999, 1023, 1023, 1023, 1023,  643,  646,  655,	671,  692,
718,  748,	783,  821,  863,  906,	953, 1001, 1023, 1023, 1023, 1023,  652,  655,	664,  680,
700,  726,	757,  791,  829,  870,	913,  959, 1007, 1023, 1023, 1023, 1023,  668,	671,  680,
695,  715,	740,  770,  804,  841,	881,  924,  970, 1017, 1023, 1023, 1023, 1023,	689,  692,
700,  715,	735,  759,  788,  821,	858,  897,  940,  984, 1023, 1023, 1023, 1023, 1023,  715,
718,  726,	740,  759,  783,  811,	843,  879,  918,  959, 1003, 1023, 1023, 1023, 1023, 1023,
746,  748,	757,  770,  788,  811,	839,  870,  904,  942,	982, 1023, 1023, 1023, 1023, 1023,
1023,  780,	783,  791,  804,  821,	843,  870,  900,  933,	970, 1009, 1023, 1023, 1023, 1023,
1023, 1023,	819,  821,  829,  841,	858,  879,  904,  933,	965, 1001, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  860,  863,  870,	881,  897,  918,  942,	970, 1001, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  904,  906,	913,  924,  940,  959,	982, 1009, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  950,	953,  959,  970,  984, 1003, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023,	999, 1001, 1007, 1017, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  703,  706,  715,	729,  748,
773,  801,	834,  870,  909,  950,	995, 1023, 1023, 1023, 1023, 1023,  706,  709,	718,  732,
751,  775,	804,  836,  872,  911,	953,  997, 1023, 1023, 1023, 1023, 1023,  715,	718,  726,
740,  759,	783,  811,  843,  879,	918,  959, 1003, 1023, 1023, 1023, 1023, 1023,	729,  732,
740,  754,	773,  796,  824,  855,	891,  929,  970, 1013, 1023, 1023, 1023, 1023, 1023,  748,
751,  759,	773,  791,  814,  841,	872,  906,  944,  984, 1023, 1023, 1023, 1023, 1023, 1023,
773,  775,	783,  796,  814,  836,	863,  893,  927,  963, 1003, 1023, 1023, 1023, 1023, 1023,
1023,  801,	804,  811,  824,  841,	863,  888,  918,  950,	986, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	834,  836,  843,  855,	872,  893,  918,  946,	978, 1013, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  870,  872,  879,	891,  906,  927,  950,	978, 1009, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  909,  911,	918,  929,  944,  963,	986, 1013, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  950,	953,  959,  970,  984, 1003, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023,	995,  997, 1003, 1013, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  767,  770,	778,  791,
809,  831,	858,  888,  922,  959,	999, 1023, 1023, 1023, 1023, 1023, 1023,  770,	773,  780,
793,  811,	834,  860,  891,  924,	961, 1001, 1023, 1023, 1023, 1023, 1023, 1023,	778,  780,
788,  801,	819,  841,  867,  897,	931,  968, 1007, 1023, 1023, 1023, 1023, 1023, 1023,  791,
793,  801,	814,  831,  853,  879,	909,  942,  978, 1017, 1023, 1023, 1023, 1023, 1023, 1023,
809,  811,	819,  831,  848,  870,	895,  924,  957,  993, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  831,	834,  841,  853,  870,	891,  915,  944,  976, 1011, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	858,  860,  867,  879,	895,  915,  940,  968,	999, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  888,  891,  897,	909,  924,  944,  968,	995, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  922,  924,	931,  942,  957,  976,	999, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  959,	961,  968,  978,  993, 1011, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023,	999, 1001, 1007, 1017, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  831,	834,  841,
853,  870,	891,  915,  944,  976, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023,	834,  836,
843,  855,	872,  893,  918,  946,	978, 1013, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  841,
843,  851,	863,  879,  900,  924,	953,  984, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
853,  855,	863,  874,  891,  911,	935,  963,  995, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  870,	872,  879,  891,  906,	927,  950,  978, 1009, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	891,  893,  900,  911,	927,  946,  970,  997, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  915,  918,  924,	935,  950,  970,  993, 1019, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  944,  946,	953,  963,  978,  997, 1019, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  976,	978,  984,  995, 1009, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1011, 1013, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,	895,  897,
904,  915,	931,  950,  974, 1001, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  897,
900,  906,	918,  933,  953,  976, 1003, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
904,  906,	913,  924,  940,  959,	982, 1009, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  915,	918,  924,  935,  950,	970,  993, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	931,  933,  940,  950,	965,  984, 1007, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  950,  953,  959,	970,  984, 1003, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  974,  976,	982,  993, 1007, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1001, 1003, 1009, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  959,
961,  968,	978,  993, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
961,  963,	970,  980,  995, 1013, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  968,	970,  976,  986, 1001, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	978,  980,  986,  997, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  993,  995, 1001, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1011, 1013, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,
};

uint16_t c_lut_g_lut[] = {
0, 4,	  8,   12,   16,   20,	 24,   28,   32,   36,	 40,   44,   48,   52,	 56,   60,
64, 4,	  6,	9,   13,   16,	 20,   24,   28,   32,	 36,   40,   44,   48,	 52,   56,
60,   64,	  8,	9,   11,   14,	 18,   22,   25,   29,	 33,   37,   41,   45,	 49,   53,
57,   60,	 64,   12,   13,   14,	 17,   20,   23,   27,	 30,   34,   38,   42,	 46,   49,
53,   57,	 61,   65,   16,   16,	 18,   20,   23,   26,	 29,   32,   36,   39,	 43,   47,
51,   54,	 58,   62,   66,   20,	 20,   22,   23,   26,	 28,   31,   34,   38,	 41,   45,
48,   52,	 56,   59,   63,   67,	 24,   24,   25,   27,	 29,   31,   34,   37,	 40,   43,
47,   50,	 54,   57,   61,   65,	 68,   28,   28,   29,	 30,   32,   34,   37,	 40,   42,
46,   49,	 52,   56,   59,   63,	 66,   70,   32,   32,	 33,   34,   36,   38,	 40,   42,
45,   48,	 51,   54,   58,   61,	 64,   68,   71,   36,	 36,   37,   38,   39,	 41,   43,
46,   48,	 51,   54,   57,   60,	 63,   67,   70,   73,	 40,   40,   41,   42,	 43,   45,
47,   49,	 51,   54,   57,   59,	 62,   66,   69,   72,	 75,   44,   44,   45,	 46,   47,
48,   50,	 52,   54,   57,   59,	 62,   65,   68,   71,	 74,   78,   48,   48,	 49,   49,
51,   52,	 54,   56,   58,   60,	 62,   65,   68,   71,	 74,   77,   80,   52,	 52,   53,
53,   54,	 56,   57,   59,   61,	 63,   66,   68,   71,	 73,   76,   79,   82,	 56,   56,
57,   57,	 58,   59,   61,   63,	 64,   67,   69,   71,	 74,   76,   79,   82,	 85,   60,
60,   60,	 61,   62,   63,   65,	 66,   68,   70,   72,	 74,   77,   79,   82,	 85,   88,
64,   64,	 64,   65,   66,   67,	 68,   70,   71,   73,	 75,   78,   80,   82,	 85,   88,
90, 8,	 11,   18,   25,   33,	 41,   49,   57,   64,	 72,   80,   88,   96,	104,  112,
120,  128,	 11,   14,   20,   27,	 34,   42,   49,   57,	 65,   73,   81,   89,	 97,  105,
112,  120,	128,   18,   20,   24,	 30,   37,   44,   51,	 59,   66,   74,   82,	 90,   98,
105,  113,	121,  129,   25,   27,	 30,   35,   41,   47,	 54,   61,   69,   76,	 84,   91,
99,  107,	115,  123,  130,   33,	 34,   37,   41,   46,	 52,   58,   65,   72,	 79,   86,
94,  101,	109,  117,  124,  132,	 41,   42,   44,   47,	 52,   57,   63,   69,	 76,   83,
90,   97,	104,  112,  119,  127,	134,   49,   49,   51,	 54,   58,   63,   68,	 74,   80,
87,   94,	100,  108,  115,  122,	129,  137,   57,   57,	 59,   61,   65,   69,	 74,   80,
85,   91,	 98,  105,  111,  118,	125,  133,  140,   64,	 65,   66,   69,   72,	 76,   80,
85,   91,	 97,  103,  109,  116,	122,  129,  136,  143,	 72,   73,   74,   76,	 79,   83,
87,   91,	 97,  102,  108,  114,	120,  127,  133,  140,	147,   80,   81,   82,	 84,   86,
90,   94,	 98,  103,  108,  113,	119,  125,  131,  138,	144,  151,   88,   89,	 90,   91,
94,   97,	100,  105,  109,  114,	119,  125,  130,  136,	143,  149,  155,   96,	 97,   98,
99,  101,	104,  108,  111,  116,	120,  125,  130,  136,	142,  148,  154,  160,	104, 105,
105,  107,	109,  112,  115,  118,	122,  127,  131,  136,	142,  147,  153,  159,	165, 112,
112,  113,	115,  117,  119,  122,	125,  129,  133,  138,	143,  148,  153,  158,	164, 170,
120,  120,	121,  123,  124,  127,	129,  133,  136,  140,	144,  149,  154,  159,	164, 170,
175,  128,	128,  129,  130,  132,	134,  137,  140,  143,	147,  151,  155,  160,	165, 170,
175,  181,	 24,   27,   34,   43,	 54,   65,   76,   87,	 99,  111,  122,  134,	146,  158,
170,  181,	193,   27,   29,   36,	 45,   55,   66,   77,	 88,  100,  111,  123,	135,  146,
158,  170,	182,  194,   34,   36,	 42,   49,   59,   69,	 80,   91,  102,  113,	125,  136,
148,  159,	171,  183,  195,   43,	 45,   49,   56,   65,	 74,   84,   94,  105,	116,  127,
139,  150,	162,  173,  185,  197,	 54,   55,   59,   65,	 72,   80,   90,  100,	110, 120,
131,  142,	154,  165,  176,  188,	199,   65,   66,   69,	 74,   80,   88,   97,	106,  116,
126,  136,	147,  158,  169,  180,	191,  202,   76,   77,	 80,   84,   90,   97,	105,  113,
122,  132,	142,  152,  163,  173,	184,  195,  206,   87,	 88,   91,   94,  100,	106, 113,
121,  130,	139,  148,  158,  168,	179,  189,  200,  211,	 99,  100,  102,  105,	110, 116,
122,  130,	138,  146,  155,  165,	175,  185,  195,  205,	216,  111,  111,  113,	116, 120,
126,  132,	139,  146,  154,  163,	172,  181,  191,  201,	211,  221,  122,  123,	125, 127,
131,  136,	142,  148,  155,  163,	171,  180,  189,  198,	208,  217,  227,  134,	135, 136,
139,  142,	147,  152,  158,  165,	172,  180,  188,  197,	206,  215,  224,  234,	146, 146,
148,  150,	154,  158,  163,  168,	175,  181,  189,  197,	205,  213,  222,  232,	241, 158,
158,  159,	162,  165,  169,  173,	179,  185,  191,  198,	206,  213,  222,  230,	239, 248,
170,  170,	171,  173,  176,  180,	184,  189,  195,  201,	208,  215,  222,  230,	239, 247,
256,  181,	182,  183,  185,  188,	191,  195,  200,  205,	211,  217,  224,  232,	239, 247,
255,  264,	193,  194,  195,  197,	199,  202,  206,  211,	216,  221,  227,  234,	241, 248,
256,  264,	272,   48,   51,   58,	 68,   80,   93,  107,	122,  137,  152,  167,	182, 198,
213,  229,	245,  260,   51,   53,	 60,   70,   82,   95,	108,  123,  138,  152,	168,  183,
198,  214,	229,  245,  261,   58,	 60,   66,   75,   86,	 99,  112,  126,  140,	155,  170,
185,  200,	216,  231,  247,  262,	 68,   70,   75,   83,	 93,  105,  117,  131,	145, 159,
174,  188,	203,  219,  234,  249,	265,   80,   82,   86,	 93,  102,  113,  125,	138, 151,
165,  179,	193,  208,  223,  238,	253,  268,   93,   95,	 99,  105,  113,  123,	134, 146,
158,  171,	185,  199,  213,  228,	242,  257,  272,  107,	108,  112,  117,  125,	134, 144,
155,  167,	179,  192,  206,  220,	234,  248,  263,  277,	122,  123,  126,  131,	138, 146,
155,  165,	177,  188,  201,  214,	227,  241,  255,  269,	283,  137,  138,  140,	145, 151,
158,  167,	177,  187,  198,  210,	223,  235,  249,  262,	276,  290,  152,  152,	155, 159,
165,  171,	179,  188,  198,  209,	220,  232,  245,  257,	270,  284,  297,  167,	168, 170,
174,  179,	185,  192,  201,  210,	220,  231,  242,  254,	267,  279,  292,  305,	182, 183,
185,  188,	193,  199,  206,  214,	223,  232,  242,  253,	265,  276,  289,  301,	314, 198,
198,  200,	203,  208,  213,  220,	227,  235,  245,  254,	265,  275,  287,  299,	311, 323,
213,  214,	216,  219,  223,  228,	234,  241,  249,  257,	267,  276,  287,  298,	309, 321,
333,  229,	229,  231,  234,  238,	242,  248,  255,  262,	270,  279,  289,  299,	309, 320,
331,  343,	245,  245,  247,  249,	253,  257,  263,  269,	276,  284,  292,  301,	311, 321,
331,  342,	354,  260,  261,  262,	265,  268,  272,  277,	283,  290,  297,  305,	314, 323,
333,  343,	354,  365,   80,   82,	 89,  100,  113,  128,	144,  161,  179,  197,	215, 234,
253,  272,	291,  310,  330,   82,	 85,   92,  102,  115,	129,  145,  162,  180,	198, 216,
235,  254,	272,  292,  311,  330,	 89,   92,   98,  108,	120,  134,  150,  166,	183, 201,
219,  237,	256,  275,  294,  313,	332,  100,  102,  108,	117,  128,  141,  156,	172, 188,
206,  223,	241,  260,  278,  297,	316,  335,  113,  115,	120,  128,  138,  151,	165, 180,
196,  212,	230,  247,  265,  283,	302,  320,  339,  128,	129,  134,  141,  151,	162, 175,
190,  205,	221,  237,  254,  272,	290,  308,  326,  344,	144,  145,  150,  156,	165, 175,
187,  201,	215,  230,  246,  263,	280,  297,  315,  333,	351,  161,  162,  166,	172, 180,
190,  201,	213,  227,  241,  257,	272,  289,  306,  323,	340,  358,  179,  180,	183, 188,
196,  205,	215,  227,  240,  254,	268,  283,  299,  315,	332,  349,  366,  197,	198, 201,
206,  212,	221,  230,  241,  254,	267,  280,  295,  310,	326,  342,  359,  375,	215, 216,
219,  223,	230,  237,  246,  257,	268,  280,  294,  308,	322,  337,  353,  369,	385, 234,
235,  237,	241,  247,  254,  263,	272,  283,  295,  308,	321,  335,  350,  365,	380, 396,
253,  254,	256,  260,  265,  272,	280,  289,  299,  310,	322,  335,  348,  362,	377, 392,
408,  272,	272,  275,  278,  283,	290,  297,  306,  315,	326,  337,  350,  362,	376, 390,
405,  420,	291,  292,  294,  297,	302,  308,  315,  323,	332,  342,  353,  365,	377, 390,
404,  418,	432,  310,  311,  313,	316,  320,  326,  333,	340,  349,  359,  369,	380, 392,
405,  418,	431,  445,  330,  330,	332,  335,  339,  344,	351,  358,  366,  375,	385, 396,
408,  420,	432,  445,  459,  120,	122,  129,  140,  154,	170,  187,  206,  226,	247, 268,
290,  312,	334,  356,  379,  402,	122,  125,  131,  142,	155,  171,  189,  208,	227, 248,
269,  291,	313,  335,  357,  380,	403,  129,  131,  138,	148,  161,  176,  193,	212, 231,
251,  272,	294,  315,  337,  360,	382,  405,  140,  142,	148,  157,  170,  184,	201, 218,
237,  257,	278,  299,  320,  342,	364,  386,  408,  154,	155,  161,  170,  181,	195, 210,
227,  246,	265,  285,  305,  326,	347,  369,  391,  413,	170,  171,  176,  184,	195, 208,
222,  239,	256,  274,  294,  314,	334,  355,  376,  398,	419,  187,  189,  193,	201, 210,
222,  236,	251,  268,  286,  304,	323,  343,  364,  384,	405,  427,  206,  208,	212, 218,
227,  239,	251,  266,  282,  299,	316,  335,  354,  374,	394,  415,  436,  226,	227, 231,
237,  246,	256,  268,  282,  297,	313,  330,  347,  366,	385,  405,  425,  445,	247, 248,
251,  257,	265,  274,  286,  299,	313,  328,  344,  361,	379,  398,  417,  436,	456, 268,
269,  272,	278,  285,  294,  304,	316,  330,  344,  360,	376,  393,  411,  430,	449, 468,
290,  291,	294,  299,  305,  314,	323,  335,  347,  361,	376,  392,  408,  426,	443, 462,
481,  312,	313,  315,  320,  326,	334,  343,  354,  366,	379,  393,  408,  424,	441, 458,
476,  494,	334,  335,  337,  342,	347,  355,  364,  374,	385,  398,  411,  426,	441, 457,
473,  491,	509,  356,  357,  360,	364,  369,  376,  384,	394,  405,  417,  430,	443, 458,
473,  490,	506,  524,  379,  380,	382,  386,  391,  398,	405,  415,  425,  436,	449, 462,
476,  491,	506,  523,  539,  402,	403,  405,  408,  413,	419,  427,  436,  445,	456, 468,
481,  494,	509,  524,  539,  556,	168,  170,  177,  188,	202,  218,  237,  258,	280, 303,
326,  350,	375,  401,  426,  452,	478,  170,  172,  179,	190,  204,  220,  239,	259, 281,
304,  327,	352,  376,  401,  427,	453,  479,  177,  179,	186,  196,  209,  226,	244, 264,
285,  308,	331,  355,  379,  404,	430,  455,  481,  188,	190,  196,  206,  218,	234, 252,
271,  292,	314,  337,  360,  385,	409,  434,  460,  485,	202,  204,  209,  218,	231, 245,
262,  281,	301,  323,  345,  368,	392,  416,  441,  466,	491,  218,  220,  226,	234, 245,
259,  275,	293,  313,  333,  355,	377,  401,  424,  448,	473,  498,  237,  239,	244, 252,
262,  275,	291,  308,  326,  346,	367,  389,  411,  434,	458,  482,  507,  258,	259, 264,
271,  281,	293,  308,  324,  341,	360,  380,  401,  423,	446,  469,  493,  517,	280, 281,
285,  292,	301,  313,  326,  341,	358,  376,  396,  416,	437,  459,  481,  504,	528, 303,
304,  308,	314,  323,  333,  346,	360,  376,  394,  412,	432,  452,  473,  495,	517, 540,
326,  327,	331,  337,  345,  355,	367,  380,  396,  412,	430,  448,  468,  489,	510, 531,
554,  350,	352,  355,  360,  368,	377,  389,  401,  416,	432,  448,  466,  485,	505, 526,
547,  568,	375,  376,  379,  385,	392,  401,  411,  423,	437,  452,  468,  485,	504, 523,
542,  563,	584,  401,  401,  404,	409,  416,  424,  434,	446,  459,  473,  489,	505, 523,
541,  560,	580,  601,  426,  427,	430,  434,  441,  448,	458,  469,  481,  495,	510, 526,
542,  560,	579,  598,  618,  452,	453,  455,  460,  466,	473,  482,  493,  504,	517, 531,
547,  563,	580,  598,  617,  636,	478,  479,  481,  485,	491,  498,  507,  517,	528, 540,
554,  568,	584,  601,  618,  636,	655,  224,  226,  233,	243,  258,  275,  295,	316, 340,
364,  390,	417,  444,  472,  500,	529,  558,  226,  228,	235,  246,  260,  277,	296, 318,
341,  366,	392,  418,  445,  473,	501,  530,  559,  233,	235,  241,  252,  266,	282, 302,
323,  346,	370,  395,  422,  449,	476,  504,  533,  562,	243,  246,  252,  262,	275, 291,
310,  331,	353,  377,  402,  428,	454,  482,  509,  538,	566,  258,  260,  266,	275, 288,
303,  321,	341,  363,  386,  411,	436,  462,  489,  516,	544,  573,  275,  277,	282, 291,
303,  318,	335,  355,  376,  398,	422,  446,  472,  498,	525,  553,  581,  295,	296, 302,
310,  321,	335,  352,  370,  390,	412,  435,  459,  484,	509,  536,  563,  590,	316, 318,
323,  331,	341,  355,  370,  388,	407,  428,  450,  473,	497,  522,  548,  575,	601, 340,
341,  346,	353,  363,  376,  390,	407,  425,  445,  467,	489,  512,  537,  562,	588, 614,
364,  366,	370,  377,  386,  398,	412,  428,  445,  464,	485,  506,  529,  553,	577, 602,
628,  390,	392,  395,  402,  411,	422,  435,  450,  467,	485,  504,  525,  547,	570, 594,
618,  643,	417,  418,  422,  428,	436,  446,  459,  473,	489,  506,  525,  545,	566, 589,
612,  635,	660,  444,  445,  449,	454,  462,  472,  484,	497,  512,  529,  547,	566, 587,
608,  631,	654,  677,  472,  473,	476,  482,  489,  498,	509,  522,  537,  553,	570, 589,
608,  629,	650,  673,  696,  500,	501,  504,  509,  516,	525,  536,  548,  562,	577, 594,
612,  631,	650,  671,  693,  716,	529,  530,  533,  538,	544,  553,  563,  575,	588, 602,
618,  635,	654,  673,  693,  714,	736,  558,  559,  562,	566,  573,  581,  590,	601, 614,
628,  643,	660,  677,  696,  716,	736,  757,  288,  290,	297,  307,  322,  339,	360, 382,
407,  433,	461,  489,  519,  549,	580,  611,  643,  290,	292,  299,  309,  324,	341, 361,
384,  408,	435,  462,  490,  520,	550,  581,  612,  644,	297,  299,  305,  316,	330, 347,
367,  389,	413,  439,  466,  494,	524,  554,  584,  616,	647,  307,  309,  316,	326, 339,
356,  375,	397,  421,  446,  473,	501,  530,  559,  590,	621,  652,  322,  324,	330, 339,
352,  369,	387,  408,  432,  456,	483,  510,  538,  568,	597,  628,  659,  339,	341, 347,
356,  369,	384,  402,  422,  445,	469,  494,  521,  549,	578,  607,  637,  668,	360, 361,
367,  375,	387,  402,  419,  439,	461,  484,  509,  535,	562,  590,  619,  648,	679, 382,
384,  389,	397,  408,  422,  439,	458,  478,  501,  525,	550,  577,  604,  632,	661, 691,
407,  408,	413,  421,  432,  445,	461,  478,  498,  520,	543,  568,  593,  620,	647, 676,
705,  433,	435,  439,  446,  456,	469,  484,  501,  520,	541,  563,  587,  611,	637, 664,
692,  720,	461,  462,  466,  473,	483,  494,  509,  525,	543,  563,  584,  607,	631, 656,
682,  709,	737,  489,  490,  494,	501,  510,  521,  535,	550,  568,  587,  607,	629, 652,
677,  702,	728,  755,  519,  520,	524,  530,  538,  549,	562,  577,  593,  611,	631, 652,
675,  698,	723,  748,  775,  549,	550,  554,  559,  568,	578,  590,  604,  620,	637, 656,
677,  698,	721,  745,  770,  795,	580,  581,  584,  590,	597,  607,  619,  632,	647, 664,
682,  702,	723,  745,  768,  792,	817,  611,  612,  616,	621,  628,  637,  648,	661, 676,
692,  709,	728,  748,  770,  792,	815,  840,  643,  644,	647,  652,  659,  668,	679, 691,
705,  720,	737,  755,  775,  795,	817,  840,  863,  360,	362,  368,  379,  394,	411, 432,
456,  481,	509,  538,  568,  599,	632,  665,  699,  734,	362,  364,  371,  381,	396, 413,
434,  457,	483,  510,  539,  569,	601,  633,  666,  700,	735,  368,  371,  377,	387, 402,
419,  440,	463,  488,  515,  544,	574,  605,  637,  670,	704,  738,  379,  381,	387, 398,
411,  429,	449,  471,  496,  523,	551,  580,  611,  643,	676,  709,  743,  394,	396, 402,
411,  425,	441,  461,  483,  507,	533,  561,  590,  620,	652,  684,  717,  751,	411, 413,
419,  429,	441,  457,  476,  498,	521,  546,  574,  602,	632,  663,  694,  727,	760, 432,
434,  440,	449,  461,  476,  494,	515,  538,  562,  589,	616,  646,  676,  707,	739, 772,
456,  457,	463,  471,  483,  498,	515,  535,  557,  580,	606,  633,  661,  691,	722, 753,
785,  481,	483,  488,  496,  507,	521,  538,  557,  578,	601,  625,  652,  679,	708, 738,
769,  800,	509,  510,  515,  523,	533,  546,  562,  580,	601,  623,  647,  672,	699, 727,
756,  786,	817,  538,  539,  544,	551,  561,  574,  589,	606,  625,  647,  670,	694, 720,
748,  776,	805,  835,  568,  569,	574,  580,  590,  602,	616,  633,  652,  672,	694, 718,
743,  770,	797,  826,  855,  599,	601,  605,  611,  620,	632,  646,  661,  679,	699, 720,
743,  768,	793,  820,  848,  876,	632,  633,  637,  643,	652,  663,  676,  691,	708, 727,
748,  770,	793,  818,  844,  871,	899,  665,  666,  670,	676,  684,  694,  707,	722, 738,
756,  776,	797,  820,  844,  869,	895,  923,  699,  700,	704,  709,  717,  727,	739, 753,
769,  786,	805,  826,  848,  871,	895,  921,  947,  734,	735,  738,  743,  751,	760, 772,
785,  800,	817,  835,  855,  876,	899,  923,  947,  973,	440,  442,  448,  459,	473, 491,
513,  537,	563,  591,  622,  653,	687,  721,  756,  792,	829,  442,  444,  450,	461, 475,
493,  515,	538,  565,  593,  623,	655,  688,  722,  758,	794,  831,  448,  450,	457, 467,
482,  499,	520,  544,  570,  598,	628,  659,  692,  726,	761,  797,  834,  459,	461, 467,
477,  491,	509,  529,  553,  578,	606,  635,  667,  699,	733,  768,  803,  840,	473, 475,
482,  491,	505,  522,  542,  565,	590,  617,  646,  677,	709,  742,  776,  812,	848, 491,
493,  499,	509,  522,  538,  558,	580,  604,  631,  659,	689,  721,  754,  788,	822, 858,
513,  515,	520,  529,  542,  558,	576,  598,  622,  648,	675,  705,  736,  768,	801, 835,
870,  537,	538,  544,  553,  565,	580,  598,  619,  642,	667,  694,  722,  752,	784, 816,
850,  885,	563,  565,  570,  578,	590,  604,  622,  642,	664,  688,  714,  742,	771, 802,
834,  867,	901,  591,  593,  598,	606,  617,  631,  648,	667,  688,  712,  737,	764, 792,
822,  853,	886,  919,  622,  623,	628,  635,  646,  659,	675,  694,  714,  737,	761, 788,
815,  844,	875,  906,  939,  653,	655,  659,  667,  677,	689,  705,  722,  742,	764, 788,
813,  840,	868,  898,  928,  960,	687,  688,  692,  699,	709,  721,  736,  752,	771, 792,
815,  840,	866,  893,  922,  952,	983,  721,  722,  726,	733,  742,  754,  768,	784, 802,
822,  844,	868,  893,  920,  948,	977, 1007,  756,  758,	761,  768,  776,  788,	801, 816,
834,  853,	875,  898,  922,  948,	975, 1003, 1023,  792,	794,  797,  803,  812,	822, 835,
850,  867,	886,  906,  928,  952,	977, 1003, 1023, 1023,	829,  831,  834,  840,	848, 858,
870,  885,	901,  919,  939,  960,	983, 1007, 1023, 1023, 1023,  527,  530,  536,	547, 561,
579,  601,	625,  652,  682,  713,	746,  781,  817,  854,	892,  931,  530,  532,	538, 549,
563,  581,	603,  627,  654,  683,	714,  748,  782,  818,	855,  893,  932,  536,	538, 545,
555,  569,	587,  608,  633,  659,	688,  719,  752,  786,	822,  859,  897,  936,	547, 549,
555,  565,	579,  597,  618,  642,	668,  697,  727,  760,	794,  829,  866,  904,	942, 561,
563,  569,	579,  593,  610,  631,	654,  680,  708,  738,	770,  804,  839,  875,	912, 951,
579,  581,	587,  597,  610,  627,	647,  670,  695,  722,	752,  784,  817,  851,	887, 924,
961,  601,	603,  608,  618,  631,	647,  666,  688,  713,	740,  769,  800,  832,	866, 901,
937,  975,	625,  627,  633,  642,	654,  670,  688,  710,	734,  760,  788,  818,	850, 883,
917,  953,	990,  652,  654,  659,	668,  680,  695,  713,	734,  757,  782,  810,	839, 870,
902,  936,	971, 1007,  682,  683,	688,  697,  708,  722,	740,  760,  782,  807,	833, 862,
892,  924,	957,  991, 1023,  713,	714,  719,  727,  738,	752,  769,  788,  810,	833, 859,
887,  916,	947,  979, 1013, 1023,	746,  748,  752,  760,	770,  784,  800,  818,	839, 862,
887,  914,	942,  972, 1004, 1023, 1023,  781,  782,  786,	794,  804,  817,  832,	850, 870,
892,  916,	942,  970,  999, 1023, 1023, 1023,  817,  818,	822,  829,  839,  851,	866, 883,
902,  924,	947,  972,  999, 1023, 1023, 1023, 1023,  854,	855,  859,  866,  875,	887, 901,
917,  936,	957,  979, 1004, 1023, 1023, 1023, 1023, 1023,	892,  893,  897,  904,	912, 924,
937,  953,	971,  991, 1013, 1023, 1023, 1023, 1023, 1023, 1023,  931,  932,  936,	942, 951,
961,  975,	990, 1007, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  623,  626,	632, 643,
657,  675,	697,  722,  749,  779,	811,  846,  882,  919,	958,  998, 1023,  626,	628, 634,
645,  659,	677,  699,  724,  751,	781,  813,  847,  883,	921,  959,  999, 1023,	632, 634,
640,  651,	665,  683,  705,  729,	756,  786,  818,  852,	888,  925,  964, 1003, 1023, 643,
645,  651,	661,  675,  693,  714,	738,  765,  795,  826,	860,  895,  932,  970, 1010, 1023,
657,  659,	665,  675,  689,  707,	727,  751,  778,  806,	838,  871,  906,  942,	980, 1019,
1023,  675,	677,  683,  693,  707,	724,  744,  767,  793,	821,  852,  885,  919,	955, 992,
1023, 1023,	697,  699,  705,  714,	727,  744,  763,  786,	811,  839,  869,  901,	935, 970,
1007, 1023, 1023,  722,  724,  729,	738,  751,  767,  786,	808,  833,  860,  889,	921, 954,
988, 1023, 1023, 1023,  749,  751,	756,  765,  778,  793,	811,  833,  857,  883,	912, 942,
975, 1009, 1023, 1023, 1023,  779,	781,  786,  795,  806,	821,  839,  860,  883,	909, 937,
966,  998, 1023, 1023, 1023, 1023,	811,  813,  818,  826,	838,  852,  869,  889,	912, 937,
964,  992, 1023, 1023, 1023, 1023, 1023,  846,  847,  852,	860,  871,  885,  901,	921, 942,
966,  992, 1021, 1023, 1023, 1023, 1023, 1023,  882,  883,	888,  895,  906,  919,	935, 954,
975,  998, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  919,	921,  925,  932,  942,	955, 970,
988, 1009, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,	958,  959,  964,  970,	980, 992,
1007, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  998,  999, 1003, 1010, 1019,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  727,	729, 736,
746,  761,	779,  801,  826,  854,	885,  918,  953,  990, 1023, 1023, 1023, 1023,	729, 732,
738,  748,	763,  781,  803,  828,	856,  886,  919,  954,	991, 1023, 1023, 1023, 1023, 736,
738,  744,	755,  769,  787,  809,	834,  861,  892,  924,	959,  996, 1023, 1023, 1023, 1023,
746,  748,	755,  765,  779,  797,	818,  843,  870,  900,	933,  967, 1004, 1023, 1023, 1023,
1023,  761,	763,  769,  779,  793,	811,  832,  856,  883,	912,  944,  979, 1015, 1023, 1023,
1023, 1023,	779,  781,  787,  797,	811,  828,  848,  872,	899,  928,  959,  993, 1023, 1023,
1023, 1023, 1023,  801,  803,  809,	818,  832,  848,  869,	892,  918,  946,  977, 1010, 1023,
1023, 1023, 1023, 1023,  826,  828,	834,  843,  856,  872,	892,  914,  939,  967,	998, 1023,
1023, 1023, 1023, 1023, 1023,  854,	856,  861,  870,  883,	899,  918,  939,  964,	991, 1021,
1023, 1023, 1023, 1023, 1023, 1023,	885,  886,  892,  900,	912,  928,  946,  967,	991, 1018,
1023, 1023, 1023, 1023, 1023, 1023, 1023,  918,  919,  924,	933,  944,  959,  977,	998, 1021,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  953,  954,	959,  967,  979,  993, 1010, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,  990,	991,  996, 1004, 1015, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,	839, 841,
848,  858,	873,  891,  913,  938,	967,  998, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 841,
843,  850,	860,  875,  893,  915,	940,  968,  999, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
848,  850,	856,  867,  881,  899,	921,  946,  974, 1005, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  858,	860,  867,  877,  891,	909,  931,  955,  983, 1014, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	873,  875,  881,  891,	905,  923,  944,  968,	996, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  891,  893,  899,	909,  923,  940,  961,	985, 1012, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023,  913,  915,	921,  931,  944,  961,	981, 1005, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023,  938,	940,  946,  955,  968,	985, 1005, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023,	967,  968,  974,  983,	996, 1012, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023,  998,  999, 1005, 1014, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 959,
961,  968,	978,  993, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
961,  963,	970,  980,  995, 1013, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,  968,	970,  976,  986, 1001, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023,	978,  980,  986,  997, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023,  993,  995, 1001, 1011, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1011, 1013, 1019, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
1023,
};

uint16_t c_lut_b_lut[] = {
0,	2,   4,   6,	  8,  10,  12,  14,	 16,  18,  20,  22,	 24,  26,  28,  30,
32,	2,   3,   4,	  6,	8,  10,  12,	 14,  16,  18,  20,	 22,  24,  26,  28,
30,  32,   4,   4,	  6,	7,   9,  11,	 13,  15,  16,  18,	 20,  22,  24,  26,
28,  30,  32,   6,	  6,	7,   8,  10,	 12,  13,  15,  17,	 19,  21,  23,  25,
27,  29,  31,  33,	  8,	8,   9,  10,	 11,  13,  14,  16,	 18,  20,  22,  23,
25,  27,  29,  31,	 33,  10,  10,  11,	 12,  13,  14,  16,	 17,  19,  21,  22,
24,  26,  28,  30,	 32,  33,  12,  12,	 13,  13,  14,  16,	 17,  18,  20,  22,
23,  25,  27,  29,	 30,  32,  34,  14,	 14,  15,  15,  16,	 17,  18,  20,  21,
23,  24,  26,  28,	 30,  31,  33,  35,	 16,  16,  16,  17,	 18,  19,  20,  21,
23,  24,  26,  27,	 29,  30,  32,  34,	 36,  18,  18,  18,	 19,  20,  21,  22,
23,  24,  25,  27,	 28,  30,  32,  33,	 35,  37,  20,  20,	 20,  21,  22,  22,
23,  24,  26,  27,	 28,  30,  31,  33,	 34,  36,  38,  22,	 22,  22,  23,  23,
24,  25,  26,  27,	 28,  30,  31,  33,	 34,  36,  37,  39,	 24,  24,  24,  25,
25,  26,  27,  28,	 29,  30,  31,  33,	 34,  35,  37,  38,	 40,  26,  26,  26,
27,  27,  28,  29,	 30,  30,  32,  33,	 34,  35,  37,  38,	 40,  41,  28,  28,
28,  29,  29,  30,	 30,  31,  32,  33,	 34,  36,  37,  38,	 40,  41,  42,  30,
30,  30,  31,  31,	 32,  32,  33,  34,	 35,  36,  37,  38,	 40,  41,  42,  44,
32,  32,  32,  33,	 33,  33,  34,  35,	 36,  37,  38,  39,	 40,  41,  42,  44,
45,	4,   6,   9,	 13,  16,  20,  24,	 28,  32,  36,  40,	 44,  48,  52,  56,
60,  64,   6,   7,	 10,  13,  17,  21,	 25,  29,  32,  36,	 40,  44,  48,  52,
56,  60,  64,   9,	 10,  12,  15,  18,	 22,  26,  29,  33,	 37,  41,  45,  49,
53,  57,  61,  65,	 13,  13,  15,  17,	 20,  24,  27,  31,	 34,  38,  42,  46,
50,  53,  57,  61,	 65,  16,  17,  18,	 20,  23,  26,  29,	 32,  36,  40,  43,
47,  51,  54,  58,	 62,  66,  20,  21,	 22,  24,  26,  29,	 31,  35,  38,  41,
45,  48,  52,  56,	 60,  63,  67,  24,	 25,  26,  27,  29,	 31,  34,  37,  40,
43,  47,  50,  54,	 57,  61,  65,  68,	 28,  29,  29,  31,	 32,  35,  37,  40,
43,  46,  49,  52,	 56,  59,  63,  66,	 70,  32,  32,  33,	 34,  36,  38,  40,
43,  45,  48,  51,	 54,  58,  61,  65,	 68,  72,  36,  36,	 37,  38,  40,  41,
43,  46,  48,  51,	 54,  57,  60,  63,	 67,  70,  73,  40,	 40,  41,  42,  43,
45,  47,  49,  51,	 54,  57,  60,  63,	 66,  69,  72,  76,	 44,  44,  45,  46,
47,  48,  50,  52,	 54,  57,  60,  62,	 65,  68,  71,  74,	 78,  48,  48,  49,
50,  51,  52,  54,	 56,  58,  60,  63,	 65,  68,  71,  74,	 77,  80,  52,  52,
53,  53,  54,  56,	 57,  59,  61,  63,	 66,  68,  71,  74,	 76,  79,  82,  56,
56,  57,  57,  58,	 60,  61,  63,  65,	 67,  69,  71,  74,	 76,  79,  82,  85,
60,  60,  61,  61,	 62,  63,  65,  66,	 68,  70,  72,  74,	 77,  79,  82,  85,
88,  64,  64,  65,	 65,  66,  67,  68,	 70,  72,  73,  76,	 78,  80,  82,  85,
88,  91,  12,  13,	 17,  22,  27,  32,	 38,  44,  49,  55,	 61,  67,  73,  79,
85,  91,  97,  13,	 15,  18,  22,  27,	 33,  38,  44,  50,	 56,  61,  67,  73,
79,  85,  91,  97,	 17,  18,  21,  25,	 29,  34,  40,  45,	 51,  57,  62,  68,
74,  80,  86,  91,	 97,  22,  22,  25,	 28,  32,  37,  42,	 47,  53,  58,  64,
69,  75,  81,  87,	 92,  98,  27,  27,	 29,  32,  36,  40,	 45,  50,  55,  60,
66,  71,  77,  82,	 88,  94, 100,  32,	 33,  34,  37,  40,	 44,  48,  53,  58,
63,  68,  73,  79,	 84,  90,  96, 101,	 38,  38,  40,  42,	 45,  48,  52,  57,
61,  66,  71,  76,	 81,  87,  92,  98,	103,  44,  44,  45,	 47,  50,  53,  57,
61,  65,  69,  74,	 79,  84,  89,  95,	100, 105,  49,  50,	 51,  53,  55,  58,
61,  65,  69,  73,	 78,  82,  87,  92,	 97, 103, 108,  55,	 56,  57,  58,  60,
63,  66,  69,  73,	 77,  82,  86,  91,	 96, 100, 106, 111,	 61,  61,  62,  64,
66,  68,  71,  74,	 78,  82,  86,  90,	 94,  99, 104, 109,	114,  67,  67,  68,
69,  71,  73,  76,	 79,  82,  86,  90,	 94,  98, 103, 107,	112, 117,  73,  73,
74,  75,  77,  79,	 81,  84,  87,  91,	 94,  98, 102, 107,	111, 116, 120,  79,
79,  80,  81,  82,	 84,  87,  89,  92,	 96,  99, 103, 107,	111, 115, 120, 124,
85,  85,  86,  87,	 88,  90,  92,  95,	 97, 100, 104, 107,	111, 115, 119, 124,
128,  91,  91,  91,	 92,  94,  96,  98,	100, 103, 106, 109,	112, 116, 120, 124,
128, 132,  97,  97,	 97,  98, 100, 101,	103, 105, 108, 111,	114, 117, 120, 124,
128, 132, 136,  24,	 25,  29,  34,  40,	 47,  54,  61,  68,	 76,  83,  91,  99,
107, 114, 122, 130,	 25,  27,  30,  35,	 41,  47,  54,  61,	 69,  76,  84,  91,
99, 107, 115, 123,	130,  29,  30,  33,	 37,  43,  49,  56,	 63,  70,  77,  85,
93, 100, 108, 116,	123, 131,  34,  35,	 37,  42,  47,  52,	 59,  65,  72,  80,
87,  94, 102, 109,	117, 125, 132,  40,	 41,  43,  47,  51,	 57,  62,  69,  75,
82,  89,  97, 104,	111, 119, 126, 134,	 47,  47,  49,  52,	 57,  61,  67,  73,
79,  86,  93, 100,	107, 114, 121, 129,	136,  54,  54,  56,	 59,  62,  67,  72,
77,  83,  90,  96,	103, 110, 117, 124,	131, 139,  61,  61,	 63,  65,  69,  73,
77,  83,  88,  94,	100, 107, 114, 120,	127, 134, 142,  68,	 69,  70,  72,  75,
79,  83,  88,  94,	 99, 105, 111, 118,	124, 131, 138, 145,	 76,  76,  77,  80,
82,  86,  90,  94,	 99, 105, 110, 116,	122, 129, 135, 142,	149,  83,  84,  85,
87,  89,  93,  96,	100, 105, 110, 116,	121, 127, 133, 140,	146, 153,  91,  91,
93,  94,  97, 100,	103, 107, 111, 116,	121, 127, 132, 138,	144, 151, 157,  99,
99, 100, 102, 104,	107, 110, 114, 118,	122, 127, 132, 138,	143, 149, 155, 162,
107, 107, 108, 109,	111, 114, 117, 120,	124, 129, 133, 138,	143, 149, 155, 160,
166, 114, 115, 116,	117, 119, 121, 124,	127, 131, 135, 140,	144, 149, 155, 160,
166, 172, 122, 123,	123, 125, 126, 129,	131, 134, 138, 142,	146, 151, 155, 160,
166, 171, 177, 130,	130, 131, 132, 134,	136, 139, 142, 145,	149, 153, 157, 162,
166, 172, 177, 182,	 40,  41,  45,  50,	 57,  64,  72,  81,	 89,  98, 108, 117,
126, 136, 145, 155,	165,  41,  42,  46,	 51,  57,  65,  73,	 81,  90,  99, 108,
117, 127, 136, 146,	155, 165,  45,  46,	 49,  54,  60,  67,	 75,  83,  92, 100,
109, 119, 128, 137,	147, 156, 166,  50,	 51,  54,  58,  64,	 71,  78,  86,  94,
103, 112, 121, 130,	139, 149, 158, 167,	 57,  57,  60,  64,	 69,  75,  82,  90,
98, 106, 115, 124,	133, 142, 151, 160,	170,  64,  65,  67,	 71,  75,  81,  88,
95, 102, 110, 119,	127, 136, 145, 154,	163, 172,  72,  73,	 75,  78,  82,  88,
94, 100, 108, 115,	123, 131, 140, 149,	157, 166, 175,  81,	 81,  83,  86,  90,
95, 100, 107, 113,	121, 128, 136, 144,	153, 161, 170, 179,	 89,  90,  92,  94,
98, 102, 108, 113,	120, 127, 134, 142,	150, 158, 166, 174,	183,  98,  99, 100,
103, 106, 110, 115,	121, 127, 133, 140,	148, 155, 163, 171,	179, 188, 108, 108,
109, 112, 115, 119,	123, 128, 134, 140,	147, 154, 161, 169,	176, 184, 193, 117,
117, 119, 121, 124,	127, 131, 136, 142,	148, 154, 160, 167,	175, 182, 190, 198,
126, 127, 128, 130,	133, 136, 140, 144,	150, 155, 161, 167,	174, 181, 188, 196,
204, 136, 136, 137,	139, 142, 145, 149,	153, 158, 163, 169,	175, 181, 188, 195,
202, 210, 145, 146,	147, 149, 151, 154,	157, 161, 166, 171,	176, 182, 188, 195,
202, 209, 216, 155,	155, 156, 158, 160,	163, 166, 170, 174,	179, 184, 190, 196,
202, 209, 216, 223,	165, 165, 166, 167,	170, 172, 175, 179,	183, 188, 193, 198,
204, 210, 216, 223,	230,  60,  61,  65,	 70,  77,  85,  94,	103, 113, 123, 134,
145, 156, 167, 178,	190, 201,  61,  62,	 66,  71,  78,  86,	 94, 104, 114, 124,
135, 145, 156, 167,	179, 190, 201,  65,	 66,  69,  74,  80,	 88,  97, 106, 116,
126, 136, 147, 158,	169, 180, 191, 202,	 70,  71,  74,  79,	 85,  92, 100, 109,
119, 129, 139, 149,	160, 171, 182, 193,	204,  77,  78,  80,	 85,  91,  97, 105,
114, 123, 132, 142,	153, 163, 174, 185,	196, 207,  85,  86,	 88,  92,  97, 104,
111, 119, 128, 137,	147, 157, 167, 177,	188, 199, 210,  94,	 94,  97, 100, 105,
111, 118, 126, 134,	143, 152, 162, 172,	182, 192, 203, 213,	103, 104, 106, 109,
114, 119, 126, 133,	141, 149, 158, 167,	177, 187, 197, 207,	218, 113, 114, 116,
119, 123, 128, 134,	141, 148, 156, 165,	174, 183, 193, 202,	212, 223, 123, 124,
126, 129, 132, 137,	143, 149, 156, 164,	172, 181, 190, 199,	208, 218, 228, 134,
135, 136, 139, 142,	147, 152, 158, 165,	172, 180, 188, 197,	206, 215, 224, 234,
145, 145, 147, 149,	153, 157, 162, 167,	174, 181, 188, 196,	204, 213, 222, 231,
240, 156, 156, 158,	160, 163, 167, 172,	177, 183, 190, 197,	204, 212, 220, 229,
238, 247, 167, 167,	169, 171, 174, 177,	182, 187, 193, 199,	206, 213, 220, 228,
237, 245, 254, 178,	179, 180, 182, 185,	188, 192, 197, 202,	208, 215, 222, 229,
237, 245, 253, 262,	190, 190, 191, 193,	196, 199, 203, 207,	212, 218, 224, 231,
238, 245, 253, 261,	270, 201, 201, 202,	204, 207, 210, 213,	218, 223, 228, 234,
240, 247, 254, 262,	270, 278,  84,  85,	 88,  94, 101, 109,	119, 129, 140, 151,
163, 175, 188, 200,	213, 226, 239,  85,	 86,  90,  95, 102,	110, 119, 130, 141,
152, 164, 176, 188,	201, 213, 226, 239,	 88,  90,  93,  98,	105, 113, 122, 132,
143, 154, 165, 177,	190, 202, 215, 228,	241,  94,  95,  98,	103, 109, 117, 126,
136, 146, 157, 168,	180, 192, 205, 217,	230, 243, 101, 102,	105, 109, 115, 123,
131, 141, 151, 161,	172, 184, 196, 208,	220, 233, 245, 109,	110, 113, 117, 123,
130, 138, 147, 156,	167, 177, 189, 200,	212, 224, 237, 249,	119, 119, 122, 126,
131, 138, 145, 154,	163, 173, 183, 194,	206, 217, 229, 241,	253, 129, 130, 132,
136, 141, 147, 154,	162, 171, 180, 190,	201, 212, 223, 234,	246, 258, 140, 141,
143, 146, 151, 156,	163, 171, 179, 188,	198, 208, 218, 229,	241, 252, 264, 151,
152, 154, 157, 161,	167, 173, 180, 188,	197, 206, 216, 226,	237, 247, 259, 270,
163, 164, 165, 168,	172, 177, 183, 190,	198, 206, 215, 224,	234, 244, 255, 266,
277, 175, 176, 177,	180, 184, 189, 194,	201, 208, 216, 224,	233, 243, 253, 263,
273, 284, 188, 188,	190, 192, 196, 200,	206, 212, 218, 226,	234, 243, 252, 261,
271, 281, 292, 200,	201, 202, 205, 208,	212, 217, 223, 229,	237, 244, 253, 261,
270, 280, 290, 300,	213, 213, 215, 217,	220, 224, 229, 234,	241, 247, 255, 263,
271, 280, 289, 299,	309, 226, 226, 228,	230, 233, 237, 241,	246, 252, 259, 266,
273, 281, 290, 299,	308, 318, 239, 239,	241, 243, 245, 249,	253, 258, 264, 270,
277, 284, 292, 300,	309, 318, 327, 112,	113, 116, 122, 129,	138, 147, 158, 170,
182, 195, 208, 222,	236, 250, 265, 279,	113, 114, 117, 123,	130, 138, 148, 159,
171, 183, 196, 209,	223, 237, 251, 265,	280, 116, 117, 121,	126, 133, 141, 151,
161, 173, 185, 198,	211, 224, 238, 252,	267, 281, 122, 123,	126, 131, 138, 146,
155, 165, 177, 188,	201, 214, 227, 241,	255, 269, 283, 129,	130, 133, 138, 144,
152, 161, 171, 182,	193, 205, 218, 231,	245, 258, 272, 286,	138, 138, 141, 146,
152, 159, 168, 177,	188, 199, 211, 223,	236, 249, 263, 276,	290, 147, 148, 151,
155, 161, 168, 176,	185, 195, 206, 217,	229, 242, 255, 268,	281, 295, 158, 159,
161, 165, 171, 177,	185, 194, 203, 214,	225, 237, 249, 261,	274, 287, 301, 170,
171, 173, 177, 182,	188, 195, 203, 213,	223, 233, 245, 256,	268, 281, 294, 307,
182, 183, 185, 188,	193, 199, 206, 214,	223, 232, 242, 253,	265, 276, 289, 301,
314, 195, 196, 198,	201, 205, 211, 217,	225, 233, 242, 252,	263, 274, 285, 297,
309, 322, 208, 209,	211, 214, 218, 223,	229, 237, 245, 253,	263, 273, 283, 294,
306, 318, 330, 222,	223, 224, 227, 231,	236, 242, 249, 256,	265, 274, 283, 293,
304, 315, 327, 339,	236, 237, 238, 241,	245, 249, 255, 261,	268, 276, 285, 294,
304, 314, 325, 336,	348, 250, 251, 252,	255, 258, 263, 268,	274, 281, 289, 297,
306, 315, 325, 336,	347, 358, 265, 265,	267, 269, 272, 276,	281, 287, 294, 301,
309, 318, 327, 336,	347, 357, 368, 279,	280, 281, 283, 286,	290, 295, 301, 307,
314, 322, 330, 339,	348, 358, 368, 379,	144, 145, 148, 154,	161, 170, 180, 191,
203, 217, 230, 245,	259, 274, 290, 306,	322, 145, 146, 149,	155, 162, 171, 181,
192, 204, 217, 231,	245, 260, 275, 291,	306, 322, 148, 149,	153, 158, 165, 173,
183, 195, 207, 220,	233, 247, 262, 277,	292, 308, 324, 154,	155, 158, 163, 170,
178, 188, 199, 210,	223, 237, 250, 265,	280, 295, 310, 326,	161, 162, 165, 170,
176, 184, 194, 204,	216, 228, 241, 255,	269, 284, 299, 314,	330, 170, 171, 173,
178, 184, 192, 201,	211, 222, 234, 247,	261, 274, 289, 304,	319, 334, 180, 181,
183, 188, 194, 201,	210, 220, 230, 242,	254, 267, 281, 295,	309, 324, 339, 191,
192, 195, 199, 204,	211, 220, 229, 239,	250, 262, 275, 288,	302, 316, 331, 345,
203, 204, 207, 210,	216, 222, 230, 239,	249, 260, 272, 284,	297, 310, 324, 338,
352, 217, 217, 220,	223, 228, 234, 242,	250, 260, 270, 281,	293, 306, 319, 332,
346, 360, 230, 231,	233, 237, 241, 247,	254, 262, 272, 281,	292, 304, 316, 328,
341, 355, 369, 245,	245, 247, 250, 255,	261, 267, 275, 284,	293, 304, 315, 326,
338, 351, 364, 378,	259, 260, 262, 265,	269, 274, 281, 288,	297, 306, 316, 326,
337, 349, 361, 374,	387, 274, 275, 277,	280, 284, 289, 295,	302, 310, 319, 328,
338, 349, 361, 372,	385, 398, 290, 291,	292, 295, 299, 304,	309, 316, 324, 332,
341, 351, 361, 372,	384, 396, 408, 306,	306, 308, 310, 314,	319, 324, 331, 338,
346, 355, 364, 374,	385, 396, 408, 420,	322, 322, 324, 326,	330, 334, 339, 345,
352, 360, 369, 378,	387, 398, 408, 420,	432, 180, 181, 184,	190, 197, 206, 216,
228, 241, 254, 269,	284, 300, 316, 333,	350, 367, 181, 182,	185, 191, 198, 207,
217, 229, 241, 255,	270, 285, 300, 317,	333, 350, 367, 184,	185, 188, 194, 201,
210, 220, 231, 244,	257, 272, 287, 302,	318, 335, 352, 369,	190, 191, 194, 199,
206, 214, 224, 236,	248, 261, 275, 290,	306, 322, 338, 355,	372, 197, 198, 201,
206, 212, 221, 230,	241, 254, 267, 280,	295, 310, 326, 342,	359, 375, 206, 207,
210, 214, 221, 229,	238, 249, 261, 273,	287, 301, 316, 331,	347, 364, 380, 216,
217, 220, 224, 230,	238, 247, 257, 269,	281, 294, 308, 323,	338, 353, 370, 386,
228, 229, 231, 236,	241, 249, 257, 267,	278, 290, 303, 317,	331, 345, 361, 376,
393, 241, 241, 244,	248, 254, 261, 269,	278, 289, 300, 313,	326, 340, 354, 369,
384, 400, 254, 255,	257, 261, 267, 273,	281, 290, 300, 311,	323, 336, 350, 364,
378, 393, 409, 269,	270, 272, 275, 280,	287, 294, 303, 313,	323, 335, 347, 360,
374, 388, 403, 418,	284, 285, 287, 290,	295, 301, 308, 317,	326, 336, 347, 359,
372, 385, 399, 413,	428, 300, 300, 302,	306, 310, 316, 323,	331, 340, 350, 360,
372, 384, 397, 410,	424, 438, 316, 317,	318, 322, 326, 331,	338, 345, 354, 364,
374, 385, 397, 409,	422, 435, 449, 333,	333, 335, 338, 342,	347, 353, 361, 369,
378, 388, 399, 410,	422, 435, 448, 461,	350, 350, 352, 355,	359, 364, 370, 376,
384, 393, 403, 413,	424, 435, 448, 460,	474, 367, 367, 369,	372, 375, 380, 386,
393, 400, 409, 418,	428, 438, 449, 461,	474, 487, 220, 221,	224, 229, 237, 246,
256, 268, 281, 296,	311, 327, 343, 360,	378, 396, 415, 221,	222, 225, 231, 238,
247, 257, 269, 282,	297, 312, 327, 344,	361, 379, 397, 415,	224, 225, 228, 234,
241, 250, 260, 272,	285, 299, 314, 330,	346, 363, 381, 399,	417, 229, 231, 234,
239, 246, 254, 265,	276, 289, 303, 318,	333, 350, 366, 384,	402, 420, 237, 238,
241, 246, 253, 261,	271, 282, 295, 308,	323, 338, 354, 371,	388, 406, 424, 246,
247, 250, 254, 261,	269, 279, 290, 302,	315, 330, 345, 360,	377, 394, 411, 429,
256, 257, 260, 265,	271, 279, 288, 299,	311, 324, 338, 352,	368, 384, 400, 418,
435, 268, 269, 272,	276, 282, 290, 299,	309, 321, 333, 347,	361, 376, 392, 408,
425, 442, 281, 282,	285, 289, 295, 302,	311, 321, 332, 344,	357, 371, 386, 401,
417, 433, 450, 296,	297, 299, 303, 308,	315, 324, 333, 344,	356, 368, 382, 396,
411, 427, 443, 459,	311, 312, 314, 318,	323, 330, 338, 347,	357, 368, 381, 394,
408, 422, 437, 453,	469, 327, 327, 330,	333, 338, 345, 352,	361, 371, 382, 394,
406, 420, 434, 449,	464, 480, 343, 344,	346, 350, 354, 360,	368, 376, 386, 396,
408, 420, 433, 447,	461, 476, 491, 360,	361, 363, 366, 371,	377, 384, 392, 401,
411, 422, 434, 447,	460, 474, 488, 504,	378, 379, 381, 384,	388, 394, 400, 408,
417, 427, 437, 449,	461, 474, 488, 502,	516, 396, 397, 399,	402, 406, 411, 418,
425, 433, 443, 453,	464, 476, 488, 502,	515, 530, 415, 415,	417, 420, 424, 429,
435, 442, 450, 459,	469, 480, 491, 504,	516, 530, 544, 264,	265, 268, 273, 281,
290, 300, 313, 326,	341, 356, 373, 390,	408, 427, 446, 466,	265, 266, 269, 274,
282, 291, 301, 314,	327, 342, 357, 374,	391, 409, 428, 447,	466, 268, 269, 272,
278, 285, 294, 304,	316, 330, 344, 360,	376, 393, 411, 430,	449, 468, 273, 274,
278, 283, 290, 299,	309, 321, 334, 348,	364, 380, 397, 415,	433, 452, 471, 281,
282, 285, 290, 297,	305, 315, 327, 340,	354, 369, 385, 402,	419, 438, 456, 475,
290, 291, 294, 299,	305, 314, 323, 335,	347, 361, 376, 392,	408, 426, 443, 462,
481, 300, 301, 304,	309, 315, 323, 333,	344, 356, 370, 384,	400, 416, 433, 450,
469, 487, 313, 314,	316, 321, 327, 335,	344, 355, 367, 380,	394, 409, 425, 441,
459, 477, 495, 326,	327, 330, 334, 340,	347, 356, 367, 378,	391, 405, 419, 435,
451, 468, 485, 504,	341, 342, 344, 348,	354, 361, 370, 380,	391, 403, 417, 431,
446, 462, 478, 495,	513, 356, 357, 360,	364, 369, 376, 384,	394, 405, 417, 430,
443, 458, 473, 490,	506, 524, 373, 374,	376, 380, 385, 392,	400, 409, 419, 431,
443, 457, 471, 486,	502, 518, 535, 390,	391, 393, 397, 402,	408, 416, 425, 435,
446, 458, 471, 485,	499, 515, 531, 547,	408, 409, 411, 415,	419, 426, 433, 441,
451, 462, 473, 486,	499, 514, 529, 544,	560, 427, 428, 430,	433, 438, 443, 450,
459, 468, 478, 490,	502, 515, 529, 543,	558, 574, 446, 447,	449, 452, 456, 462,
469, 477, 485, 495,	506, 518, 531, 544,	558, 573, 588, 466,	466, 468, 471, 475,
481, 487, 495, 504,	513, 524, 535, 547,	560, 574, 588, 603,	312, 313, 316, 321,
329, 338, 348, 361,	375, 390, 406, 423,	441, 460, 479, 499,	519, 313, 314, 317,
322, 330, 339, 349,	362, 376, 390, 407,	424, 442, 460, 480,	500, 520, 316, 317,
320, 325, 333, 342,	352, 365, 378, 393,	409, 426, 444, 462,	482, 502, 522, 321,
322, 325, 331, 338,	347, 357, 369, 383,	397, 413, 430, 448,	466, 485, 505, 525,
329, 330, 333, 338,	345, 353, 364, 376,	389, 403, 419, 435,	453, 471, 490, 510,
530, 338, 339, 342,	347, 353, 362, 372,	384, 396, 411, 426,	442, 460, 478, 496,
516, 535, 348, 349,	352, 357, 364, 372,	382, 393, 406, 420,	435, 451, 468, 485,
504, 523, 542, 361,	362, 365, 369, 376,	384, 393, 404, 416,	430, 445, 460, 477,
494, 512, 531, 550,	375, 376, 378, 383,	389, 396, 406, 416,	428, 442, 456, 471,
487, 504, 522, 540,	560, 390, 390, 393,	397, 403, 411, 420,	430, 442, 454, 468,
483, 499, 516, 533,	551, 570, 406, 407,	409, 413, 419, 426,	435, 445, 456, 468,
482, 496, 512, 528,	545, 563, 581, 423,	424, 426, 430, 435,	442, 451, 460, 471,
483, 496, 510, 525,	541, 558, 575, 593,	441, 442, 444, 448,	453, 460, 468, 477,
487, 499, 512, 525,	540, 555, 571, 588,	606, 460, 460, 462,	466, 471, 478, 485,
494, 504, 516, 528,	541, 555, 570, 586,	602, 620, 479, 480,	482, 485, 490, 496,
504, 512, 522, 533,	545, 558, 571, 586,	601, 617, 634, 499,	500, 502, 505, 510,
516, 523, 531, 540,	551, 563, 575, 588,	602, 617, 633, 649,	519, 520, 522, 525,
530, 535, 542, 550,	560, 570, 581, 593,	606, 620, 634, 649,	665, 364, 365, 368,
373, 380, 390, 401,	413, 427, 442, 459,	476, 495, 514, 534,	555, 577, 365, 366,
369, 374, 381, 391,	401, 414, 428, 443,	460, 477, 496, 515,	535, 556, 577, 368,
369, 372, 377, 385,	394, 404, 417, 431,	446, 462, 480, 498,	517, 537, 558, 579,
373, 374, 377, 383,	390, 399, 409, 421,	435, 450, 466, 484,	502, 521, 541, 562,
583, 380, 381, 385,	390, 397, 405, 416,	428, 441, 456, 472,	489, 507, 526, 546,
566, 587, 390, 391,	394, 399, 405, 414,	424, 436, 449, 464,	480, 496, 514, 533,
552, 573, 593, 401,	401, 404, 409, 416,	424, 434, 446, 459,	473, 489, 505, 523,
541, 560, 580, 601,	413, 414, 417, 421,	428, 436, 446, 457,	470, 484, 499, 515,
532, 550, 569, 589,	609, 427, 428, 431,	435, 441, 449, 459,	470, 482, 496, 510,
526, 543, 561, 579,	599, 619, 442, 443,	446, 450, 456, 464,	473, 484, 496, 509,
523, 539, 555, 573,	591, 610, 629, 459,	460, 462, 466, 472,	480, 489, 499, 510,
523, 537, 552, 568,	585, 603, 622, 641,	476, 477, 480, 484,	489, 496, 505, 515,
526, 539, 552, 567,	583, 599, 617, 635,	654, 495, 496, 498,	502, 507, 514, 523,
532, 543, 555, 568,	583, 598, 614, 631,	649, 667, 514, 515,	517, 521, 526, 533,
541, 550, 561, 573,	585, 599, 614, 630,	646, 664, 682, 534,	535, 537, 541, 546,
552, 560, 569, 579,	591, 603, 617, 631,	646, 663, 679, 697,	555, 556, 558, 562,
566, 573, 580, 589,	599, 610, 622, 635,	649, 664, 679, 696,	713, 577, 577, 579,
583, 587, 593, 601,	609, 619, 629, 641,	654, 667, 682, 697,	713, 730, 420, 421,
424, 429, 436, 446,	457, 469, 483, 499,	516, 534, 553, 573,	593, 615, 637, 421,
422, 425, 430, 437,	447, 457, 470, 484,	500, 517, 534, 553,	573, 594, 616, 638,
424, 425, 428, 433,	440, 450, 460, 473,	487, 502, 519, 537,	556, 576, 596, 618,
640, 429, 430, 433,	438, 446, 455, 465,	478, 492, 507, 523,	541, 560, 580, 600,
621, 643, 436, 437,	440, 446, 453, 461,	472, 484, 498, 513,	529, 547, 565, 585,
605, 627, 648, 446,	447, 450, 455, 461,	470, 480, 492, 506,	521, 537, 554, 573,
592, 612, 633, 655,	457, 457, 460, 465,	472, 480, 491, 502,	516, 530, 546, 563,
581, 600, 620, 641,	662, 469, 470, 473,	478, 484, 492, 502,	514, 527, 541, 557,
573, 591, 610, 629,	650, 671, 483, 484,	487, 492, 498, 506,	516, 527, 539, 553,
569, 585, 602, 621,	640, 660, 681, 499,	500, 502, 507, 513,	521, 530, 541, 553,
567, 582, 598, 615,	633, 652, 672, 692,	516, 517, 519, 523,	529, 537, 546, 557,
569, 582, 596, 612,	629, 646, 665, 684,	704, 534, 534, 537,	541, 547, 554, 563,
573, 585, 598, 612,	627, 643, 661, 679,	698, 717, 553, 553,	556, 560, 565, 573,
581, 591, 602, 615,	629, 643, 659, 676,	694, 712, 732, 573,	573, 576, 580, 585,
592, 600, 610, 621,	633, 646, 661, 676,	693, 710, 728, 747,	593, 594, 596, 600,
605, 612, 620, 629,	640, 652, 665, 679,	694, 710, 727, 744,	763, 615, 616, 618,
621, 627, 633, 641,	650, 660, 672, 684,	698, 712, 728, 744,	762, 780, 637, 638,
640, 643, 648, 655,	662, 671, 681, 692,	704, 717, 732, 747,	763, 780, 797, 480,
481, 484, 489, 496,	505, 516, 529, 543,	559, 576, 595, 614,	635, 656, 678, 701,
481, 482, 485, 490,	497, 506, 517, 530,	544, 560, 577, 596,	615, 635, 657, 679,
702, 484, 485, 488,	493, 500, 509, 520,	533, 547, 563, 580,	598, 617, 638, 659,
681, 704, 489, 490,	493, 498, 505, 514,	525, 538, 552, 567,	584, 602, 622, 642,
663, 685, 708, 496,	497, 500, 505, 512,	521, 532, 544, 558,	574, 590, 608, 627,
647, 668, 690, 713,	505, 506, 509, 514,	521, 530, 541, 553,	566, 582, 598, 616,
635, 654, 675, 697,	719, 516, 517, 520,	525, 532, 541, 551,	563, 576, 591, 607,
625, 643, 663, 683,	705, 727, 529, 530,	533, 538, 544, 553,	563, 575, 588, 602,
618, 635, 654, 673,	693, 714, 736, 543,	544, 547, 552, 558,	566, 576, 588, 601,
615, 631, 647, 665,	684, 704, 725, 746,	559, 560, 563, 567,	574, 582, 591, 602,
615, 629, 644, 661,	678, 697, 716, 737,	758, 576, 577, 580,	584, 590, 598, 607,
618, 631, 644, 659,	675, 692, 711, 730,	750, 771, 595, 596,	598, 602, 608, 616,
625, 635, 647, 661,	675, 691, 708, 725,	744, 764, 784, 614,	615, 617, 622, 627,
635, 643, 654, 665,	678, 692, 708, 724,	742, 760, 779, 799,	635, 635, 638, 642,
647, 654, 663, 673,	684, 697, 711, 725,	742, 759, 777, 795,	815, 656, 657, 659,
663, 668, 675, 683,	693, 704, 716, 730,	744, 760, 777, 794,	813, 832, 678, 679,
681, 685, 690, 697,	705, 714, 725, 737,	750, 764, 779, 795,	813, 831, 849, 701,
702, 704, 708, 713,	719, 727, 736, 746,	758, 771, 784, 799,	815, 832, 849, 868,
543, 545, 548, 553,	560, 569, 580, 593,	608, 624, 641, 660,	679, 700, 722, 745,
769, 545, 546, 549,	554, 561, 570, 581,	594, 609, 624, 642,	660, 680, 701, 723,
746, 769, 548, 549,	552, 557, 564, 573,	584, 597, 611, 627,	644, 663, 683, 704,
725, 748, 772, 553,	554, 557, 562, 569,	578, 589, 602, 616,	632, 649, 667, 687,
708, 729, 752, 775,	560, 561, 564, 569,	576, 585, 596, 609,	623, 638, 655, 673,
693, 713, 735, 757,	780, 569, 570, 573,	578, 585, 594, 605,	617, 631, 646, 663,
681, 700, 721, 742,	764, 787, 580, 581,	584, 589, 596, 605,	615, 627, 641, 656,
673, 690, 709, 729,	750, 772, 795, 593,	594, 597, 602, 609,	617, 627, 639, 652,
667, 684, 701, 720,	740, 760, 782, 805,	608, 609, 611, 616,	623, 631, 641, 652,
666, 680, 696, 713,	732, 751, 772, 793,	815, 624, 624, 627,	632, 638, 646, 656,
667, 680, 694, 710,	727, 745, 764, 784,	805, 827, 641, 642,	644, 649, 655, 663,
673, 684, 696, 710,	725, 742, 760, 778,	798, 819, 840, 660,	660, 663, 667, 673,
681, 690, 701, 713,	727, 742, 758, 775,	794, 813, 833, 855,	679, 680, 683, 687,
693, 700, 709, 720,	732, 745, 760, 775,	792, 810, 829, 849,	870, 700, 701, 704,
708, 713, 721, 729,	740, 751, 764, 778,	794, 810, 828, 846,	866, 886, 722, 723,
725, 729, 735, 742,	750, 760, 772, 784,	798, 813, 829, 846,	865, 884, 904, 745,
746, 748, 752, 757,	764, 772, 782, 793,	805, 819, 833, 849,	866, 884, 903, 922,
769, 769, 772, 775,	780, 787, 795, 805,	815, 827, 840, 855,	870, 886, 904, 922,
941,
};
#endif
uint8_t ir_preprocess_w_lut[] = {
	127,  64,  42,  32,  25,  21,  18,  16,  14,  13,  12,  11,  10,   9,   8,   8,
	7,   7,   7,   6,   6,   6,   6,   5,   5,   5,   5,   5,   4,   4,   4,   4,
	4,   4,   4,   4,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
	3,   3,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
	2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
	2,   2,   2,   2,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
	1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
	1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1
};

int16_t preprocess_r_ir_ratio[] = {
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	-62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62
};

int16_t preprocess_g_ir_ratio[] = {
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175,
	-175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175, -175
};

int16_t preprocess_b_ir_ratio[] = {
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
	9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,    9
};

uint8_t ir_preprocess_gamma[] = {
	0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,
	16,   17,   18,   19,   20,   21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,
	32,   33,   34,   35,   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,
	48,   49,   50,   51,   52,   53,   54,   55,   56,   57,   58,   59,   60,   61,   62,   63,
	64,   65,   66,   67,   68,   69,   70,   71,   72,   73,   74,   75,   76,   77,   78,   79,
	80,   81,   82,   83,   84,   85,   86,   87,   88,   89,   90,   91,   92,   93,   94,   95,
	96,   97,   98,   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,  111,
	112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,  125,  126,  127,
	128,  128,  129,  130,  131,  132,  133,  134,  135,  136,  137,  138,  139,  140,  141,  142,
	143,  144,  145,  146,  147,  148,  149,  150,  151,  152,  153,  154,  155,  156,  157,  158,
	159,  160,  161,  162,  163,  164,  165,  166,  167,  168,  169,  170,  171,  172,  173,  174,
	175,  176,  177,  178,  179,  180,  181,  182,  183,  184,  185,  186,  187,  188,  189,  190,
	191,  192,  193,  194,  195,  196,  197,  198,  199,  200,  201,  202,  203,  204,  205,  206,
	207,  208,  209,  210,  211,  212,  213,  214,  215,  216,  217,  218,  219,  220,  221,  222,
	223,  224,  225,  226,  227,  228,  229,  230,  231,  232,  233,  234,  235,  236,  237,  238,
	239,  240,  241,  242,  243,  244,  245,  246,  247,  248,  249,  250,  251,  252,  253,  254
};
/*************************************************************************
 *	Main functions
 *************************************************************************/

#define DMA_SETUP(id)						\
	do {							\
		bufaddr = _mempool_get_addr();			\
		bufsize = ispblk_dma_config(ictx, id, bufaddr); \
		_mempool_pop(bufsize);				\
	} while (0)

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
static void legacy_timer_emu_func(struct timer_list *t)
{
	struct legacy_timer_emu *lt = from_timer(lt, t, t);

	lt->function(lt->data);
}
#endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))

/**
 * _mempool_reset - reset the byteused and assigned buffer for each dma
 *
 */
static void _mempool_reset(void)
{
	u8 i = 0;

	isp_mempool.byteused = 0;

	memset(isp_bufpool, 0x0, (sizeof(struct _membuf) * ISP_PRERAW_MAX));

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		spin_lock_init(&isp_bufpool[i].pre_fe_sts_lock);
		spin_lock_init(&isp_bufpool[i].pre_be_sts_lock);
		spin_lock_init(&isp_bufpool[i].post_sts_lock);
		spin_lock_init(&isp_bufpool[i].awb_sts_lock);
	}
}

/**
 * isp_mempool_setup - init isp's mempool
 *
 * @param addr: base-address of the mempool
 * @param size: size of the mempool
 */
void isp_mempool_setup(void)
{
	_mempool_reset();
	_isp_tuning_setup();
}

/**
 * _mempool_get_addr - get mempool's latest address.
 *
 * @return: the latest address of the mempool.
 */
static uint64_t _mempool_get_addr(void)
{
	return isp_mempool.base + isp_mempool.byteused;
}

/**
 * _mempool_pop - acquire a buffer-space from mempool.
 *
 * @param size: the space acquired.
 * @return: negative if no enough space; o/w, the address of the buffer needed.
 */
static int64_t _mempool_pop(uint32_t size)
{
	int64_t addr;

	size = VIP_ALIGN(size);

	if ((isp_mempool.byteused + size) > isp_mempool.size) {
		vip_pr(CVI_ERR, "reserved_memory(0x%x) is not enough. byteused(0x%x) alloc_size(0x%x)\n",
				isp_mempool.size, isp_mempool.byteused, size);
		return -EINVAL;
	}

	addr = isp_mempool.base + isp_mempool.byteused;
	isp_mempool.byteused += size;

	return addr;
}

static void _isp_tuning_clear(void)
{
	struct cvi_vip_isp_post_cfg *post_cfg;
	struct cvi_vip_isp_be_cfg   *be_cfg;
	struct cvi_vip_isp_fe_cfg   *fe_cfg;
	u8 i = 0, tun_idx = 0;

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		post_cfg = (struct cvi_vip_isp_post_cfg *)tuning_buf_addr.post_vir[i];
		be_cfg   = (struct cvi_vip_isp_be_cfg *)tuning_buf_addr.be_vir[i];
		fe_cfg   = (struct cvi_vip_isp_fe_cfg *)tuning_buf_addr.fe_vir[i];

		if (tuning_buf_addr.post_vir[i] != NULL) {
			memset((void *)tuning_buf_addr.post_vir[i], 0x0, sizeof(struct cvi_vip_isp_post_cfg));
			tun_idx = post_cfg->tun_idx;
			vip_pr(CVI_INFO, "Clear post tuning tun_update(%d), tun_idx(%d)",
					post_cfg->tun_update[tun_idx], tun_idx);
		}
		if (tuning_buf_addr.be_vir[i] != NULL) {
			memset((void *)tuning_buf_addr.be_vir[i], 0x0, sizeof(struct cvi_vip_isp_be_cfg));
			tun_idx = be_cfg->tun_idx;
			vip_pr(CVI_INFO, "Clear be tuning tun_update(%d), tun_idx(%d)",
					be_cfg->tun_update[tun_idx], tun_idx);
		}
		if (tuning_buf_addr.fe_vir[i] != NULL) {
			memset((void *)tuning_buf_addr.fe_vir[i], 0x0, sizeof(struct cvi_vip_isp_fe_cfg));
			tun_idx = fe_cfg->tun_idx;
			vip_pr(CVI_INFO, "Clear fe tuning tun_update(%d), tun_idx(%d)",
					fe_cfg->tun_update[tun_idx], tun_idx);
		}
	}
}

u8 _isp_tuning_setup(void)
{
	uint8_t i = 0;
	static u64 fe_paddr[ISP_PRERAW_MAX] = {0, 0};
	static u64 be_paddr[ISP_PRERAW_MAX] = {0, 0};
	static u64 post_paddr[ISP_PRERAW_MAX] = {0, 0};
	u32 size = 0;

	size = (sizeof(struct cvi_vip_isp_post_cfg) +
		sizeof(struct cvi_vip_isp_be_cfg) +
		sizeof(struct cvi_vip_isp_fe_cfg));
	size = VIP_ALIGN(size);

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		u64 phyAddr = 0;

		if (ptr[i] == NULL) {
			ptr[i] = kmalloc(size, GFP_KERNEL | __GFP_RETRY_MAYFAIL);
			if (ptr[i] == NULL) {
				vip_pr(CVI_ERR, "tuning_buf ptr[%d] kmalloc size(%zd) fail\n", i, size);
				return 1;
			}
			memset(ptr[i], 0x0, size);

			phyAddr = virt_to_phys(ptr[i]);
		}

		if (post_paddr[i] == 0) {
			post_paddr[i] = phyAddr;
			tuning_buf_addr.post_addr[i] = post_paddr[i];
			tuning_buf_addr.post_vir[i] = phys_to_virt(post_paddr[i]);
		}

		if (be_paddr[i] == 0) {
			be_paddr[i] = phyAddr + VIP_ALIGN(sizeof(struct cvi_vip_isp_post_cfg));
			tuning_buf_addr.be_addr[i] = be_paddr[i];
			tuning_buf_addr.be_vir[i] = phys_to_virt(be_paddr[i]);
		}

		if (fe_paddr[i] == 0) {
			fe_paddr[i] = phyAddr + VIP_ALIGN(sizeof(struct cvi_vip_isp_post_cfg))
					+ VIP_ALIGN(sizeof(struct cvi_vip_isp_be_cfg));
			tuning_buf_addr.fe_addr[i] = fe_paddr[i];
			tuning_buf_addr.fe_vir[i] = phys_to_virt(fe_paddr[i]);
		}

		vip_pr(CVI_INFO, "tuning fe_addr[%d]=0x%llx, be_addr[%d]=0x%llx, post_addr[%d]=0x%llx\n",
				i, tuning_buf_addr.fe_addr[i],
				i, tuning_buf_addr.be_addr[i],
				i, tuning_buf_addr.post_addr[i]);
	}

	return 0;
}

void _isp_snr_cfg_enq(struct cvi_isp_snr_update *snr_node, const enum cvi_isp_raw raw_num)
{
	unsigned long flags;
	struct _isp_snr_i2c_node  *n;

	if (snr_node == NULL)
		return;

	spin_lock_irqsave(&snr_node_lock[raw_num], flags);

	if (snr_node->snr_cfg_node.snsr.need_update) {
		n = kmalloc(sizeof(*n), GFP_ATOMIC);
		if (n == NULL) {
			vip_pr(CVI_ERR, "SNR cfg node alloc size(%d) fail\n", sizeof(*n));
			spin_unlock_irqrestore(&snr_node_lock[raw_num], flags);
			return;
		}
		memcpy(&n->n, &snr_node->snr_cfg_node.snsr, sizeof(struct snsr_regs_s));
		list_add_tail(&n->list, &isp_snr_i2c_queue[raw_num].list);
	}

	spin_unlock_irqrestore(&snr_node_lock[raw_num], flags);
}

void pre_raw_num_enq(struct _isp_sof_raw_num_q *q, struct _isp_raw_num_n *n)
{
	unsigned long flags;

	spin_lock_irqsave(&raw_num_lock, flags);
	list_add_tail(&n->list, &q->list);
	spin_unlock_irqrestore(&raw_num_lock, flags);
}

struct isp_buffer *isp_next_buf(struct isp_queue *q)
{
	struct isp_buffer *b = NULL;
	unsigned long flags;

	spin_lock_irqsave(&buf_lock, flags);
	if (!list_empty(&q->rdy_queue))
		b = list_first_entry(&q->rdy_queue, struct isp_buffer, list);
	spin_unlock_irqrestore(&buf_lock, flags);

	return b;
}

void isp_buf_queue(struct isp_queue *q, struct isp_buffer *b)
{
	unsigned long flags;

	if (b == NULL)
		return;

	spin_lock_irqsave(&buf_lock, flags);
	list_add_tail(&b->list, &q->rdy_queue);
	++q->num_rdy;
	spin_unlock_irqrestore(&buf_lock, flags);
}

struct isp_buffer *isp_buf_remove(struct isp_queue *q)
{
	struct isp_buffer *b = NULL;
	unsigned long flags;

	spin_lock_irqsave(&buf_lock, flags);
	if (!list_empty(&q->rdy_queue)) {
		b = list_first_entry(&q->rdy_queue, struct isp_buffer, list);
		list_del_init(&b->list);
		--q->num_rdy;
	}
	spin_unlock_irqrestore(&buf_lock, flags);

	return b;
}

void _cvi_isp_buf_queue2(struct cvi_isp_vdev *vdev, struct cvi_isp_buf2 *b)
{
	unsigned long flags;

	vip_pr(CVI_DBG, "buf_queue chn_id=%d\n", vdev->chn_id);

	spin_lock_irqsave(&vdev->qbuf_lock, flags);
	list_add_tail(&b->list, &vdev->qbuf_list[vdev->chn_id]);
	++vdev->qbuf_num[vdev->chn_id];
	spin_unlock_irqrestore(&vdev->qbuf_lock, flags);
}

struct cvi_isp_buf2 *_cvi_isp_next_buf2(struct cvi_isp_vdev *vdev, const u8 chn_num)
{
	unsigned long flags;
	struct cvi_isp_buf2 *b = NULL;

	spin_lock_irqsave(&vdev->qbuf_lock, flags);
	if (!list_empty(&vdev->qbuf_list[chn_num]))
		b = list_first_entry(&vdev->qbuf_list[chn_num], struct cvi_isp_buf2, list);
	spin_unlock_irqrestore(&vdev->qbuf_lock, flags);

	return b;
}

int cvi_isp_rdy_buf_empty2(struct cvi_isp_vdev *vdev, const u8 chn_num)
{
	unsigned long flags;
	int empty = 0;

	spin_lock_irqsave(&vdev->qbuf_lock, flags);
	empty = (vdev->qbuf_num[chn_num] == 0);
	spin_unlock_irqrestore(&vdev->qbuf_lock, flags);

	return empty;
}

void cvi_isp_rdy_buf_pop2(struct cvi_isp_vdev *vdev, const u8 chn_num)
{
	unsigned long flags;

	spin_lock_irqsave(&vdev->qbuf_lock, flags);
	vdev->qbuf_num[chn_num]--;
	spin_unlock_irqrestore(&vdev->qbuf_lock, flags);
}

void cvi_isp_rdy_buf_remove2(struct cvi_isp_vdev *vdev, const u8 chn_num)
{
	unsigned long flags;
	struct cvi_isp_buf2 *b = NULL;

	spin_lock_irqsave(&vdev->qbuf_lock, flags);
	if (!list_empty(&vdev->qbuf_list[chn_num])) {
		b = list_first_entry(&vdev->qbuf_list[chn_num], struct cvi_isp_buf2, list);
		list_del_init(&b->list);
		kfree(b);
	}
	spin_unlock_irqrestore(&vdev->qbuf_lock, flags);
}

void _vi_yuv_dma_setup(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num)
{
	struct isp_buffer *b;
	uint32_t bufsize_yuyv = 0;
	uint8_t  i = 0;

	struct _membuf *pool = &isp_bufpool[raw_num];

	u8 total_chn = (raw_num == ISP_PRERAW_A) ?
			ctx->rawb_chnstr_num :
			ctx->total_chn_num;
	u8 chn_str = (raw_num == ISP_PRERAW_A) ? 0 : ctx->rawb_chnstr_num;

	for (; chn_str < total_chn; chn_str++) {
		u32 dma = (chn_str == ctx->rawb_chnstr_num) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7;

		for (i = 0; i < OFFLINE_YUV_BUF_NUM; i++) {
			b = vmalloc(sizeof(*b));
			if (b == NULL) {
				vip_pr(CVI_ERR, "yuv_buf isp_buf_%d vmalloc size(%d) fail\n", i, sizeof(*b));
				return;
			}
			memset(b, 0, sizeof(*b));
			b->chn_num = chn_str;
			b->is_yuv_frm = true;
			bufsize_yuyv = ispblk_dma_yuv_bypass_config(ctx, dma, 0, raw_num);
			pool->yuv_yuyv[b->chn_num][i] = b->addr = _mempool_pop(bufsize_yuyv);

			if (i == 0)
				ispblk_dma_setaddr(ctx, dma, b->addr);

			isp_buf_queue(&pre_out_queue[b->chn_num], b);
		}
	}
}

static void _isp_preraw_fe_dma_dump(struct isp_ctx *ictx, enum cvi_isp_raw  raw_num)
{
	u8 i = 0;
	char str[64] = "PRERAW_FE";

	vip_pr(CVI_INFO, "***************%s_%d************************\n", str, raw_num);
	for (i = 0; i < OFFLINE_RAW_BUF_NUM; i++)
		vip_pr(CVI_INFO, "bayer_le(0x%llx)\n", isp_bufpool[raw_num].bayer_le[i]);

	for (i = 0; i < RGBMAP_BUF_IDX; i++)
		vip_pr(CVI_INFO, "rgbmap_le(0x%llx)\n", isp_bufpool[raw_num].rgbmap_le[i]);

	vip_pr(CVI_INFO, "lmap_le(0x%llx)\n", isp_bufpool[raw_num].lmap_le);

	if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
		for (i = 0; i < OFFLINE_RAW_BUF_NUM; i++)
			vip_pr(CVI_INFO, "bayer_se(0x%llx)\n", isp_bufpool[raw_num].bayer_se[i]);

		for (i = 0; i < RGBMAP_BUF_IDX; i++)
			vip_pr(CVI_INFO, "rgbmap_se(0x%llx)\n", isp_bufpool[raw_num].rgbmap_se[i]);

		vip_pr(CVI_INFO, "lmap_se(0x%llx)\n", isp_bufpool[raw_num].lmap_se);
	}

	if (ictx->isp_pipe_cfg[raw_num].is_yuv_bypass_path &&
		!ictx->isp_pipe_cfg[raw_num].is_offline_scaler) {
		for (i = 0; i < ISP_CHN_MAX; i++) {
			vip_pr(CVI_INFO, "yuyv_yuv(0x%llx), yuyv_yuv(0x%llx)\n",
				isp_bufpool[raw_num].yuv_yuyv[i][0], isp_bufpool[raw_num].yuv_yuyv[i][1]);
		}
	}
	vip_pr(CVI_INFO, "*************************************************\n");
}

static void _isp_preraw_be_dma_dump(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	u8 i = 0;
	char str[64] = "PRERAW_BE";
	enum cvi_isp_raw raw = ISP_PRERAW_A;

	vip_pr(CVI_INFO, "***************%s************************\n", str);
	vip_pr(CVI_INFO, "rdma4_le(0x%llx)\n", isp_bufpool[raw].bayer_le[0]);
	for (i = 0; i < OFFLINE_PRE_BE_BUF_NUM; i++)
		vip_pr(CVI_INFO, "prebe_le(0x%llx)\n", isp_bufpool[raw].prebe_le[i]);

	if (ictx->is_hdr_on) {
		vip_pr(CVI_INFO, "rdma18_se(0x%llx)\n", isp_bufpool[raw].bayer_se[0]);
		for (i = 0; i < OFFLINE_PRE_BE_BUF_NUM; i++)
			vip_pr(CVI_INFO, "prebe_se(0x%llx)\n", isp_bufpool[raw].prebe_se[i]);
	}

	for (; raw < raw_max; raw++) {
		if (raw == ISP_PRERAW_B)
			vip_pr(CVI_INFO, "***********************Dual sensor dump**********************\n");

		vip_pr(CVI_INFO, "af(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].af.phy_addr,
				isp_bufpool[raw].sts_mem[1].af.phy_addr);
		vip_pr(CVI_INFO, "ae_le(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].ae_le.phy_addr,
				isp_bufpool[raw].sts_mem[1].ae_le.phy_addr);
		vip_pr(CVI_INFO, "gms(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].gms.phy_addr,
				isp_bufpool[raw].sts_mem[1].gms.phy_addr);
		vip_pr(CVI_INFO, "awb(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].awb.phy_addr,
				isp_bufpool[raw].sts_mem[1].awb.phy_addr);

		if (ictx->isp_pipe_cfg[raw].is_hdr_on) {
			vip_pr(CVI_INFO, "ae_se(0x%llx, 0x%llx)\n",
					isp_bufpool[raw].sts_mem[0].ae_se.phy_addr,
					isp_bufpool[raw].sts_mem[1].ae_se.phy_addr);
		}
	}
	vip_pr(CVI_INFO, "*************************************************\n");
}

static void _isp_rawtop_dma_dump(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	char str[64] = "RAW_TOP";
	enum cvi_isp_raw raw = ISP_PRERAW_A;

	vip_pr(CVI_INFO, "***************%s************************\n", str);
	vip_pr(CVI_INFO, "rdma5_le(0x%llx)\n", isp_bufpool[raw].prebe_le[0]);
	if (ictx->is_hdr_on)
		vip_pr(CVI_INFO, "rdma6_se(0x%llx)\n", isp_bufpool[raw].prebe_se[0]);
	vip_pr(CVI_INFO, "*************************************************\n");
}

static void _isp_rgbtop_dma_dump(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	char str[64] = "RGB_TOP";
	enum cvi_isp_raw raw = ISP_PRERAW_A;

	vip_pr(CVI_INFO, "***************%s************************\n", str);
	for (; raw < raw_max; raw++) {
		if (raw == ISP_PRERAW_B)
			vip_pr(CVI_INFO, "***********************Dual sensor dump**********************\n");

		vip_pr(CVI_INFO, "lsc(0x%llx)\n", isp_bufpool[raw].lsc);

		vip_pr(CVI_INFO, "awb_post(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].awb_post.phy_addr,
				isp_bufpool[raw].sts_mem[1].awb_post.phy_addr);
		vip_pr(CVI_INFO, "hist_edge_v(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].hist_edge_v.phy_addr,
				isp_bufpool[raw].sts_mem[1].hist_edge_v.phy_addr);
		vip_pr(CVI_INFO, "dci(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].sts_mem[0].dci.phy_addr,
				isp_bufpool[raw].sts_mem[1].dci.phy_addr);
		vip_pr(CVI_INFO, "manr(0x%llx), manr_rtile(0x%llx)\n",
				isp_bufpool[raw].manr,
				isp_bufpool[raw].manr_rtile);
		vip_pr(CVI_INFO, "tdnr(0x%llx, 0x%llx), tdnr_rtile(0x%llx, 0x%llx)\n",
				isp_bufpool[raw].tdnr[0],
				isp_bufpool[raw].tdnr[1],
				isp_bufpool[raw].tdnr_rtile[0],
				isp_bufpool[raw].tdnr_rtile[1]);
	}
	vip_pr(CVI_INFO, "*************************************************\n");
	vip_pr(CVI_INFO, "VI total reserved memory(0x%x)\n", isp_mempool.byteused);
	vip_pr(CVI_INFO, "*************************************************\n");
}

void _isp_preraw_fe_dma_setup(struct isp_ctx *ictx, enum cvi_isp_raw  raw_num)
{
	uint64_t bufaddr = 0;
	uint32_t bufsize = 0;
	uint8_t  i = 0;
	struct isp_buffer *b;

	u32 raw_le = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA6;
	u32 raw_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA1 : ISP_BLK_ID_WDMA7;
	u32 rgbmap_le = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA2 : ISP_BLK_ID_WDMA8;
	u32 rgbmap_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA4 : ISP_BLK_ID_WDMA10;
	u32 lmap_le = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA3 : ISP_BLK_ID_WDMA9;
	u32 lmap_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA5 : ISP_BLK_ID_WDMA11;

	if (ictx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //YUV sensor
		if (!ictx->isp_pipe_cfg[raw_num].is_offline_scaler) //Online mode to scaler
			_vi_yuv_dma_setup(ictx, raw_num);

		goto EXIT;
	}

	if (_is_be_post_online(ictx)) { //fe->dram->be->post
		for (i = 0; i < OFFLINE_RAW_BUF_NUM; i++) {
			DMA_SETUP(raw_le);
			b = vmalloc(sizeof(*b));
			if (b == NULL) {
				vip_pr(CVI_ERR, "raw_le isp_buf_%d vmalloc size(%d) fail\n", i, sizeof(*b));
				return;
			}
			memset(b, 0, sizeof(*b));
			b->addr = bufaddr;
			b->raw_num = raw_num;
			b->ir_idx = i;
			isp_bufpool[raw_num].bayer_le[i] = b->addr;
			isp_buf_queue(&pre_out_queue[b->raw_num], b);
		}
		ispblk_dma_setaddr(ictx, raw_le, isp_bufpool[raw_num].bayer_le[0]);

		if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
			for (i = 0; i < OFFLINE_RAW_BUF_NUM; i++) {
				DMA_SETUP(raw_se);
				b = vmalloc(sizeof(*b));
				if (b == NULL) {
					vip_pr(CVI_ERR, "raw_se isp_buf_%d vmalloc size(%d) fail\n", i, sizeof(*b));
					return;
				}
				memset(b, 0, sizeof(*b));
				b->addr = bufaddr;
				b->raw_num = raw_num;
				b->ir_idx = i;
				isp_bufpool[raw_num].bayer_se[i] = b->addr;
				isp_buf_queue(&pre_out_se_queue[b->raw_num], b);
			}
			ispblk_dma_setaddr(ictx, raw_se, isp_bufpool[raw_num].bayer_se[0]);
		}
	}

	// rgbmap
	bufaddr = _mempool_get_addr();
	ispblk_dma_config(ictx, rgbmap_le, bufaddr);
	bufsize = ispblk_dma_buf_get_size(ictx, rgbmap_le);
	_mempool_pop(bufsize);

	isp_bufpool[raw_num].rgbmap_le[0] = bufaddr;
	if (!_is_all_online(ictx)) {
		for (i = 1; i < RGBMAP_BUF_IDX; i++)
			isp_bufpool[raw_num].rgbmap_le[i] = _mempool_pop(bufsize);
	}

	// lmap_le
	bufaddr = _mempool_get_addr();
	ispblk_dma_config(ictx, lmap_le, bufaddr);
	bufsize = ispblk_dma_buf_get_size(ictx, lmap_le);
	_mempool_pop(bufsize);

	isp_bufpool[raw_num].lmap_le = bufaddr;

	if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
		// rgbmap se
		bufaddr = _mempool_get_addr();
		ispblk_dma_config(ictx, rgbmap_se, bufaddr);
		bufsize = ispblk_dma_buf_get_size(ictx, rgbmap_se);
		_mempool_pop(bufsize);

		isp_bufpool[raw_num].rgbmap_se[0] = bufaddr;
		for (i = 1; i < RGBMAP_BUF_IDX; i++)
			isp_bufpool[raw_num].rgbmap_se[i] = _mempool_pop(bufsize);

		// lmap_se
		bufaddr = _mempool_get_addr();
		ispblk_dma_config(ictx, lmap_se, bufaddr);
		bufsize = ispblk_dma_buf_get_size(ictx, lmap_se);
		_mempool_pop(bufsize);

		isp_bufpool[raw_num].lmap_se = bufaddr;
	}

EXIT:
	_isp_preraw_fe_dma_dump(ictx, raw_num);
}

void _isp_preraw_be_dma_setup(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	uint64_t bufaddr = 0;
	uint32_t bufsize = 0;
	uint8_t  buf_num = 0;
	struct isp_buffer *b;

	enum cvi_isp_raw raw = ISP_PRERAW_A;

	u8 cfg_dma = false;

	//RGB path
	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_dma = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_dma = true;
	}

	ispblk_dma_enable(ictx, ISP_BLK_ID_RDMA4, false);
	ispblk_dma_enable(ictx, ISP_BLK_ID_RDMA18, false);

	if (cfg_dma == false)
		goto EXIT;

	if (ictx->is_offline_be) {
		//apply pre_fe wdma0 buffer
		ispblk_dma_config(ictx, ISP_BLK_ID_RDMA4, isp_bufpool[ISP_PRERAW_A].bayer_le[0]);

		if (ictx->is_hdr_on) {
			//apply pre_fe wdma1 buffer
			ispblk_dma_config(ictx, ISP_BLK_ID_RDMA18, isp_bufpool[ISP_PRERAW_A].bayer_se[0]);
		}
	}

	if (_is_fe_be_online(ictx)) { //fe->be->dram->post
		for (buf_num = 0; buf_num < OFFLINE_PRE_BE_BUF_NUM; buf_num++) {
			DMA_SETUP(ISP_BLK_ID_WDMA24);
			b = vmalloc(sizeof(*b));
			if (b == NULL) {
				vip_pr(CVI_ERR, "WDMA24 isp_buf_%d vmalloc size(%d) fail\n", buf_num, sizeof(*b));
				return;
			}
			memset(b, 0, sizeof(*b));
			b->addr = bufaddr;
			b->raw_num = raw;
			b->ir_idx = buf_num;
			isp_bufpool[raw].prebe_le[buf_num] = b->addr;
			isp_buf_queue(&pre_be_out_q, b);
		}

		ispblk_dma_setaddr(ictx, ISP_BLK_ID_WDMA24, isp_bufpool[raw].prebe_le[0]);

		if (ictx->isp_pipe_cfg[ISP_PRERAW_A].is_hdr_on) {
			for (buf_num = 0; buf_num < OFFLINE_PRE_BE_BUF_NUM; buf_num++) {
				DMA_SETUP(ISP_BLK_ID_WDMA25);
				b = vmalloc(sizeof(*b));
				if (b == NULL) {
					vip_pr(CVI_ERR, "WDMA25 isp_buf_%d vmalloc size(%d) fail\n",
							buf_num, sizeof(*b));
					return;
				}
				memset(b, 0, sizeof(*b));
				b->addr = bufaddr;
				b->raw_num = raw;
				b->ir_idx = buf_num;
				isp_bufpool[raw].prebe_se[buf_num] = b->addr;
				isp_buf_queue(&pre_be_out_se_q, b);
			}

			ispblk_dma_setaddr(ictx, ISP_BLK_ID_WDMA25, isp_bufpool[raw].prebe_se[0]);
		}
	}

	for (; raw < raw_max; raw++) {
		//Be out dma

		if (ictx->isp_pipe_cfg[raw].is_yuv_bypass_path)
			continue;

		// af
		DMA_SETUP(ISP_BLK_ID_WDMA16);
		isp_bufpool[raw].sts_mem[0].af.phy_addr = bufaddr;
		isp_bufpool[raw].sts_mem[0].af.size = bufsize;
		isp_bufpool[raw].sts_mem[1].af.phy_addr = _mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[1].af.size = bufsize;

		// gms
		bufaddr = _mempool_get_addr();
		ispblk_dma_config(ictx, ISP_BLK_ID_WDMA17, bufaddr);
		bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA17);
		_mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[0].gms.phy_addr = bufaddr;
		isp_bufpool[raw].sts_mem[0].gms.size = bufsize;
		isp_bufpool[raw].sts_mem[1].gms.phy_addr = _mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[1].gms.size = bufsize;

		// ae le
		DMA_SETUP(ISP_BLK_ID_WDMA18);
		isp_bufpool[raw].sts_mem[0].ae_le.phy_addr = bufaddr;
		isp_bufpool[raw].sts_mem[0].ae_le.size = bufsize;
		isp_bufpool[raw].sts_mem[1].ae_le.phy_addr = _mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[1].ae_le.size = bufsize;

		if (ictx->isp_pipe_cfg[raw].is_hdr_on) {
			// ae se
			DMA_SETUP(ISP_BLK_ID_WDMA21);
			isp_bufpool[raw].sts_mem[0].ae_se.phy_addr = bufaddr;
			isp_bufpool[raw].sts_mem[0].ae_se.size = bufsize;
			isp_bufpool[raw].sts_mem[1].ae_se.phy_addr = _mempool_pop(bufsize);
			isp_bufpool[raw].sts_mem[1].ae_se.size = bufsize;
		}

		// rgbir
		if (ictx->isp_pipe_cfg[raw].is_rgbir_sensor) {
			for (buf_num = OFFLINE_PRE_BE_BUF_NUM; buf_num > 0; buf_num--) {
				DMA_SETUP(ISP_BLK_ID_WDMA14);
				isp_bufpool[raw].ir_le[buf_num] = bufaddr;

				if (ictx->isp_pipe_cfg[raw].is_hdr_on) {
					DMA_SETUP(ISP_BLK_ID_WDMA15);
					isp_bufpool[raw].ir_se[buf_num] = bufaddr;
				}
			}
		}

		// awb le/se share the same module
		DMA_SETUP(ISP_BLK_ID_WDMA19);
		isp_bufpool[raw].sts_mem[0].awb.phy_addr = bufaddr;
		isp_bufpool[raw].sts_mem[0].awb.size = bufsize;
		isp_bufpool[raw].sts_mem[1].awb.phy_addr = _mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[1].awb.size = bufsize;
	}

EXIT:
	_isp_preraw_be_dma_dump(ictx, raw_max);
}

void _isp_rawtop_dma_setup(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	u8 cfg_dma = false;

	//RGB path
	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_dma = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_dma = true;
	}

	if (cfg_dma) {
		if (_is_fe_be_online(ictx)) { //fe->be->dram->post
			//apply pre_be wdma24 buffer
			ispblk_dma_config(ictx, ISP_BLK_ID_RDMA5, isp_bufpool[ISP_PRERAW_A].prebe_le[0]);

			if (ictx->is_hdr_on) {
				//apply pre_be wdma25 buffer
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA6, isp_bufpool[ISP_PRERAW_A].prebe_se[0]);
			} else
				ispblk_dma_enable(ictx, ISP_BLK_ID_RDMA6, false);
		} else if (_is_be_post_online(ictx)) { //fe->dram->be->post
			ispblk_dma_enable(ictx, ISP_BLK_ID_RDMA5, 0);
			ispblk_dma_enable(ictx, ISP_BLK_ID_RDMA6, 0);
		}
	}

	_isp_rawtop_dma_dump(ictx, raw_max);
}

void _isp_rgbtop_dma_setup(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	uint64_t bufaddr = 0;
	uint32_t bufsize = 0;

	enum cvi_isp_raw raw = ISP_PRERAW_A;

	u8 cfg_dma = false;

	//RGB path
	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_dma = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_dma = true;
	}

	if (cfg_dma == false) //YUV sensor only
		goto EXIT;

	for (raw = ISP_PRERAW_A; raw < raw_max; raw++) {

		if (ictx->isp_pipe_cfg[raw].is_yuv_bypass_path) //YUV sensor
			continue;

		// lsc
		DMA_SETUP(ISP_BLK_ID_RDMA7);
		isp_bufpool[raw].lsc = bufaddr;

		// hist_edge_v
		DMA_SETUP(ISP_BLK_ID_WDMA20);
		isp_bufpool[raw].sts_mem[0].hist_edge_v.phy_addr = bufaddr;
		isp_bufpool[raw].sts_mem[0].hist_edge_v.size = bufsize;
		isp_bufpool[raw].sts_mem[1].hist_edge_v.phy_addr = _mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[1].hist_edge_v.size = bufsize;

		// awb2 post
		//DMA_SETUP(ISP_BLK_ID_WDMA22);
		isp_bufpool[raw].sts_mem[0].awb_post.phy_addr = 0;
		isp_bufpool[raw].sts_mem[0].awb_post.size = 0;
		isp_bufpool[raw].sts_mem[1].awb_post.phy_addr = 0;
		isp_bufpool[raw].sts_mem[1].awb_post.size = 0;

		// dci
		DMA_SETUP(ISP_BLK_ID_WDMA27);
		isp_bufpool[raw].sts_mem[0].dci.phy_addr = bufaddr;
		isp_bufpool[raw].sts_mem[0].dci.size = bufsize;
		isp_bufpool[raw].sts_mem[1].dci.phy_addr = _mempool_pop(bufsize);
		isp_bufpool[raw].sts_mem[1].dci.size = bufsize;

		// rgb-ir merge
		if (ictx->isp_pipe_cfg[raw].is_rgbir_sensor)
			ispblk_dma_config(ictx, ISP_BLK_ID_RDMA15, isp_bufpool[raw].ir_le[0]);

		// manr
		if (ictx->is_3dnr_on) {
			if (ictx->is_tile) {
				u32 map_size = 0;

				bufaddr = _mempool_get_addr();
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA12, bufaddr);
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_RDMA12);
				_mempool_pop(bufsize);
				isp_bufpool[raw].manr = bufaddr;
				ispblk_dma_config(ictx, ISP_BLK_ID_WDMA26, isp_bufpool[raw].manr);

				map_size += bufsize;

				ictx->is_work_on_r_tile = true;
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_RDMA12);
				isp_bufpool[raw].manr_rtile = _mempool_pop(bufsize);
				ictx->is_work_on_r_tile = false;

				map_size += bufsize;

				isp_bufpool[raw].sts_mem[0].mmap.phy_addr =
					isp_bufpool[raw].sts_mem[1].mmap.phy_addr = isp_bufpool[raw].manr;
				isp_bufpool[raw].sts_mem[0].mmap.size =
					isp_bufpool[raw].sts_mem[1].mmap.size = map_size;

			} else { //non-tile
				DMA_SETUP(ISP_BLK_ID_RDMA12);
				isp_bufpool[raw].manr = bufaddr;
				ispblk_dma_config(ictx, ISP_BLK_ID_WDMA26, isp_bufpool[raw].manr);

				isp_bufpool[raw].sts_mem[0].mmap.phy_addr =
					isp_bufpool[raw].sts_mem[1].mmap.phy_addr = bufaddr;
				isp_bufpool[raw].sts_mem[0].mmap.size =
					isp_bufpool[raw].sts_mem[1].mmap.size = bufsize;
			}

			if (_is_all_online(ictx)) {
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA8, isp_bufpool[raw].rgbmap_le[0]);
			} else {
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA10, isp_bufpool[raw].rgbmap_le[0]);
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA8, isp_bufpool[raw].rgbmap_le[1]);
			}

			if (ictx->isp_pipe_cfg[raw].is_hdr_on) {
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA11, isp_bufpool[raw].rgbmap_se[0]);
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA9, isp_bufpool[raw].rgbmap_se[1]);
			}

			if (ictx->is_tile) {
				bufaddr = _mempool_get_addr();
				ispblk_dma_config(ictx, ISP_BLK_ID_WDMA29, bufaddr);
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA29);
				_mempool_pop(bufsize);

				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA17, bufaddr);
				isp_bufpool[raw].tdnr[0] = bufaddr;

				bufaddr = _mempool_get_addr();
				ispblk_dma_config(ictx, ISP_BLK_ID_WDMA28, bufaddr);
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA28);
				_mempool_pop(bufsize);

				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA16, bufaddr);
				isp_bufpool[raw].tdnr[1] = bufaddr;

				ictx->is_work_on_r_tile = true;
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA29);
				isp_bufpool[raw].tdnr_rtile[0] = _mempool_pop(bufsize);

				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA28);
				isp_bufpool[raw].tdnr_rtile[1] = _mempool_pop(bufsize);
				ictx->is_work_on_r_tile = false;

			} else { //non-tile
				DMA_SETUP(ISP_BLK_ID_WDMA29);
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA17, bufaddr);
				isp_bufpool[raw].tdnr[0] = bufaddr;

				if (ictx->is_fbc_on)
					isp_bufpool[raw].tdnr[2] = _mempool_pop(bufsize);

				DMA_SETUP(ISP_BLK_ID_WDMA28);
				ispblk_dma_config(ictx, ISP_BLK_ID_RDMA16, bufaddr);
				isp_bufpool[raw].tdnr[1] = bufaddr;

				if (ictx->is_fbc_on)
					isp_bufpool[raw].tdnr[3] = _mempool_pop(bufsize);
			}
		}
	}

	if (cfg_dma) {
		ispblk_dma_config(ictx, ISP_BLK_ID_RDMA13, isp_bufpool[ISP_PRERAW_A].lmap_le);
		if (ictx->is_hdr_on)
			ispblk_dma_config(ictx, ISP_BLK_ID_RDMA14, isp_bufpool[ISP_PRERAW_A].lmap_se);
	}

EXIT:
	_isp_rgbtop_dma_dump(ictx, raw_max);
}

void _isp_yuvtop_dma_setup(struct isp_ctx *ictx)
{
	u8 cfg_dma = false;

	//RGB path
	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_dma = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_dma = true;
	}

	if (cfg_dma) {
		if (ictx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_scaler ||
			ictx->isp_pipe_cfg[ISP_PRERAW_B].is_offline_scaler) {
			ispblk_dma_config(ictx, ISP_BLK_ID_WDMA30, 0);
			ispblk_dma_config(ictx, ISP_BLK_ID_WDMA31, 0);

			ispblk_dma_enable(ictx, ISP_BLK_ID_WDMA30, 1);
			ispblk_dma_enable(ictx, ISP_BLK_ID_WDMA31, 1);
		} else {
			ispblk_dma_enable(ictx, ISP_BLK_ID_WDMA30, 0);
			ispblk_dma_enable(ictx, ISP_BLK_ID_WDMA31, 0);
		}
	}
}

void _vi_dma_setup(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;

	for (raw_num = ISP_PRERAW_A; raw_num < raw_max; raw_num++)
		_isp_preraw_fe_dma_setup(ictx, raw_num);

	_isp_preraw_be_dma_setup(ictx, raw_max);
	_isp_rawtop_dma_setup(ictx, raw_max);
	_isp_rgbtop_dma_setup(ictx, raw_max);
	_isp_yuvtop_dma_setup(ictx);
}

void _vi_yuv_get_dma_size(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num)
{
	uint32_t bufsize_yuyv = 0;
	uint8_t  i = 0;

	u8 total_chn = (raw_num == ISP_PRERAW_A) ?
			ctx->rawb_chnstr_num :
			ctx->total_chn_num;
	u8 chn_str = (raw_num == ISP_PRERAW_A) ? 0 : ctx->rawb_chnstr_num;

	for (; chn_str < total_chn; chn_str++) {
		u32 dma = (chn_str == ctx->rawb_chnstr_num) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7;

		for (i = 0; i < OFFLINE_YUV_BUF_NUM; i++) {
			bufsize_yuyv = ispblk_dma_yuv_bypass_config(ctx, dma, 0, raw_num);
			_mempool_pop(bufsize_yuyv);
		}
	}
}

void _vi_pre_fe_get_dma_size(struct isp_ctx *ictx, enum cvi_isp_raw  raw_num)
{
	uint32_t bufsize = 0;
	uint8_t  i = 0;

	u32 raw_le = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA6;
	u32 raw_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA1 : ISP_BLK_ID_WDMA7;
	u32 rgbmap_le = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA2 : ISP_BLK_ID_WDMA8;
	u32 rgbmap_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA4 : ISP_BLK_ID_WDMA10;
	u32 lmap_le = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA3 : ISP_BLK_ID_WDMA9;
	u32 lmap_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA5 : ISP_BLK_ID_WDMA11;

	if (ictx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //YUV sensor
		if (!ictx->isp_pipe_cfg[raw_num].is_offline_scaler) //Online mode to scaler
			_vi_yuv_get_dma_size(ictx, raw_num);

		goto EXIT;
	}

	if (_is_be_post_online(ictx)) { //fe->dram->be->post
		for (i = 0; i < OFFLINE_RAW_BUF_NUM; i++) {
			bufsize = ispblk_dma_config(ictx, raw_le, 0);
			_mempool_pop(bufsize);
		}

		if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
			for (i = 0; i < OFFLINE_RAW_BUF_NUM; i++) {
				bufsize = ispblk_dma_config(ictx, raw_se, 0);
				_mempool_pop(bufsize);
			}
		}
	}

	// rgbmap
	bufsize = ispblk_dma_buf_get_size(ictx, rgbmap_le);
	_mempool_pop(bufsize);

	if (!_is_all_online(ictx)) {
		for (i = 1; i < RGBMAP_BUF_IDX; i++)
			_mempool_pop(bufsize);
	}

	// lmap_le
	bufsize = ispblk_dma_buf_get_size(ictx, lmap_le);
	_mempool_pop(bufsize);

	if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
		// rgbmap se
		bufsize = ispblk_dma_buf_get_size(ictx, rgbmap_se);
		_mempool_pop(bufsize);

		for (i = 1; i < RGBMAP_BUF_IDX; i++)
			_mempool_pop(bufsize);

		// lmap_se
		bufsize = ispblk_dma_buf_get_size(ictx, lmap_se);
		_mempool_pop(bufsize);
	}
EXIT:
	return;
}

void _vi_pre_be_get_dma_size(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	uint32_t bufsize = 0;
	uint8_t  buf_num = 0;

	enum cvi_isp_raw raw = ISP_PRERAW_A;

	u8 cfg_dma = false;

	//RGB path
	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_dma = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_dma = true;
	}

	if (cfg_dma == false)
		goto EXIT;

	if (_is_fe_be_online(ictx)) { //fe->be->dram->post
		for (buf_num = 0; buf_num < OFFLINE_PRE_BE_BUF_NUM; buf_num++) {
			bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA24, 0);
			_mempool_pop(bufsize);
		}

		if (ictx->isp_pipe_cfg[ISP_PRERAW_A].is_hdr_on) {
			for (buf_num = 0; buf_num < OFFLINE_PRE_BE_BUF_NUM; buf_num++) {
				bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA25, 0);
				_mempool_pop(bufsize);
			}
		}
	}

	for (; raw < raw_max; raw++) {
		//Be out dma

		if (ictx->isp_pipe_cfg[raw].is_yuv_bypass_path)
			continue;

		// af
		bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA16);
		_mempool_pop(bufsize);
		_mempool_pop(bufsize);

		// gms
		bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA17);
		_mempool_pop(bufsize);
		_mempool_pop(bufsize);

		// ae le
		bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA18);
		_mempool_pop(bufsize);
		_mempool_pop(bufsize);

		if (ictx->isp_pipe_cfg[raw].is_hdr_on) {
			// ae se
			bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA21);
			_mempool_pop(bufsize);
			_mempool_pop(bufsize);
		}

		// rgbir
		if (ictx->isp_pipe_cfg[raw].is_rgbir_sensor) {
			for (buf_num = OFFLINE_PRE_BE_BUF_NUM; buf_num > 0; buf_num--) {
				bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA14, 0);
				_mempool_pop(bufsize);

				if (ictx->isp_pipe_cfg[raw].is_hdr_on) {
					bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA15, 0);
					_mempool_pop(bufsize);
				}
			}
		}

		// awb le/se share the same module
		bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA19);
		_mempool_pop(bufsize);
		_mempool_pop(bufsize);
	}
EXIT:
	return;
}

void _vi_rgbtop_get_dma_size(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	uint32_t bufsize = 0;

	enum cvi_isp_raw raw = ISP_PRERAW_A;

	u8 cfg_dma = false;

	//RGB path
	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_dma = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_dma = true;
	}

	if (cfg_dma == false) //YUV sensor only
		goto EXIT;

	for (raw = ISP_PRERAW_A; raw < raw_max; raw++) {

		if (ictx->isp_pipe_cfg[raw].is_yuv_bypass_path) //YUV sensor
			continue;

		// lsc
		bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_RDMA7, 0);
		_mempool_pop(bufsize);

		// hist_edge_v
		bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA20, 0);
		_mempool_pop(bufsize);
		_mempool_pop(bufsize);

		// dci
		bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA27, 0);
		_mempool_pop(bufsize);
		_mempool_pop(bufsize);

		// manr
		if (ictx->is_3dnr_on) {
			if (ictx->is_tile) {
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_RDMA12);
				_mempool_pop(bufsize);

				ictx->is_work_on_r_tile = true;
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_RDMA12);
				_mempool_pop(bufsize);
				ictx->is_work_on_r_tile = false;

			} else { //non-tile
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_RDMA12);
				_mempool_pop(bufsize);
			}

			if (ictx->is_tile) {
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA29);
				_mempool_pop(bufsize);

				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA28);
				_mempool_pop(bufsize);

				ictx->is_work_on_r_tile = true;
				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA29);
				_mempool_pop(bufsize);

				bufsize = ispblk_dma_buf_get_size(ictx, ISP_BLK_ID_WDMA28);
				_mempool_pop(bufsize);
				ictx->is_work_on_r_tile = false;

			} else { //non-tile
				bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA29, 0);
				_mempool_pop(bufsize);

				if (ictx->is_fbc_on)
					_mempool_pop(bufsize);

				bufsize = ispblk_dma_config(ictx, ISP_BLK_ID_WDMA28, 0);
				_mempool_pop(bufsize);

				if (ictx->is_fbc_on)
					_mempool_pop(bufsize);
			}
		}
	}
EXIT:
	return;
}

void _vi_get_dma_buf_size(struct isp_ctx *ictx, enum cvi_isp_raw raw_max)
{
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;

	for (raw_num = ISP_PRERAW_A; raw_num < raw_max; raw_num++)
		_vi_pre_fe_get_dma_size(ictx, raw_num);

	_vi_pre_be_get_dma_size(ictx, raw_max);
	_vi_rgbtop_get_dma_size(ictx, raw_max);
}

static int _isp_clk_ctrl(struct cvi_isp_vdev *vdev, u8 clk_on)
{
	int rc = 0, i = 0;

	if (clk_on) {
		for (i = 0; i < ARRAY_SIZE(vdev->isp_clk); ++i) {
			if (vdev->isp_clk[i]) {
				if (clk_prepare_enable(vdev->isp_clk[i])) {
					vip_pr(CVI_ERR, "[ERR] ISP_CLK(%s) enable fail\n",
							CLK_ISP_NAME[i]);
					rc = -EAGAIN;
				}
			} else {
				vip_pr(CVI_ERR, "[ERR] ISP_CLK(%s) is null\n", CLK_ISP_NAME[i]);
				rc = -EAGAIN;
			}
		}

		for (i = 0; i < ARRAY_SIZE(vdev->mac_clk); ++i) {
			if (vdev->mac_clk[i]) {
				if (clk_prepare_enable(vdev->mac_clk[i])) {
					vip_pr(CVI_ERR, "[ERR] MAC_CLK(%s) enable fail\n",
							CLK_MAC_NAME[i]);
					rc = -EAGAIN;
				}
			} else {
				vip_pr(CVI_ERR, "[ERR] MAC_CLK(%s) is null\n", CLK_MAC_NAME[i]);
				rc = -EAGAIN;
			}
		}
	}

	return rc;
}

static void isp_init_param(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	uint8_t i = 0;

	memset(ctx, 0, sizeof(*ctx));

	ctx->phys_regs		= isp_get_phys_reg_bases();
	ctx->sensor_bitdepth	= 12;
	ctx->cam_id		= 0;

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		ctx->rgb_color_mode[i]			= ISP_BAYER_TYPE_GB;
		ctx->isp_pipe_cfg[i].is_patgen_en	= false;
		ctx->isp_pipe_cfg[i].is_offline_preraw	= false;
		ctx->isp_pipe_cfg[i].is_yuv_bypass_path	= false;
		ctx->isp_pipe_cfg[i].max_height		= 0;
		ctx->isp_pipe_cfg[i].max_width		= 0;
		ctx->isp_pipe_cfg[i].csibdg_width	= 0;
		ctx->isp_pipe_cfg[i].csibdg_height	= 0;

		INIT_LIST_HEAD(&raw_dump_b_dq[i].rdy_queue);
		INIT_LIST_HEAD(&raw_dump_b_se_dq[i].rdy_queue);
		raw_dump_b_dq[i].num_rdy          = 0;
		raw_dump_b_dq[i].raw_num          = i;
		raw_dump_b_se_dq[i].num_rdy       = 0;
		raw_dump_b_se_dq[i].raw_num       = i;

		INIT_LIST_HEAD(&raw_dump_b_q[i].rdy_queue);
		INIT_LIST_HEAD(&raw_dump_b_se_q[i].rdy_queue);
		raw_dump_b_q[i].num_rdy          = 0;
		raw_dump_b_q[i].raw_num          = i;
		raw_dump_b_se_q[i].num_rdy       = 0;
		raw_dump_b_se_q[i].raw_num       = i;

		INIT_LIST_HEAD(&isp_snr_i2c_queue[i].list);

		INIT_LIST_HEAD(&pre_be_in_se_q[i].rdy_queue);
		pre_be_in_se_q[i].num_rdy	= 0;
	}

	INIT_LIST_HEAD(&pre_raw_num_q.list);

	INIT_LIST_HEAD(&dqbuf_q.list);

	memset(&vdev->usr_crop, 0, sizeof(vdev->usr_crop));
}

static void cvi_isp_sw_init(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct cvi_vi_ctx *pviProcCtx = NULL;
	u8 i = 0, j = 0;

	pviProcCtx = (struct cvi_vi_ctx *)(vdev->shared_mem);

	struct sched_param param = {
		.sched_priority = MAX_USER_RT_PRIO - 10,
	};

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
	timer_setup(&usr_pic_timer.t, legacy_timer_emu_func, 0);
#else
	init_timer(&usr_pic_timer);
#endif

	vdev->postraw_proc_num	= 0;
	ctx->is_offline_be	= false;
	ctx->is_offline_postraw	= true;
	ctx->is_3dnr_on		= true;
	ctx->is_tile		= false;
	ctx->is_dpcm_on		= false;
	ctx->is_work_on_r_tile	= false;
	ctx->is_hdr_on		= false;
	ctx->is_dual_sensor	= false;
	ctx->is_yuv_sensor	= false;
	ctx->is_sublvds_path	= false;
	ctx->is_fbc_on		= false;
	ctx->is_rgbir_sensor	= false;
	ctx->is_ctrl_inited	= false;
	ctx->sensor_bitdepth	= 12;
	ctx->rgbmap_prebuf_idx	= 1;
	ctx->cam_id		= 0;
	ctx->rawb_chnstr_num	= 1;
	ctx->total_chn_num	= 0;
	vdev->usr_pic_delay	= 0;
	vdev->usr_pic_phy_addr	= 0;
	vdev->isp_source	= CVI_ISP_SOURCE_DEV;

	if (pviProcCtx->vi_stt != VI_SUSPEND)
		memset(vdev->snr_info, 0, sizeof(struct cvi_isp_snr_info) * ISP_PRERAW_MAX);

	memset(&isp_mempool, 0, sizeof(isp_mempool));

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		for (j = 0; j < ISP_BE_CHN_MAX; j++) {
			vdev->pre_be_frm_num[i][j]		= 0;
			vdev->pre_be_awb_frm_num[i][j]		= 0;
		}
		vdev->preraw_first_frm[i]			= true;
		vdev->postraw_frame_number[i]			= 0;
		vdev->isp_int_flag[i]				= false;
		vdev->ctx.mmap_grid_size[i]			= 3;

		memset(&ctx->isp_pipe_cfg[i], 0, sizeof(struct _isp_cfg));

		ctx->isp_pipe_cfg[i].is_offline_scaler		= true;

		for (j = 0; j < ISP_FE_CHN_MAX; j++) {
			vdev->pre_fe_sof_cnt[i][j]		= 0;
			vdev->pre_fe_frm_num[i][j]		= 0;

			atomic_set(&vdev->pre_fe_state[i][j], ISP_PRERAW_IDLE);
		}

		spin_lock_init(&snr_node_lock[i]);

		atomic_set(&vdev->isp_raw_dump_en[i], 0);
	}

	for (i = 0; i < ISP_CHN_MAX; i++) {
		INIT_LIST_HEAD(&pre_out_queue[i].rdy_queue);
		INIT_LIST_HEAD(&pre_out_se_queue[i].rdy_queue);
		pre_out_queue[i].num_rdy       = 0;
		pre_out_queue[i].raw_num       = 0;
		pre_out_se_queue[i].num_rdy    = 0;
		pre_out_se_queue[i].raw_num    = 0;
	}

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		INIT_LIST_HEAD(&raw_dump_b_dq[i].rdy_queue);
		INIT_LIST_HEAD(&raw_dump_b_se_dq[i].rdy_queue);
		raw_dump_b_dq[i].num_rdy          = 0;
		raw_dump_b_dq[i].raw_num          = i;
		raw_dump_b_se_dq[i].num_rdy       = 0;
		raw_dump_b_se_dq[i].raw_num       = i;

		INIT_LIST_HEAD(&raw_dump_b_q[i].rdy_queue);
		INIT_LIST_HEAD(&raw_dump_b_se_q[i].rdy_queue);
		raw_dump_b_q[i].num_rdy          = 0;
		raw_dump_b_q[i].raw_num          = i;
		raw_dump_b_se_q[i].num_rdy       = 0;
		raw_dump_b_se_q[i].raw_num       = i;

		INIT_LIST_HEAD(&isp_snr_i2c_queue[i].list);

		INIT_LIST_HEAD(&pre_be_in_se_q[i].rdy_queue);
		pre_be_in_se_q[i].num_rdy	= 0;
	}

	INIT_LIST_HEAD(&pre_raw_num_q.list);
	INIT_LIST_HEAD(&dqbuf_q.list);

	INIT_LIST_HEAD(&pre_be_in_q.rdy_queue);
	INIT_LIST_HEAD(&pre_be_out_q.rdy_queue);
	INIT_LIST_HEAD(&pre_be_out_se_q.rdy_queue);
	pre_be_in_q.num_rdy	= 0;
	pre_be_out_q.num_rdy	= 0;
	pre_be_out_se_q.num_rdy	= 0;

	INIT_LIST_HEAD(&post_in_queue.rdy_queue);
	INIT_LIST_HEAD(&post_in_se_queue.rdy_queue);
	post_in_queue.num_rdy	 = 0;
	post_in_se_queue.num_rdy = 0;

	atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRERAW_IDLE);
	atomic_set(&vdev->pre_be_state[ISP_BE_CH1], ISP_PRERAW_IDLE);
	atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
	atomic_set(&vdev->isp_streamoff, 0);
	atomic_set(&vdev->isp_err_handle_flag, 0);
	atomic_set(&vdev->ol_sc_frm_done, 1);
	atomic_set(&isp_pre_exit, 0);

	if (isp_pre_th == NULL) {
		isp_pre_th = kthread_create(_isp_preraw_thread, (void *)vdev, "cvitask_isp_pre");
		if (IS_ERR(isp_pre_th)) {
			pr_err("Unable to start isp_preraw_thread.\n");
		}

		sched_setscheduler(isp_pre_th, SCHED_FIFO, &param);

		vdev->isp_pre_int_flag = 0;
		init_waitqueue_head(&vdev->isp_pre_wait_q);
		wake_up_process(isp_pre_th);
	}

	if (isp_err_handler_th == NULL) {
		isp_err_handler_th = kthread_create(_isp_err_handler_thread, (void *)vdev, "cvitask_isp_err");
		if (IS_ERR(isp_err_handler_th)) {
			pr_err("Unable to start isp_err_handler_thread.\n");
		}

		sched_setscheduler(isp_err_handler_th, SCHED_FIFO, &param);

		vdev->isp_err_int_flag = 0;
		init_waitqueue_head(&vdev->isp_err_wait_q);
		wake_up_process(isp_err_handler_th);
	}

	init_waitqueue_head(&vdev->isp_dq_wait_q);

	spin_lock_init(&buf_lock);
	spin_lock_init(&raw_num_lock);
	spin_lock_init(&dq_lock);
	spin_lock_init(&vdev->qbuf_lock);
}

static enum ISP_BAYER_TYPE _mbus_remap(__u32 code)
{
	switch (code) {
	case MEDIA_BUS_FMT_SBGGR8_1X8:
	case MEDIA_BUS_FMT_SBGGR10_1X10:
	case MEDIA_BUS_FMT_SBGGR12_1X12:
		return ISP_BAYER_TYPE_BG;
	case MEDIA_BUS_FMT_SGBRG8_1X8:
	case MEDIA_BUS_FMT_SGBRG10_1X10:
	case MEDIA_BUS_FMT_SGBRG12_1X12:
		return ISP_BAYER_TYPE_GB;
	case MEDIA_BUS_FMT_SGRBG8_1X8:
	case MEDIA_BUS_FMT_SGRBG10_1X10:
	case MEDIA_BUS_FMT_SGRBG12_1X12:
		return ISP_BAYER_TYPE_GR;
	case MEDIA_BUS_FMT_SRGGB8_1X8:
	case MEDIA_BUS_FMT_SRGGB10_1X10:
	case MEDIA_BUS_FMT_SRGGB12_1X12:
		return ISP_BAYER_TYPE_RG;

	case MEDIA_BUS_FMT_CVI_BAYER_GRGBI_1x12:
		return ISP_BAYER_TYPE_GRGBI;
	case MEDIA_BUS_FMT_CVI_BAYER_RGBGI_1x12:
		return ISP_BAYER_TYPE_RGBGI;
	case MEDIA_BUS_FMT_CVI_BAYER_GBGRI_1x12:
		return ISP_BAYER_TYPE_GBGRI;
	case MEDIA_BUS_FMT_CVI_BAYER_BGRGI_1x12:
		return ISP_BAYER_TYPE_BGRGI;
	case MEDIA_BUS_FMT_CVI_BAYER_IGRGB_1x12:
		return ISP_BAYER_TYPE_IGRGB;
	case MEDIA_BUS_FMT_CVI_BAYER_IRGBG_1x12:
		return ISP_BAYER_TYPE_IRGBG;
	case MEDIA_BUS_FMT_CVI_BAYER_IBGRG_1x12:
		return ISP_BAYER_TYPE_IBGRG;
	case MEDIA_BUS_FMT_CVI_BAYER_IGBGR_1x12:
		return ISP_BAYER_TYPE_IGBGR;
	}

	return ISP_BAYER_TYPE_GB;
}

void _isp_tile_cal_size(struct isp_ctx *ictx)
{
	const int guard = 0x40;
	//384 alignment
	u32 left_width = (((ictx->img_width >> 1) % 384) != 0) ?
				((ictx->img_width >> 1) / 384 + 1) * 384 :
				((ictx->img_width >> 1) / 384) * 384;

	ictx->tile_cfg.l_in.start  = 0;
	ictx->tile_cfg.l_in.end    = left_width + guard - 1 + guard;
	ictx->tile_cfg.l_out.start = 0;
	ictx->tile_cfg.l_out.end   = left_width + guard - 1;
	ictx->tile_cfg.r_in.start  = left_width;
	ictx->tile_cfg.r_in.end    = ictx->img_width - 1;
	ictx->tile_cfg.r_out.start = left_width + guard;
	ictx->tile_cfg.r_out.end   = ictx->img_width - 1;

	vip_pr(CVI_WARN, "tile cfg: Left in(%d %d) out(%d %d)\n",
		ictx->tile_cfg.l_in.start, ictx->tile_cfg.l_in.end,
		ictx->tile_cfg.l_out.start, ictx->tile_cfg.l_out.end);
	vip_pr(CVI_WARN, "tile cfg: Right in(%d %d) out(%d %d)\n",
		ictx->tile_cfg.r_in.start, ictx->tile_cfg.r_in.end,
		ictx->tile_cfg.r_out.start, ictx->tile_cfg.r_out.end);
}

static void _isp_rawtop_tile_up(struct cvi_isp_vdev *vdev, enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u64 dma_addr = 0;
	u8 i = 0, hdr_num = 1;

	ispblk_rawtop_tile(ctx);
	ispblk_bnr_tile(ctx);

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
		hdr_num += 1;

	for (i = 0; i < hdr_num; i++) {
		u32 dmaid = (i == 0) ? ISP_BLK_ID_RDMA5 : ISP_BLK_ID_RDMA6;

		if (!ctx->is_work_on_r_tile) { //left tile
			ispblk_dma_config(ctx, dmaid, 0);
		} else { //right tile
			dma_addr = ispblk_dma_getaddr(ctx, dmaid);

			if (!ctx->is_dpcm_on) //non dpcm
				dma_addr += (ctx->tile_cfg.r_in.start * 3) / 2;
			else //dpcm
				dma_addr += (ctx->tile_cfg.r_in.start * 3) / 4;

			ispblk_dma_config(ctx, dmaid, dma_addr);
		}
	}
}

static void _isp_rgbtop_tile_up(struct cvi_isp_vdev *vdev, enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;

	ispblk_rgbtop_tile(ctx);

	ispblk_lsc_tile(ctx);

	ispblk_hist_edge_v_tile(ctx);

	ispblk_ltm_tile(ctx, raw_num);

	ispblk_dhz_tile(ctx);

	ispblk_dci_tile(ctx);

	if (ctx->is_3dnr_on) {
		u32 dmaid = ISP_BLK_ID_RDMA8;
		u8 i = 0;

		ispblk_manr_tile(ctx, raw_num);

		if (!ctx->is_work_on_r_tile) { //Left tile

			for (i = 0; i < 4; i++, dmaid++)
				ispblk_dma_config(ctx, dmaid, 0);

			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA12, isp_bufpool[raw_num].manr);
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA26, isp_bufpool[raw_num].manr);
		} else { //Right tile
			u64 dma_addr = 0;

			for (i = 0; i < 4; i++, dmaid++) {
				u8 w_bit = ctx->isp_pipe_cfg[raw_num].rgbmap_i.w_bit;

				dma_addr = ispblk_dma_getaddr(ctx, dmaid);
				dma_addr += ((UPPER(ctx->tile_cfg.r_in.start, w_bit) * 48 + 127) >> 7) << 4;

				ispblk_dma_config(ctx, dmaid, dma_addr);
			}

			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA12, isp_bufpool[raw_num].manr_rtile);
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA26, isp_bufpool[raw_num].manr_rtile);
		}
	}
}

static void _isp_yuvtop_tile_up(struct cvi_isp_vdev *vdev, enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u64 dma_addr = 0;
	u32 fbc_frm_num = vdev->postraw_frame_number[raw_num] % 2;
	u64 r_uv_addr = 0, r_y_addr = 0;
	u64 w_uv_addr = 0, w_y_addr = 0;
	u8 i = 0;

	ispblk_yuvtop_tile(ctx);

	//Update 3dnr dma setting
	if (ctx->is_3dnr_on) {

		if (ctx->is_fbc_on)
			ispblk_fbce_tile(ctx);

		if (ctx->is_work_on_r_tile) { //Right tile
			if (ctx->is_fbc_on) {
				w_uv_addr = (fbc_frm_num == 0) ?
					isp_bufpool[raw_num].tdnr_rtile[0] : isp_bufpool[raw_num].tdnr_rtile[2];
				w_y_addr = (fbc_frm_num == 0) ?
					isp_bufpool[raw_num].tdnr_rtile[1] : isp_bufpool[raw_num].tdnr_rtile[3];
				r_uv_addr = (fbc_frm_num == 1) ?
					isp_bufpool[raw_num].tdnr_rtile[0] : isp_bufpool[raw_num].tdnr_rtile[2];
				r_y_addr = (fbc_frm_num == 1) ?
					isp_bufpool[raw_num].tdnr_rtile[1] : isp_bufpool[raw_num].tdnr_rtile[3];
			} else {
				w_uv_addr = r_uv_addr = isp_bufpool[raw_num].tdnr_rtile[0];
				w_y_addr  = r_y_addr  = isp_bufpool[raw_num].tdnr_rtile[1];
			}

			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA17, r_uv_addr);
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA29, w_uv_addr);
			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA16, r_y_addr);
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA28, w_y_addr);
		} else { //Left tile
			if (ctx->is_fbc_on) {
				w_uv_addr = (fbc_frm_num == 0) ?
						isp_bufpool[raw_num].tdnr[0] : isp_bufpool[raw_num].tdnr[2];
				w_y_addr = (fbc_frm_num == 0) ?
						isp_bufpool[raw_num].tdnr[1] : isp_bufpool[raw_num].tdnr[3];
				r_uv_addr = (fbc_frm_num == 1) ?
						isp_bufpool[raw_num].tdnr[0] : isp_bufpool[raw_num].tdnr[2];
				r_y_addr = (fbc_frm_num == 1) ?
						isp_bufpool[raw_num].tdnr[1] : isp_bufpool[raw_num].tdnr[3];
			} else {
				w_uv_addr = r_uv_addr = isp_bufpool[raw_num].tdnr[0];
				w_y_addr  = r_y_addr  = isp_bufpool[raw_num].tdnr[1];
			}

			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA17, r_uv_addr);
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA29, w_uv_addr);
			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA16, r_y_addr);
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA28, w_y_addr);
		}
	}

	for (i = 0; i < 2; i++) {
		u32 dmaid = (i == 0) ? ISP_BLK_ID_WDMA30 : ISP_BLK_ID_WDMA31;

		if (!ctx->is_work_on_r_tile) { //left tile
			ispblk_dma_config(ctx, dmaid, 0);
		} else { //right tile
			dma_addr = ispblk_dma_getaddr(ctx, dmaid);

			dma_addr += ctx->tile_cfg.r_out.start;

			ispblk_dma_config(ctx, dmaid, dma_addr);
		}
	}
}

static void _isp_left_tile(struct cvi_isp_vdev *vdev, enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ictx = &vdev->ctx;
	struct vip_rect crop;

	vip_pr(CVI_DBG, "Left_tile\n");

	ictx->is_work_on_r_tile = false;
	ictx->img_width = ictx->tile_cfg.l_in.end - ictx->tile_cfg.l_in.start + 1;

	// output crop
	memset(&crop, 0, sizeof(crop));
	crop.h = ictx->img_height;
	if (!ictx->isp_pipe_cfg[raw_num].is_offline_scaler)
		crop.w = ictx->img_width;
	else
		crop.w = ictx->tile_cfg.l_out.end - ictx->tile_cfg.l_out.start + 1;
	ispblk_crop_config(ictx, ISP_BLK_ID_CROP8, crop);
	crop.w >>= 1;
	if (ictx->isp_pipe_cfg[raw_num].is_offline_scaler) {//offline to sc
		crop.h >>= 1;
	}
	ispblk_crop_config(ictx, ISP_BLK_ID_CROP9, crop);

	_isp_rawtop_tile_up(vdev, raw_num);
	_isp_rgbtop_tile_up(vdev, raw_num);
	_isp_yuvtop_tile_up(vdev, raw_num);
}

static void _isp_right_tile(struct cvi_isp_vdev *vdev, enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ictx = &vdev->ctx;
	struct vip_rect crop;

	vip_pr(CVI_DBG, "Right_tile\n");

	ictx->is_work_on_r_tile = true;
	ictx->img_width = ictx->tile_cfg.r_in.end - ictx->tile_cfg.r_in.start + 1;

	// for output
	memset(&crop, 0, sizeof(crop));
	crop.h = ictx->img_height;
	if (!ictx->isp_pipe_cfg[raw_num].is_offline_scaler) {
		crop.x = 0;
		crop.w = ictx->img_width;
	} else {
		crop.x = ictx->tile_cfg.r_out.start - ictx->tile_cfg.r_in.start;
		crop.w = ictx->tile_cfg.r_out.end - ictx->tile_cfg.r_out.start + 1;
	}
	ispblk_crop_config(ictx, ISP_BLK_ID_CROP8, crop);
	crop.x >>= 1;
	crop.w >>= 1;
	if (ictx->isp_pipe_cfg[raw_num].is_offline_scaler) {//offline to sc
		crop.y >>= 1;
		crop.h >>= 1;
	}
	ispblk_crop_config(ictx, ISP_BLK_ID_CROP9, crop);

	_isp_rawtop_tile_up(vdev, raw_num);
	_isp_rgbtop_tile_up(vdev, raw_num);
	_isp_yuvtop_tile_up(vdev, raw_num);
}

static void _vi_preraw_be_init(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ictx = &vdev->ctx;
	union REG_ISP_DPC_2 dpc_reg2;
	uint32_t bps[40] = {((0 << 12) | 0), ((0 << 12) | 20)};
	u8 cfg_be = false;

	if (!ictx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_be = true;
	} else if (ictx->is_dual_sensor && !ictx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_be = true;
	}

	if (cfg_be) { //RGB sensor
		// preraw_be_top
		ispblk_preraw_be_config(ictx);

		//ispblk_blc_set_offset(ictx, ISP_BLC_ID_BE_LE, 511, 511, 511, 511);
		ispblk_blc_set_gain(ictx, ISP_BLC_ID_BE_LE, 0x40f, 0x419, 0x419, 0x405);
		//ispblk_blc_set_2ndoffset(ictx, ISP_BLC_ID_BE_LE, 511, 511, 511, 511);
		//ispblk_blc_enable(ictx, ISP_BLC_ID_BE_LE, true, false);

		ispblk_wbg_config(ictx, ISP_WBG_ID_PRE_BE_LE, 0x400, 0x400, 0x400);
		ispblk_wbg_enable(ictx, ISP_WBG_ID_PRE_BE_LE, true, false);

		//ToDo rgbir flow
		ispblk_rgbir_preproc_config(ictx, ir_preprocess_w_lut,
			preprocess_r_ir_ratio, preprocess_g_ir_ratio, preprocess_b_ir_ratio);
		ispblk_ir_proc_config(ictx, ir_preprocess_gamma);

		if (ictx->is_hdr_on) {
			ispblk_blc_set_offset(ictx, ISP_BLC_ID_BE_SE, 511, 511, 511, 511);
			ispblk_blc_set_gain(ictx, ISP_BLC_ID_BE_SE, 0x800, 0x800, 0x800, 0x800);
			ispblk_blc_set_2ndoffset(ictx, ISP_BLC_ID_BE_SE, 511, 511, 511, 511);
			//ispblk_blc_enable(ictx, ISP_BLC_ID_BE_SE, true, false);

			ispblk_wbg_config(ictx, ISP_WBG_ID_PRE_BE_SE, 0x800, 0x800, 0x800);
			ispblk_wbg_enable(ictx, ISP_WBG_ID_PRE_BE_SE, true, false);
		}

		ispblk_fpn_config(ictx, false);

		dpc_reg2.bits.DPC_ENABLE = 0;
		//dpc_reg2.bits.GE_ENABLE = 1;
		//dpc_reg2.bits.DPC_DYNAMICBPC_ENABLE = 1;
		dpc_reg2.bits.DPC_STATICBPC_ENABLE = 1;
		dpc_reg2.bits.DPC_CLUSTER_SIZE = 2;
		ispblk_dpc_set_static(ictx, ISP_RAW_PATH_LE, 0, bps, 2);
		//ispblk_dpc_config(ictx, ISP_RAW_PATH_LE, dpc_reg2);

		if (ictx->is_hdr_on)
			ispblk_dpc_config(ictx, ISP_RAW_PATH_SE, dpc_reg2);
		else {
			dpc_reg2.bits.DPC_ENABLE = 0;
			dpc_reg2.bits.GE_ENABLE = 0;
			dpc_reg2.bits.DPC_DYNAMICBPC_ENABLE = 0;
			dpc_reg2.bits.DPC_STATICBPC_ENABLE = 0;
			ispblk_dpc_config(ictx, ISP_RAW_PATH_SE, dpc_reg2);
		}

		ispblk_lscr_set_lut(ictx, ISP_BLK_ID_LSCR4, lscr_lut, ARRAY_SIZE(lscr_lut));
		ispblk_lscr_config(ictx, ISP_BLK_ID_LSCR4, false);

		ispblk_af_config(ictx, true);
		ispblk_gms_config(ictx, true);

		ispblk_aehist_config(ictx, ISP_BLK_ID_AEHIST0, true);
		if (ictx->is_hdr_on)
			ispblk_aehist_config(ictx, ISP_BLK_ID_AEHIST1, true);

		if (_is_fe_be_online(ictx)) { //fe->be->dram->post
			if (ictx->is_hdr_on)
				ispblk_awb_config(ictx, ISP_BLK_ID_AWB0, true, ISP_AWB_SWITCH);
			else
				ispblk_awb_config(ictx, ISP_BLK_ID_AWB0, true, ISP_AWB_LE);
		} else if (_is_be_post_online(ictx) || _is_all_online(ictx)) { //fe->dram->be->post or fe->be->post
			ispblk_awb_config(ictx, ISP_BLK_ID_AWB0, true, ISP_AWB_LE);
		}
	}
}

static void _isp_rawtop_init(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ictx = &vdev->ctx;

	// raw_top
	ispblk_rawtop_config(ictx);

	ispblk_bnr_config(ictx, ISP_BNR_OUT_B_OUT, false, 0, 0);

	ispblk_cfa_config(ictx);
	ispblk_rgbcac_config(ictx, true);
}

static void _isp_rgbtop_init(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ictx = &vdev->ctx;

	ispblk_rgbtop_config(ictx);

	ispblk_lsc_config(ictx, false);

	ispblk_hist_edge_v_config(ictx, true);

	//ispblk_awb_config(ictx, ISP_BLK_ID_AWB2, true, ISP_AWB_LE);

	//ispblk_ccm_config(ictx, ISP_BLK_ID_CCM4, true, &ccm_hw_cfg);
	//ispblk_ccm_config(ictx, ISP_BLK_ID_CCM0, true, &ccm_hw_cfg);
	//ispblk_ccm_config(ictx, ISP_BLK_ID_CCM1, true, &ccm_hw_cfg);
	ispblk_dhz_config(ictx, false);
	ispblk_gamma_config(ictx, 0, gamma_data);
	ispblk_gamma_enable(ictx, false);
	//ispblk_clut_config(ictx, false, c_lut_r_lut, c_lut_g_lut, c_lut_b_lut);
	//ispblk_rgbdither_config(ictx, true, true, true, true);
	ispblk_csc_config(ictx);

	ispblk_dci_config(ictx, true, dci_map_lut_50);
	ispblk_preyee_config(ictx, false);

	ispblk_ir_merge_config(ictx);

	ispblk_manr_config(ictx, ictx->is_3dnr_on);

	ispblk_cacp_config(ictx, false);

	if (ictx->is_hdr_on) {
		ispblk_fusion_config(ictx, true, true, ISP_FS_OUT_FS);

		ispblk_ltm_b_lut(ictx, 0, ltm_b_lut);
		ispblk_ltm_d_lut(ictx, 0, ltm_d_lut);
		ispblk_ltm_g_lut(ictx, 0, ltm_g_lut);
		ispblk_ltm_config(ictx, true, false, true, false);
		ispblk_ltm_enable(ictx, true);
	} else {
		ispblk_fusion_config(ictx, false, false, ISP_FS_OUT_LONG);
		ispblk_ltm_config(ictx, false, false, false, false);
		ispblk_ltm_enable(ictx, false);
	}
}

static void _isp_yuvtop_init(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ictx = &vdev->ctx;

	ispblk_yuvtop_config(ictx);

	if (ictx->is_tile) {
		ispblk_yuvdither_config(ictx, 0, false, true, true, true);
		ispblk_yuvdither_config(ictx, 1, false, true, true, true);
	} else {
		//ispblk_yuvdither_config(ictx, 0, true, true, true, true);
		//ispblk_yuvdither_config(ictx, 1, true, true, true, true);
	}

	ispblk_444_422_config(ictx);
	if (ictx->is_3dnr_on && ictx->is_fbc_on) {
		ispblk_fbce_config(ictx, true);
		ispblk_fbcd_enable(ictx, true);
	} else {
		ispblk_fbce_config(ictx, false);
		ispblk_fbcd_enable(ictx, false);
	}

	ispblk_ynr_config(ictx, ISP_YNR_OUT_Y_DELAY, 16, 0);
	ispblk_cnr_config(ictx, false, false, 255);
	ispblk_ee_config(ictx, false);
	ispblk_ycur_config(ictx, 0, ycur_data);
	ispblk_ycur_enable(ictx, false, 0);
	ispblk_ca_lite_config(ictx, false);

	ispblk_crop_enable(ictx, ISP_BLK_ID_CROP8, false);
	ispblk_crop_enable(ictx, ISP_BLK_ID_CROP9, false);
}

static void _snr_i2c_update(
	const struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num,
	struct _isp_snr_i2c_node **_i2c_n,
	const u16 _i2c_num)
{
	struct _isp_snr_i2c_node *node;
	struct isp_i2c_data *i2c_data;
	unsigned long flags;
	u16 i = 0, j = 0, del_node = true;
	uint32_t dev_mask = 0;
	uint32_t cmd = burst_i2c_en ? CVI_SNS_I2C_BURST_QUEUE : CVI_SNS_I2C_WRITE;

	if (vdev->ctx.isp_pipe_cfg[raw_num].is_offline_preraw || vdev->ctx.isp_pipe_cfg[raw_num].is_patgen_en)
		return;

	for (j = 0; j < _i2c_num; j++) {
		node = _i2c_n[j];

		for (i = 0; i < node->n.regs_num; i++) {
			i2c_data = &node->n.i2c_data[i];

			if (i2c_data->update) {
				if (i2c_data->dly_frm_num == 0) {
					vip_pr(CVI_DBG, "i2c_addr=0x%x write:0x%x\n",
							i2c_data->reg_addr, i2c_data->data);
					vip_sys_cmm_cb_i2c(cmd, (void *)i2c_data);
					i2c_data->update = 0;
					if (burst_i2c_en)
						dev_mask |= BIT(i2c_data->i2c_dev);
				} else {
					vip_pr(CVI_DBG, "addr=0x%x, dly_frm=%d\n",
							i2c_data->reg_addr, i2c_data->dly_frm_num);
					i2c_data->dly_frm_num--;
					del_node = false;
				}
			}
		}

		if (del_node) {
			vip_pr(CVI_DBG, "i2c del node and free\n");
			spin_lock_irqsave(&snr_node_lock[raw_num], flags);
			list_del_init(&node->list);
			kfree(node);
			spin_unlock_irqrestore(&snr_node_lock[raw_num], flags);
		}
	}

	while (dev_mask) {
		uint32_t tmp = ffs(dev_mask) - 1;

		vip_sys_cmm_cb_i2c(CVI_SNS_I2C_BURST_FIRE, (void *)&tmp);
		dev_mask &= ~BIT(tmp);
	}
}

static void _isp_snr_cfg_deq_and_fire(
	struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num)
{
	struct list_head *pos, *temp;
	struct _isp_snr_i2c_node *i2c_n[20];
	unsigned long flags;
	u16 i2c_num = 0;

	spin_lock_irqsave(&snr_node_lock[raw_num], flags);

	list_for_each_safe(pos, temp, &isp_snr_i2c_queue[raw_num].list) {
		i2c_n[i2c_num] = list_entry(pos, struct _isp_snr_i2c_node, list);
		i2c_num++;
	}

	spin_unlock_irqrestore(&snr_node_lock[raw_num], flags);

	_snr_i2c_update(vdev, raw_num, i2c_n, i2c_num);
}


static void _usr_pic_timer_handler(unsigned long data)
{
	struct cvi_isp_vdev *vdev = (struct cvi_isp_vdev *)usr_pic_timer.data;
	struct isp_ctx *ctx = &vdev->ctx;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;

	if (!ctx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw || !vb2_is_streaming(&vdev->vb_q)) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
		mod_timer(&usr_pic_timer.t, jiffies + vdev->usr_pic_delay);
#else
		mod_timer(&usr_pic_timer, jiffies + vdev->usr_pic_delay);
#endif
		return;
	}

	if (atomic_read(&vdev->pre_fe_state[raw_num][ISP_FE_CH0]) == ISP_PRERAW_IDLE &&
		(atomic_read(&vdev->isp_streamoff) == 0)) {
		struct _isp_raw_num_n  *n;

		if (_is_fe_be_online(ctx) && ctx->isp_pipe_cfg[ISP_PRERAW_A].is_hdr_on) {
			struct isp_buffer *b = NULL;

			b = isp_next_buf(&pre_be_out_se_q);
			if (!b) {
				vip_pr(CVI_DBG, "pre_be chn_num_%d outbuf is empty\n", ISP_FE_CH1);
				return;
			}

			ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA25, b->addr);
		}

		if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 1 && _is_fe_be_online(ctx)) {//raw_dump flow
			_isp_fe_be_raw_dump_cfg(vdev, raw_num, 0);
			atomic_set(&vdev->isp_raw_dump_en[raw_num], 3);
		}

		_pre_hw_enque(vdev, raw_num, ISP_FE_CH0);

		n = kmalloc(sizeof(*n), GFP_ATOMIC);
		if (n == NULL) {
			vip_pr(CVI_ERR, "pre_raw_num_q kmalloc size(%d) fail\n", sizeof(*n));
			return;
		}
		n->raw_num = raw_num;
		pre_raw_num_enq(&pre_raw_num_q, n);

		vdev->isp_pre_int_flag = (raw_num == ISP_PRERAW_A) ? 1 : 2;
		wake_up(&vdev->isp_pre_wait_q);

		if (!_is_all_online(ctx)) //Not on the fly mode
			tasklet_hi_schedule(&vdev->job_work);

		_isp_v4l2_event_queue(vdev,
					V4L2_EVENT_CVI_VIP_PRE0_SOF,
					++vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0]);
	}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
	mod_timer(&usr_pic_timer.t, jiffies + vdev->usr_pic_delay);
#else
	mod_timer(&usr_pic_timer, jiffies + vdev->usr_pic_delay);
#endif
}

static void usr_pic_time_remove(void)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
	if (timer_pending(&usr_pic_timer.t)) {
		del_timer_sync(&usr_pic_timer.t);
		timer_setup(&usr_pic_timer.t, legacy_timer_emu_func, 0);
#else
	if (timer_pending(&usr_pic_timer)) {
		del_timer_sync(&usr_pic_timer);
		init_timer(&usr_pic_timer);
#endif
	}
}

static int __init usr_pic_timer_init(struct cvi_isp_vdev *vdev)
{
	usr_pic_time_remove();
	usr_pic_timer.function = _usr_pic_timer_handler;
	usr_pic_timer.data = (uintptr_t)vdev;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
	usr_pic_timer.t.expires = jiffies + vdev->usr_pic_delay;
	add_timer(&usr_pic_timer.t);
#else
	usr_pic_timer.expires = jiffies + vdev->usr_pic_delay;
	add_timer(&usr_pic_timer);
#endif

	return 0;
}

void _isp_fe_be_raw_dump_cfg(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 trigger = false;

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
		trigger = (vdev->pre_be_frm_num[raw_num][ISP_BE_CH0] ==
				vdev->pre_be_frm_num[raw_num][ISP_BE_CH1]);
	} else
		trigger = true;

	if (trigger) {
		struct isp_buffer *b = NULL, *b_se = NULL;
		struct isp_queue *fe_out_q = &raw_dump_b_q[raw_num];
		u32 dmaid = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA6;
		u32 dmaid_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA1 : ISP_BLK_ID_WDMA7;
		u8 en = 1;

		vip_pr(CVI_DBG, "fe_be raw_dump cfg start\n");

		b = isp_next_buf(fe_out_q);
		if (b == NULL) {
			vip_pr(CVI_ERR, "Pre_fe_%d LE raw_dump outbuf is empty\n", raw_num);
			return;
		}

		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			struct isp_queue *fe_out_q_se = &raw_dump_b_se_q[raw_num];

			b_se = isp_next_buf(fe_out_q_se);
			if (b_se == NULL) {
				vip_pr(CVI_ERR, "Pre_fe_%d SE raw_dump outbuf is empty\n", raw_num);
				return;
			}
		}

		ispblk_dma_config(ctx, dmaid, b->addr);
		ispblk_csidbg_dma_wr_en(ctx, raw_num, ISP_FE_CH0, en);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			ispblk_dma_config(ctx, dmaid_se, b_se->addr);
			ispblk_csidbg_dma_wr_en(ctx, raw_num, ISP_FE_CH1, en);
		}

		atomic_set(&vdev->isp_raw_dump_en[raw_num], 2);
	}
}

static int _isp_raw_dump(struct cvi_isp_vdev *vdev, struct cvi_vip_isp_raw_blk *dump)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct isp_buffer *b;
	int ret = 0;
	u8 raw_num = dump[0].raw_dump.raw_num;

	if (isp_byr[raw_num] != 0 || isp_byr_se[raw_num] != 0) {
		vip_pr(CVI_ERR, "Release buffer first, call put pipe dump\n");
		dump[0].is_b_not_rls = true;
		ret = -EINVAL;
		return ret;
	}

	b = vmalloc(sizeof(*b));
	memset(b, 0, sizeof(*b));
	b->addr = dump[0].raw_dump.phy_addr;
	b->raw_num = raw_num;
	vip_pr(CVI_DBG, "raw_num=%d enque raw_dump le\n", raw_num);
	isp_buf_queue(&raw_dump_b_q[b->raw_num], b);

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
		b = vmalloc(sizeof(*b));
		memset(b, 0, sizeof(*b));
		b->addr = dump[1].raw_dump.phy_addr;
		b->raw_num = raw_num;
		vip_pr(CVI_DBG, "enque raw_dump se\n");
		isp_buf_queue(&raw_dump_b_se_q[b->raw_num], b);
	}

	atomic_set(&vdev->isp_raw_dump_en[raw_num], 1);
	ret = wait_event_interruptible_timeout(
		vdev->isp_int_wait_q[raw_num], vdev->isp_int_flag[raw_num] != 0,
		msecs_to_jiffies(dump->time_out));

	vdev->isp_int_flag[raw_num] = 0;
	if (!ret) {
		vip_pr(CVI_ERR, "vi get raw timeout(%d)\n", dump[0].time_out);
		dump[0].is_timeout = true;
		isp_byr[raw_num] = isp_byr_se[raw_num] = NULL;
		ret = -ETIME;
		return ret;
	}

	if (signal_pending(current)) {
		dump[0].is_sig_int = true;
		isp_byr[raw_num] = isp_byr_se[raw_num] = NULL;
		ret = -ERESTARTSYS;
		return ret;
	}

	isp_byr[raw_num] = isp_buf_remove(&raw_dump_b_dq[raw_num]);
	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
		isp_byr_se[raw_num] = isp_buf_remove(&raw_dump_b_se_dq[raw_num]);

	dump[0].src_w		= isp_byr[raw_num]->crop_le.w;
	dump[0].src_h		= isp_byr[raw_num]->crop_le.h;
	dump[0].crop_x		= isp_byr[raw_num]->crop_le.x;
	dump[0].crop_y		= isp_byr[raw_num]->crop_le.y;

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
		if (isp_byr_se[raw_num] == NULL) {
			vip_pr(CVI_ERR, "Get raw_se dump buffer time_out(%d)\n", dump[1].time_out);
			dump[0].is_timeout = true;
			isp_byr[raw_num] = isp_byr_se[raw_num] = NULL;
			ret = -ETIME;
			return ret;
		}

		dump[1].src_w		= isp_byr_se[raw_num]->crop_se.w;
		dump[1].src_h		= isp_byr_se[raw_num]->crop_se.h;
		dump[1].crop_x		= isp_byr_se[raw_num]->crop_se.x;
		dump[1].crop_y		= isp_byr_se[raw_num]->crop_se.y;
	}

	return ret;
}


/*************************************************************************
 *	IOCTL definition
 *************************************************************************/
static int cvi_isp_querycap(struct file *file, void *priv,
			   struct v4l2_capability *cap)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct cvi_vip_dev *bdev =
		container_of(vdev, struct cvi_vip_dev, isp_vdev);

	strlcpy(cap->driver, CVI_VIP_DRV_NAME, sizeof(cap->driver));
	strlcpy(cap->card, CVI_VIP_DVC_NAME, sizeof(cap->card));
	snprintf(cap->bus_info, sizeof(cap->bus_info),
		 "platform:%s", bdev->v4l2_dev.name);

	cap->capabilities = vdev->vid_caps | V4L2_CAP_DEVICE_CAPS;
	return 0;
}

static int cvi_isp_g_ctrl(
	struct file *file,
	void *priv,
	struct v4l2_control *vc)
{
	int rc = -EINVAL;
	return rc;
}

static int cvi_isp_s_ctrl(
	struct file *file,
	void *priv,
	struct v4l2_control *vc)
{
	int rc = -EINVAL;
	return rc;
}

static int cvi_isp_g_ext_ctrls(
	struct file *file,
	void *priv,
	struct v4l2_ext_controls *vc)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct isp_ctx *ctx = &vdev->ctx;
	struct v4l2_ext_control *ext_ctrls;
	int rc = -EINVAL, i = 0;

	ext_ctrls = vc->controls;
	for (i = 0; i < vc->count; ++i) {
		switch (ext_ctrls[i].id) {
		case V4L2_CID_DV_VIP_ISP_STS_GET:
		{
			u8 raw_num;
			unsigned long flags;

			raw_num = ext_ctrls[i].value;

			if (raw_num >= ISP_PRERAW_MAX)
				break;

			spin_lock_irqsave(&isp_bufpool[raw_num].pre_be_sts_lock, flags);
			isp_bufpool[raw_num].pre_be_sts_in_use = 1;
			ext_ctrls[i].value = isp_bufpool[raw_num].pre_be_sts_busy_idx ^ 1;
			spin_unlock_irqrestore(&isp_bufpool[raw_num].pre_be_sts_lock, flags);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_POST_STS_GET:
		{
			u8 raw_num;
			unsigned long flags;

			raw_num = ext_ctrls[i].value;

			if (raw_num >= ISP_PRERAW_MAX)
				break;

			spin_lock_irqsave(&isp_bufpool[raw_num].post_sts_lock, flags);
			isp_bufpool[raw_num].post_sts_in_use = 1;
			ext_ctrls[i].value = isp_bufpool[raw_num].post_sts_busy_idx ^ 1;
			spin_unlock_irqrestore(&isp_bufpool[raw_num].post_sts_lock, flags);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_STS_MEM:
		{
			struct cvi_isp_sts_mem sts_mem;
			int rval = 0;
			u8 raw_num = 0;

			if (copy_from_user(&sts_mem, ext_ctrls[i].ptr, sizeof(struct cvi_isp_sts_mem)) != 0)
				break;

			raw_num = sts_mem.raw_num;

			rval = copy_to_user(ext_ctrls[i].ptr,
						isp_bufpool[raw_num].sts_mem,
						sizeof(struct cvi_isp_sts_mem) * 2);

			if (rval)
				vip_pr(CVI_ERR, "fail copying %d bytes of ISP_STS_MEM info\n", rval);
			else
				rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_AWB_STS_GET:
		{
			struct cvi_vip_isp_awb_sts awb_sts;
			unsigned long flags;
			u8 raw_num = 0;

			if (copy_from_user(&awb_sts, ext_ctrls[i].ptr, sizeof(struct cvi_vip_isp_awb_sts)) != 0)
				break;

			raw_num = awb_sts.raw_num;

			if (raw_num >= ISP_PRERAW_MAX)
				break;

			spin_lock_irqsave(&isp_bufpool[raw_num].awb_sts_lock, flags);
			isp_bufpool[raw_num].awb_sts_in_use = 1;
			awb_sts.is_se = ctx->isp_pipe_cfg[raw_num].is_awb_sts_se;
			awb_sts.buf_idx = isp_bufpool[raw_num].awb_sts_busy_idx ^ 1;
			spin_unlock_irqrestore(&isp_bufpool[raw_num].awb_sts_lock, flags);

			if (copy_to_user(ext_ctrls[i].ptr, &awb_sts, sizeof(struct cvi_vip_isp_awb_sts)) != 0)
				break;

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_SCENE_INFO:
		{
			enum ISP_SCENE_INFO info = FE_ON_BE_OFF_POST_ON_SC;

			if (ctx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_scaler) {
				if (_is_fe_be_online(ctx))
					info = FE_ON_BE_OFF_POST_OFF_SC;
				else if (_is_be_post_online(ctx))
					info = FE_OFF_BE_ON_POST_OFF_SC;
				else if (_is_all_online(ctx))
					info = FE_ON_BE_ON_POST_OFF_SC;
			} else {
				if (_is_fe_be_online(ctx))
					info = FE_ON_BE_OFF_POST_ON_SC;
				else if (_is_be_post_online(ctx))
					info = FE_OFF_BE_ON_POST_ON_SC;
				else if (_is_all_online(ctx))
					info = FE_ON_BE_ON_POST_ON_SC;
			}

			ext_ctrls[i].value = info;

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_BUF_SIZE:
		{
			u32 tmp_size = 0;
			enum cvi_isp_raw raw_max = ISP_PRERAW_MAX - 1;
			u8 raw_num = 0;

			tmp_size = isp_mempool.size;
			isp_mempool.size = 0x8000000;
			isp_mempool.byteused = 0;

			_vi_sence_ctrl(vdev, &raw_max);

			for (raw_num = ISP_PRERAW_A; raw_num < raw_max; raw_num++) {
				vdev->ctx.isp_pipe_cfg[raw_num].is_patgen_en = csi_patgen_en[raw_num];

				if (vdev->ctx.isp_pipe_cfg[raw_num].is_patgen_en) {
					vdev->usr_fmt.width = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_w;
					vdev->usr_fmt.height = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_h;
					vdev->usr_fmt.code = ISP_BAYER_TYPE_BG;
					vdev->usr_crop.width = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_w;
					vdev->usr_crop.height = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_h;
					vdev->usr_crop.left = 0;
					vdev->usr_crop.top = 0;

					vip_pr(CVI_WARN, "patgen enable, w_h(%d:%d), color mode(%d)\n",
							vdev->usr_fmt.width, vdev->usr_fmt.height, vdev->usr_fmt.code);
				}

				_vi_ctrl_init(raw_num, vdev);
			}

			_vi_get_dma_buf_size(ctx, raw_max);

			ext_ctrls[i].value = isp_mempool.byteused;

			isp_mempool.size	= tmp_size;
			isp_mempool.byteused	= 0;

			rc = 0;
			break;
		}

		default:
			break;
		}
	}
	return rc;
}

static int cvi_isp_s_ext_ctrls(
	struct file *file,
	void *priv,
	struct v4l2_ext_controls *vc)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct isp_ctx *ctx = &vdev->ctx;
	struct v4l2_ext_control *ext_ctrls;
	int rc = -EINVAL, i = 0;

	ext_ctrls = vc->controls;
	for (i = 0; i < vc->count; ++i) {
		switch (ext_ctrls[i].id) {
		case V4L2_CID_DV_VIP_ISP_PATTERN:
			if (ext_ctrls[i].value >= CVI_VIP_PAT_MAX) {
				vip_pr(CVI_ERR, "invalid isp-pattern(%d)\n",
					ext_ctrls[i].value);
				break;
			}
			rc = 0;
			// TODO: for isp patgen ctrl
			break;

		case V4L2_CID_DV_VIP_ISP_ONLINE:
			ctx->is_offline_postraw = !ext_ctrls[i].value;
			vip_pr(CVI_WARN, "is_offline_postraw=%d\n", ctx->is_offline_postraw);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_BE_ONLINE:
			ctx->is_offline_be = !ext_ctrls[i].value;
			vip_pr(CVI_WARN, "is_offline_be=%d\n", ctx->is_offline_be);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_HDR:
			ctx->is_hdr_on = ext_ctrls[i].value;
			//This is only for pre_fe from dram
			ctx->isp_pipe_cfg[ISP_PRERAW_A].is_hdr_on = ext_ctrls[i].value;
			vip_pr(CVI_WARN, "HDR_ON(%d)\n", ctx->is_hdr_on);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_HDR_DETAIL_EN:
		{
			u32 val = 0, snr_num = 0, enable = 0;

			val = ext_ctrls[i].value;
			snr_num = val & 0x3; //bit0~1: snr_num
			enable = val & 0x4; //bit2: enable/disable

			if (snr_num < ISP_PRERAW_MAX) {
				ctx->isp_pipe_cfg[snr_num].is_hdr_detail_en = enable;
				vip_pr(CVI_WARN, "HDR_DETAIL_EN(%d)\n",
					ctx->isp_pipe_cfg[snr_num].is_hdr_detail_en);
				rc = 0;
			}

			break;
		}

		case V4L2_CID_DV_VIP_ISP_3DNR:
			ctx->is_3dnr_on = ext_ctrls[i].value;
			vip_pr(CVI_WARN, "is_3dnr_on=%d\n", ctx->is_3dnr_on);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_TILE:
			ctx->is_tile = ext_ctrls[i].value;
			vip_pr(CVI_WARN, "TILE_ON(%d)\n", ctx->is_tile);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_COMPRESS_EN:
			ctx->is_dpcm_on = ext_ctrls[i].value;
			vip_pr(CVI_WARN, "ISP_COMPRESS_ON(%d)\n", ctx->is_dpcm_on);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_YUV_BYPASS_PATH:
		{
			struct cvi_vip_isp_yuv_param param;
			struct cvi_vi_ctx *pviProcCtx = NULL;

			pviProcCtx = (struct cvi_vi_ctx *)vdev->shared_mem;

			if (copy_from_user(&param, ext_ctrls[i].ptr, sizeof(struct cvi_vip_isp_yuv_param)) != 0)
				break;

			if ((param.raw_num < ISP_PRERAW_A) || (param.raw_num >= ISP_PRERAW_MAX)) {
				vip_pr(CVI_ERR, "invalid raw_num(%d)\n", param.raw_num);
				break;
			}

			ctx->isp_pipe_cfg[param.raw_num].is_yuv_bypass_path = param.yuv_bypass_path;
			ctx->isp_pipe_cfg[param.raw_num].infMode = pviProcCtx->devAttr[param.raw_num].enIntfMode;
			ctx->isp_pipe_cfg[param.raw_num].muxMode = pviProcCtx->devAttr[param.raw_num].enWorkMode;

			vip_pr(CVI_INFO, "%s YUV_BYPASS_PATH_ON(%d), infMode(%d), muxMode(%d)\n",
				(param.raw_num == ISP_PRERAW_A) ? "PRERAW_A" : "PRERAW_B",
				ctx->isp_pipe_cfg[param.raw_num].is_yuv_bypass_path,
				ctx->isp_pipe_cfg[param.raw_num].infMode,
				ctx->isp_pipe_cfg[param.raw_num].muxMode);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_SUBLVDS_PATH:
			ctx->is_sublvds_path = ext_ctrls[i].value;
			vip_pr(CVI_WARN, "SUBLVDS_PATH_ON(%d)\n", ctx->is_sublvds_path);
			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_BLC_CFG:
		case V4L2_CID_DV_VIP_ISP_WBG_CFG:
		case V4L2_CID_DV_VIP_ISP_CCM_CFG:
		case V4L2_CID_DV_VIP_ISP_DHZ_CFG:
			break;

		case V4L2_CID_DV_VIP_ISP_STS_PUT:
		{
			u8 raw_num = 0;
			unsigned long flags;

			raw_num = ext_ctrls[i].value;

			if (raw_num >= ISP_PRERAW_MAX)
				break;

			spin_lock_irqsave(&isp_bufpool[raw_num].pre_be_sts_lock, flags);
			isp_bufpool[raw_num].pre_be_sts_in_use = 0;
			spin_unlock_irqrestore(&isp_bufpool[raw_num].pre_be_sts_lock, flags);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_POST_STS_PUT:
		{
			u8 raw_num = 0;
			unsigned long flags;

			raw_num = ext_ctrls[i].value;

			if (raw_num >= ISP_PRERAW_MAX)
				break;

			spin_lock_irqsave(&isp_bufpool[raw_num].post_sts_lock, flags);
			isp_bufpool[raw_num].post_sts_in_use = 0;
			spin_unlock_irqrestore(&isp_bufpool[raw_num].post_sts_lock, flags);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GE_CFG:
		case V4L2_CID_DV_VIP_ISP_GAMMA_CFG:
		case V4L2_CID_DV_VIP_ISP_EE_CFG:
			break;

		case V4L2_CID_DV_VIP_ISP_USR_PIC_CFG:
		{
			struct cvi_isp_usr_pic_cfg *cfg;

			cfg = (struct cvi_isp_usr_pic_cfg *)ext_ctrls[i].ptr;
			if ((cfg->crop.width < 32) || (cfg->crop.width > 4096)
			    || (cfg->crop.left > cfg->crop.width) || (cfg->crop.top > cfg->crop.height)) {
				vip_pr(CVI_ERR, "USR_PIC_CFG:(Invalid Param) w(%d) h(%d) x(%d) y(%d)",
					cfg->crop.width, cfg->crop.height, cfg->crop.left, cfg->crop.top);
			} else {
				vdev->usr_fmt = cfg->fmt;
				vdev->usr_crop = cfg->crop;

				vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].csibdg_width	= vdev->usr_fmt.width;
				vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].csibdg_height	= vdev->usr_fmt.height;
				vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].max_width		= vdev->usr_fmt.width;
				vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].max_height		= vdev->usr_fmt.height;

				ispblk_csibdg_update_size(&vdev->ctx, ISP_PRERAW_A);

				rc = 0;
			}

			break;
		}

		case V4L2_CID_DV_VIP_ISP_USR_PIC_ONOFF:
		{
			vdev->isp_source = ext_ctrls[i].value;
			ctx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw =
				(vdev->isp_source == CVI_ISP_SOURCE_FE);
			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_PIPE_DUMP:
		{
			struct cvi_vip_isp_raw_blk dump[2];

			if (copy_from_user(&dump[0], ext_ctrls[i].ptr, sizeof(struct cvi_vip_isp_raw_blk) * 2) != 0)
				break;

			rc = _isp_raw_dump(vdev, &dump[0]);

			if (copy_to_user(ext_ctrls[i].ptr, &dump[0], sizeof(struct cvi_vip_isp_raw_blk) * 2) != 0)
				break;

			break;
		}

		case V4L2_CID_DV_VIP_ISP_PUT_PIPE_DUMP:
		{
			u32 raw_num = 0;

			raw_num = ext_ctrls[i].value;
			isp_byr[raw_num] = isp_byr_se[raw_num] = NULL;

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_USR_PIC_PUT:
		{
			if (ctx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw) {
#if 1
				ispblk_dma_config(ctx, ISP_BLK_ID_RDMA0, ext_ctrls[i].value64);
				vdev->usr_pic_phy_addr = ext_ctrls[i].value64;
				rc = 0;
#else //for vip_FPGA test
				uint64_t bufaddr = 0;
				uint32_t bufsize = 0;

				bufaddr = _mempool_get_addr();
				bufsize = ispblk_dma_config(ctx, ISP_BLK_ID_RDMA0, bufaddr);
				_mempool_pop(bufsize);

				vip_pr(CVI_WARN, "\nRDMA0 base_addr=0x%x\n", bufaddr);

				vdev->usr_pic_phy_addr = bufaddr;
				rc = 0;
#endif
			}
			break;
		}

		case V4L2_CID_DV_VIP_ISP_USR_PIC_TIMING:
		{
			if (ext_ctrls[i].value > 30)
				vdev->usr_pic_delay = msecs_to_jiffies(33);
			else if (ext_ctrls[i].value > 0)
				vdev->usr_pic_delay = msecs_to_jiffies(1000 / ext_ctrls[i].value);
			else
				vdev->usr_pic_delay = 0;

			if (vdev->usr_pic_delay)
				usr_pic_timer_init(vdev);
			else
				usr_pic_time_remove();

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_LSC_PHY_BUF:
		{
			struct cvi_vip_memblock *isp_mem;

			isp_mem = vmalloc(sizeof(struct cvi_vip_memblock));
			if (copy_from_user(isp_mem, ext_ctrls[i].ptr, sizeof(struct cvi_vip_memblock)) != 0) {
				vfree(isp_mem);
				break;
			}

			isp_mem->phy_addr = isp_bufpool[isp_mem->raw_num].lsc;
			isp_mem->size = ispblk_dma_config(ctx, ISP_BLK_ID_RDMA7, 0);

			if (copy_to_user(ext_ctrls[i].ptr, isp_mem, sizeof(struct cvi_vip_memblock)) != 0) {
				vfree(isp_mem);
				break;
			}

			vfree(isp_mem);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_TUN_ADDR:
		{
			if (copy_to_user(ext_ctrls[i].ptr, &tuning_buf_addr, sizeof(struct isp_tuning_cfg)) != 0)
				break;

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_BNR_CFG:
		case V4L2_CID_DV_VIP_ISP_CNR_CFG:
		case V4L2_CID_DV_VIP_ISP_YNR_CFG:
		case V4L2_CID_DV_VIP_ISP_PFC_CFG:
		case V4L2_CID_DV_VIP_ISP_TNR_CFG:
		case V4L2_CID_DV_VIP_ISP_DCI_CFG:
		case V4L2_CID_DV_VIP_ISP_DEMOSIAC_CFG:
		case V4L2_CID_DV_VIP_ISP_3DLUT_CFG:
		case V4L2_CID_DV_VIP_ISP_DPC_CFG:
		case V4L2_CID_DV_VIP_ISP_LSC_CFG:
		case V4L2_CID_DV_VIP_ISP_LSCR_CFG:
			break;

		case V4L2_CID_DV_VIP_ISP_AE_CFG:
		{
			struct cvi_vip_isp_ae_config ae_cfg;

			if (copy_from_user(&ae_cfg, ext_ctrls[i].ptr, sizeof(struct cvi_vip_isp_ae_config)) != 0)
				break;
#ifndef FPGA_EARLY_PORTING
			ispblk_ae_tun_cfg(ctx, &ae_cfg);
#endif
			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_AWB_CFG:
		{
			struct cvi_vip_isp_awb_config awb_cfg;

			if (copy_from_user(&awb_cfg, ext_ctrls[i].ptr, sizeof(struct cvi_vip_isp_awb_config)) != 0)
				break;
#ifndef FPGA_EARLY_PORTING
			ispblk_awb_tun_cfg(ctx, &awb_cfg);
#endif
			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_AF_CFG:
		{
			struct cvi_vip_isp_af_config af_cfg;

			if (copy_from_user(&af_cfg, ext_ctrls[i].ptr, sizeof(struct cvi_vip_isp_af_config)) != 0)
				break;
#ifndef FPGA_EARLY_PORTING
			ispblk_af_tun_cfg(ctx, &af_cfg);
#endif
			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_FSWDR_CFG:
		case V4L2_CID_DV_VIP_ISP_DRC_CFG:
		case V4L2_CID_DV_VIP_ISP_MONO_CFG:
			break;

		case V4L2_CID_DV_VIP_ISP_SET_SNR_INFO:
		{
			struct cvi_isp_snr_info snr_info;

			if (copy_from_user(&snr_info, ext_ctrls[i].ptr, sizeof(struct cvi_isp_snr_info)) != 0)
				break;
			memcpy(&vdev->snr_info[snr_info.raw_num], &snr_info, sizeof(struct cvi_isp_snr_info));

			if (snr_info.raw_num == ISP_PRERAW_B)
				viproc_en[1] = 1;

			vip_pr(CVI_WARN, "raw_num=%d, color_mode=%d, frm_num=%d, w:h=%d:%d\n",
				snr_info.raw_num,
				vdev->snr_info[snr_info.raw_num].color_mode,
				vdev->snr_info[snr_info.raw_num].snr_fmt.frm_num,
				vdev->snr_info[snr_info.raw_num].snr_fmt.img_size[0].active_w,
				vdev->snr_info[snr_info.raw_num].snr_fmt.img_size[0].active_h);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_SET_SNR_CFG_NODE:
		{
			struct cvi_isp_snr_update *snr_update;
			u8                        raw_num;

			if (vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw)
				break;

			snr_update = vmalloc(sizeof(struct cvi_isp_snr_update));
			if (copy_from_user(snr_update, ext_ctrls[i].ptr, sizeof(struct cvi_isp_snr_update)) != 0) {
				vip_pr(CVI_ERR, "SNR_CFG_NODE copy from user fail.\n");
				vfree(snr_update);
				break;
			}
			raw_num = snr_update->raw_num;

			if (raw_num >= ISP_PRERAW_MAX) {
				vfree(snr_update);
				break;
			}

			if (vdev->ctx.isp_pipe_cfg[raw_num].is_offline_preraw ||
				vdev->ctx.isp_pipe_cfg[raw_num].is_patgen_en) {
				rc = 0;
				vfree(snr_update);
				break;
			}

			vip_pr(CVI_DBG, "raw=%d, SNR_CFG_NODE regs_num=%d, i2c_update=%d, isp_update=%d\n",
				raw_num,
				snr_update->snr_cfg_node.snsr.regs_num,
				snr_update->snr_cfg_node.snsr.need_update,
				snr_update->snr_cfg_node.isp.need_update);

			_isp_snr_cfg_enq(snr_update, raw_num);

			vfree(snr_update);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_SET_RGBMAP_IDX:
		{
			vip_pr(CVI_DBG, "No support set_rgbmap_idx\n");
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_IP_INFO:
		{
			if (copy_to_user(ext_ctrls[i].ptr, &ip_info_list,
						sizeof(struct ip_info) * IP_INFO_ID_MAX) != 0)
				break;

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_TRIG_PRERAW:
		{
			enum cvi_isp_raw raw_num;

			raw_num = (ext_ctrls[i].value == 0) ? ISP_PRERAW_A : ISP_PRERAW_B;
			isp_pre_trig(ctx, raw_num, ISP_FE_CH0);
			if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
				isp_pre_trig(ctx, raw_num, ISP_FE_CH1);

			vip_pr(CVI_WARN, "TRIG_PRERAW(%d)\n", raw_num);
			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_SC_ONLINE:
		{
			//Currently both sensor are needed to be online or offline at same time.
			ctx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_scaler = !ext_ctrls[i].value;
			ctx->isp_pipe_cfg[ISP_PRERAW_B].is_offline_scaler = !ext_ctrls[i].value;
			vip_pr(CVI_WARN, "set is_offline_scaler:%d\n", !ext_ctrls[i].value);
			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_MMAP_GRID_SIZE:
		{
			struct cvi_isp_mmap_grid_size m_gd_sz;

			if (copy_from_user(&m_gd_sz, ext_ctrls[i].ptr, sizeof(struct cvi_isp_mmap_grid_size)) != 0)
				break;

			m_gd_sz.grid_size = ctx->mmap_grid_size[m_gd_sz.raw_num];

			if (copy_to_user(ext_ctrls[i].ptr, &m_gd_sz, sizeof(struct cvi_isp_mmap_grid_size)) != 0)
				break;

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_SET_PROC_CONTENT:
		{
			struct isp_proc_cfg proc_cfg;
			int rval = 0;

			rval = copy_from_user(&proc_cfg, ext_ctrls[i].ptr, sizeof(struct isp_proc_cfg));
			if ((rval != 0) || (proc_cfg.buffer_size == 0))
				break;
			isp_proc_setProcContent(proc_cfg.buffer, proc_cfg.buffer_size);

			break;
		}

		case V4L2_CID_DV_VIP_ISP_RGBIR:
			ctx->is_rgbir_sensor = ext_ctrls[i].value;

			ctx->isp_pipe_cfg[ISP_PRERAW_A].is_rgbir_sensor = ext_ctrls[i].value;
			vip_pr(CVI_WARN, "RGBIR sensor(%d) with format=%d\n", ctx->is_rgbir_sensor,
				vdev->usr_fmt.code);

			rc = 0;
			break;

		case V4L2_CID_DV_VIP_ISP_AWB_STS_PUT:
		{
			u8 raw_num = 0;
			unsigned long flags;

			raw_num = ext_ctrls[i].value;

			if (raw_num >= ISP_PRERAW_MAX)
				break;

			spin_lock_irqsave(&isp_bufpool[raw_num].awb_sts_lock, flags);
			isp_bufpool[raw_num].awb_sts_in_use = 0;
			spin_unlock_irqrestore(&isp_bufpool[raw_num].awb_sts_lock, flags);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_GET_FSWDR_PHY_BUF:
		{
			struct cvi_vip_memblock *isp_mem;

			isp_mem = vmalloc(sizeof(struct cvi_vip_memblock));
			if (copy_from_user(isp_mem, ext_ctrls[i].ptr, sizeof(struct cvi_vip_memblock)) != 0) {
				vfree(isp_mem);
				break;
			}

			isp_mem->size = sizeof(struct cvi_vip_isp_fswdr_report);
			if (isp_bufpool[isp_mem->raw_num].fswdr_rpt == NULL) {
				isp_bufpool[isp_mem->raw_num].fswdr_rpt = kmalloc(
					isp_mem->size, GFP_DMA | GFP_KERNEL);
				if (isp_bufpool[isp_mem->raw_num].fswdr_rpt == NULL) {
					vip_pr(CVI_ERR, "isp_bufpool[%d].fswdr_rpt alloc size(%d) fail\n",
						isp_mem->raw_num, isp_mem->size);
					vfree(isp_mem);
					break;
				}
			}
			isp_mem->vir_addr = isp_bufpool[isp_mem->raw_num].fswdr_rpt;
			isp_mem->phy_addr = virt_to_phys(isp_bufpool[isp_mem->raw_num].fswdr_rpt);

			if (copy_to_user(ext_ctrls[i].ptr, isp_mem, sizeof(struct cvi_vip_memblock)) != 0) {
				vfree(isp_mem);
				break;
			}

			vfree(isp_mem);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_QBUF:
		{
			struct cvi_vip_buffer2 buf;
			struct cvi_isp_buf2   *qbuf;
			u8 pre_trig = false, post_trig = false;

			if (copy_from_user(&buf, ext_ctrls[i].ptr, sizeof(buf))) {
				vip_pr(CVI_ERR, "V4L2_CID_DV_VIP_QBUF, copy_from_user failed.\n");
				rc = -ENOMEM;
				break;
			}

			qbuf = kmalloc(sizeof(struct cvi_isp_buf2), GFP_ATOMIC);
			if (qbuf == NULL) {
				vip_pr(CVI_ERR, "QBUF kmalloc size(%d) fail\n", sizeof(struct cvi_isp_buf2));
				break;
			}

			vdev->chn_id = buf.index;
			memcpy(&qbuf->buf, &buf, sizeof(struct cvi_vip_buffer2));

			if (_is_all_online(ctx) &&
				cvi_isp_rdy_buf_empty2(vdev, ISP_PRERAW_A) &&
				vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] > 0) {
				pre_trig = true;
			} else if (_is_fe_be_online(ctx)) { //fe->be->dram->post
				if (cvi_isp_rdy_buf_empty2(vdev, vdev->chn_id) &&
					vdev->postraw_frame_number[ISP_PRERAW_A] > 0) {
					vip_pr(CVI_DBG, "chn_%d buf empty, trigger post\n", vdev->chn_id);
					post_trig = true;
				}
			}

			_cvi_isp_buf_queue2(vdev, qbuf);

			if (pre_trig || post_trig)
				tasklet_hi_schedule(&vdev->job_work);

			rc = 0;
			break;
		}

		case V4L2_CID_DV_VIP_ISP_CLK_CTRL:
		{
			u8 clk_on = 0;

			clk_on = ext_ctrls[i].value;

			rc = _isp_clk_ctrl(vdev, clk_on);

			break;
		}

		case V4L2_CID_DV_VIP_ISP_SET_DMA_BUF_INFO:
		{
			struct cvi_vi_dma_buf_info info;
			int rval = 0;

			rval = copy_from_user(&info, ext_ctrls[i].ptr, sizeof(struct cvi_vi_dma_buf_info));
			if ((rval != 0) || (info.size == 0) || (info.paddr == 0))
				break;

			isp_mempool.base = info.paddr;
			isp_mempool.size = info.size;

			vip_pr(CVI_INFO, "ISP dma buf paddr(0x%llx) size=0x%x\n",
					isp_mempool.base, isp_mempool.size);

			rc = 0;
			break;
		}

		default:
			break;
		}
	}

	return rc;
}

int cvi_isp_s_selection(struct file *file, void *fh, struct v4l2_selection *sel)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct vip_rect crop;
	int rc = -EINVAL;

	switch (sel->target) {
	case V4L2_SEL_TGT_CROP:
	{
		if (!vdev->ctx.is_tile) {
			// output crop
			crop.x = sel->r.left;
			crop.y = sel->r.top;
			crop.h = sel->r.height;
			crop.w = sel->r.width;

			vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].postout_crop = crop;
			vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].postout_crop = crop;
			ispblk_crop_config(&vdev->ctx, ISP_BLK_ID_CROP8, crop);

			crop.x >>= 1;
			crop.y >>= 1;
			crop.w >>= 1;
			crop.h >>= 1;
			ispblk_crop_config(&vdev->ctx, ISP_BLK_ID_CROP9, crop);
		}
	}
	rc = 0;
	break;
	default:
		return rc;
	}

	vip_pr(CVI_INFO, "target(%d) rect(%d %d %d %d)\n", sel->target,
			sel->r.left, sel->r.top, sel->r.width, sel->r.height);
	return rc;
}

int cvi_isp_enum_fmt_vid_mplane(
	struct file *file,
	void  *priv,
	struct v4l2_fmtdesc *f)
{
	vip_pr(CVI_DBG, "+\n");
	return cvi_vip_enum_fmt_vid(file, priv, f);
}

int cvi_isp_g_fmt_vid_cap_mplane(
	struct file *file,
	void *priv,
	struct v4l2_format *f)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;
	unsigned int p;

	vip_pr(CVI_DBG, "+\n");
	WARN_ON(!vdev);

	mp->width        = vdev->ctx.img_width;
	mp->height       = vdev->ctx.img_height;
	mp->field        = V4L2_FIELD_NONE;
	mp->pixelformat  = vdev->fmt->fourcc;
	mp->colorspace   = vdev->colorspace;
	mp->xfer_func    = V4L2_XFER_FUNC_DEFAULT;
	mp->ycbcr_enc    = V4L2_YCBCR_ENC_DEFAULT;
	mp->quantization = V4L2_QUANTIZATION_DEFAULT;
	mp->num_planes   = vdev->fmt->buffers;
	for (p = 0; p < mp->num_planes; p++) {
		mp->plane_fmt[p].bytesperline = vdev->bytesperline[p];
		mp->plane_fmt[p].sizeimage = vdev->sizeimage[p];
	}

	return 0;
}

int cvi_isp_try_fmt_vid_cap_mplane(
	struct file *file,
	void *priv,
	struct v4l2_format *f)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;
	int rc = cvi_vip_try_fmt_vid_mplane(f, VIP_ALIGNMENT);

	if (rc < 0)
		return rc;

	if ((mp->width < vdev->ctx.img_width) || (mp->height < vdev->ctx.img_height)) {
		vip_pr(CVI_WARN, "size(%d*%d) should be (%d*%d).\n",
			mp->width, mp->height,
			vdev->ctx.img_width, vdev->ctx.img_height);
		mp->width = vdev->ctx.img_width;
		mp->height = vdev->ctx.img_height;
	}
#if 0
	if (mp->pixelformat != V4L2_PIX_FMT_YUV420M) {
		vip_pr(CVI_WARN, "fourcc(%x) should be yuv420.\n",
			mp->pixelformat);
		mp->pixelformat = V4L2_PIX_FMT_YUV420M;
	}
#endif
	return 0;
}

int cvi_isp_s_fmt_vid_cap_mplane(struct file *file, void *priv,
				struct v4l2_format *f)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	struct v4l2_pix_format_mplane *mp = &f->fmt.pix_mp;
	struct v4l2_plane_pix_format *pfmt = mp->plane_fmt;
	const struct cvi_vip_fmt *fmt;
	unsigned int p;
	int rc = cvi_isp_try_fmt_vid_cap_mplane(file, priv, f);

	vip_pr(CVI_DBG, "+\n");
	if (rc < 0)
		return rc;

	fmt = cvi_vip_get_format(mp->pixelformat);
	vdev->fmt = fmt;
	vdev->colorspace = mp->colorspace;
	for (p = 0; p < mp->num_planes; p++) {
		vdev->bytesperline[p] = pfmt[p].bytesperline;
		vdev->sizeimage[p] = pfmt[p].sizeimage = 1024;
	}

	return rc;
}

void cvi_isp_dqbuf_list(struct cvi_isp_vdev *vdev, const u32 frm_num, const u8 chn_id)
{
	unsigned long flags;
	struct _isp_dqbuf_n *n;

	n = kmalloc(sizeof(struct _isp_dqbuf_n), GFP_ATOMIC);
	if (n == NULL) {
		vip_pr(CVI_ERR, "DQbuf kmalloc size(%d) fail\n", sizeof(struct _isp_dqbuf_n));
		return;
	}
	n->chn_id = chn_id;
	n->frm_num = frm_num;

	vip_pr(CVI_DBG, "chn_num_%d frm_num_%d\n", chn_id, frm_num);

	spin_lock_irqsave(&dq_lock, flags);
	list_add_tail(&n->list, &dqbuf_q.list);
	spin_unlock_irqrestore(&dq_lock, flags);
}

int cvi_isp_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
{
	unsigned long flags;
	struct _isp_dqbuf_n *n = NULL;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	struct timespec64 ts;

	ktime_get_ts64(&ts);
#else
	struct timeval tv;

	tv = ktime_to_timeval(ktime_get());
#endif

	spin_lock_irqsave(&dq_lock, flags);
	if (!list_empty(&dqbuf_q.list)) {
		n = list_first_entry(&dqbuf_q.list, struct _isp_dqbuf_n, list);
		p->flags		= n->chn_id;
		p->sequence		= n->frm_num;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
		p->timestamp.tv_sec	= ts.tv_sec;
		p->timestamp.tv_usec	= ts.tv_nsec / 1000;
#else
		p->timestamp.tv_sec	= tv.tv_sec;
		p->timestamp.tv_usec	= tv.tv_usec;
#endif
		list_del_init(&n->list);
		kfree(n);
	}
	spin_unlock_irqrestore(&dq_lock, flags);

	vip_pr(CVI_DBG, "dqbuf chn_id=%d\n", p->flags);

	return 0;
}

static int isp_subscribe_event(struct v4l2_fh *fh,
	const struct v4l2_event_subscription *sub)
{
	if ((sub->type & V4L2_EVENT_CVI_VIP_CLASS) != V4L2_EVENT_CVI_VIP_CLASS)
		return -EINVAL;

	return v4l2_event_subscribe(fh, sub, CVI_ISP_NEVENTS, NULL);
}

static const struct v4l2_ioctl_ops cvi_isp_ioctl_ops = {
	.vidioc_querycap = cvi_isp_querycap,
	.vidioc_g_ctrl = cvi_isp_g_ctrl,
	.vidioc_s_ctrl = cvi_isp_s_ctrl,
	.vidioc_g_ext_ctrls = cvi_isp_g_ext_ctrls,
	.vidioc_s_ext_ctrls = cvi_isp_s_ext_ctrls,

	.vidioc_s_selection     = cvi_isp_s_selection,
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	.vidioc_enum_fmt_vid_cap = cvi_isp_enum_fmt_vid_mplane,
#else
	.vidioc_enum_fmt_vid_cap_mplane = cvi_isp_enum_fmt_vid_mplane,
#endif
	.vidioc_g_fmt_vid_cap_mplane    = cvi_isp_g_fmt_vid_cap_mplane,
	.vidioc_try_fmt_vid_cap_mplane  = cvi_isp_try_fmt_vid_cap_mplane,
	.vidioc_s_fmt_vid_cap_mplane    = cvi_isp_s_fmt_vid_cap_mplane,

//	.vidioc_s_dv_timings        = cvi_isp_s_dv_timings,
//	.vidioc_g_dv_timings        = cvi_isp_g_dv_timings,
//	.vidioc_query_dv_timings    = cvi_isp_query_dv_timings,
//	.vidioc_enum_dv_timings     = cvi_isp_enum_dv_timings,
//	.vidioc_dv_timings_cap      = cvi_isp_dv_timings_cap,

	.vidioc_reqbufs         = vb2_ioctl_reqbufs,
	//.vidioc_create_bufs     = vb2_ioctl_create_bufs,
	.vidioc_prepare_buf     = vb2_ioctl_prepare_buf,
	.vidioc_querybuf        = vb2_ioctl_querybuf,
	.vidioc_qbuf            = vb2_ioctl_qbuf,
	.vidioc_dqbuf           = cvi_isp_dqbuf,//vb2_ioctl_dqbuf,
	//.vidioc_expbuf          = vb2_ioctl_expbuf,
	.vidioc_streamon        = vb2_ioctl_streamon,
	.vidioc_streamoff       = vb2_ioctl_streamoff,

	.vidioc_subscribe_event     = isp_subscribe_event,
	.vidioc_unsubscribe_event   = v4l2_event_unsubscribe,
};

static int cif_lvds_reset(struct cvi_isp_vdev *vdev, enum cvi_isp_raw dev_num)
{
	unsigned int devno = dev_num;

	vip_sys_cif_cb(CVI_MIPI_RESET_LVDS, (void *)&devno);

	return 0;
}

/*************************************************************************
 *	VB2_OPS definition
 *************************************************************************/
/**
 * call before VIDIOC_REQBUFS to setup buf-queue.
 * nbuffers: number of buffer requested
 * nplanes:  number of plane each buffer
 * sizes:    size of each plane(bytes)
 */
static int cvi_isp_queue_setup(struct vb2_queue *vq,
			      unsigned int *nbuffers, unsigned int *nplanes,
			      unsigned int sizes[], struct device *alloc_devs[])
{
	struct cvi_isp_vdev *vdev = vb2_get_drv_priv(vq);
	unsigned int planes = vdev->fmt->buffers;
	unsigned int p;

	vip_pr(CVI_DBG, "+\n");

	for (p = 0; p < planes; ++p)
		sizes[p] = vdev->sizeimage[p];

	if (vq->num_buffers + *nbuffers < 2)
		*nbuffers = 2 - vq->num_buffers;

	*nplanes = planes;

	vip_pr(CVI_INFO, "num_buffer=%d, num_plane=%d\n", *nbuffers, *nplanes);
	for (p = 0; p < *nplanes; p++)
		vip_pr(CVI_INFO, "size[%u]=%u\n", p, sizes[p]);

	return 0;
}

static void _isp_yuv_bypass_buf_enq(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 buf_chn)
{
	struct isp_ctx *ictx = &vdev->ctx;
	struct cvi_isp_buf2 *b = NULL;
	enum ISP_BLK_ID_T dmaid;
	u64 tmp_addr = 0;
	u8 hw_chn_num = (raw_num == ISP_PRERAW_A) ? buf_chn : (buf_chn - vdev->ctx.rawb_chnstr_num);

	cvi_isp_rdy_buf_pop2(vdev, buf_chn);
	b = _cvi_isp_next_buf2(vdev, buf_chn);
	if (b == NULL)
		return;

	vip_pr(CVI_DBG, "update yuv bypass outbuf: 0x%llx raw_%d chn_num(%d)\n",
			b->buf.planes[0].addr, raw_num, buf_chn);

	if (raw_num == ISP_PRERAW_A) {
		switch (buf_chn) {
		case 0:
			dmaid = ISP_BLK_ID_WDMA0;
			break;
		case 1:
			dmaid = ISP_BLK_ID_WDMA1;
			break;
		case 2:
			dmaid = ISP_BLK_ID_WDMA6;
			break;
		case 3:
			dmaid = ISP_BLK_ID_WDMA7;
			break;
		default:
			vip_pr(CVI_ERR, "PRERAW_A Wrong chn_num(%d)\n", buf_chn);
			return;
		}
	} else {
		switch (hw_chn_num) {
		case 0:
			dmaid = ISP_BLK_ID_WDMA6;
			break;
		case 1:
			dmaid = ISP_BLK_ID_WDMA7;
			break;
		default:
			vip_pr(CVI_ERR, "RAW_B Wrong chn_num(%d), rawb_chnstr_num(%d)\n",
					buf_chn, ictx->rawb_chnstr_num);
			return;
		}
	}

	tmp_addr = b->buf.planes[0].addr;

	if (vdev->pre_fe_frm_num[raw_num][hw_chn_num] == 0)
		ispblk_dma_yuv_bypass_config(ictx, dmaid, tmp_addr, raw_num);
	else
		ispblk_dma_setaddr(ictx, dmaid, tmp_addr);
}

static void _isp_yuv_bypass_trigger(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 hw_chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 buf_chn;

	if (atomic_read(&vdev->isp_streamoff) == 0) {
		if (atomic_cmpxchg(&vdev->pre_fe_state[raw_num][hw_chn_num],
					ISP_PRERAW_IDLE, ISP_PRERAW_RUNNING) ==
					ISP_PRERAW_RUNNING) {
			vip_pr(CVI_DBG, "fe_%d chn_num_%d is running\n", raw_num, hw_chn_num);
			return;
		}
		buf_chn = (raw_num == ISP_PRERAW_A) ? hw_chn_num : vdev->ctx.rawb_chnstr_num + hw_chn_num;

		_isp_yuv_bypass_buf_enq(vdev, raw_num, buf_chn);
		isp_pre_trig(ctx, raw_num, hw_chn_num);
	}
}

void _vi_postraw_ctrl_setup(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 cfg_post = false;

	if (!ctx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) {
		cfg_post = true;
	} else if (ctx->is_dual_sensor && !ctx->isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) {
		cfg_post = true;
	}

	if (cfg_post) { //RGB sensor
		_isp_rawtop_init(vdev);
		_isp_rgbtop_init(vdev);
		_isp_yuvtop_init(vdev);
	}

	ispblk_isptop_config(ctx);
}

void _vi_pre_fe_ctrl_setup(enum cvi_isp_raw raw_num, struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ictx = &vdev->ctx;

	if (ictx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) {//YUV sensor
		ispblk_csibdg_yuv_bypass_config(ictx, raw_num);

		if (ictx->isp_pipe_cfg[raw_num].is_offline_scaler) { //vi vpss offline mode
			u8 total_chn = (raw_num == ISP_PRERAW_A) ?
					ictx->rawb_chnstr_num :
					ictx->total_chn_num;
			u8 chn_str = (raw_num == ISP_PRERAW_A) ? 0 : ictx->rawb_chnstr_num;

			for (; chn_str < total_chn; chn_str++)
				_isp_yuv_bypass_buf_enq(vdev, raw_num, chn_str);
		}
	} else { //RGB sensor
		ispblk_preraw_fe_config(ictx, raw_num);
		ispblk_csibdg_config(ictx, raw_num);
		ispblk_csibdg_crop_update(ictx, raw_num, true);

		if (raw_num == ISP_PRERAW_A) {
			ispblk_blc_set_gain(ictx, ISP_BLC_ID_FE0_LE, 0x40f, 0x419, 0x419, 0x405);
			ispblk_blc_enable(ictx, ISP_BLC_ID_FE0_LE, true, false);

			ispblk_lscr_set_lut(ictx, ISP_BLK_ID_LSCR0, lscr_lut, ARRAY_SIZE(lscr_lut));
			ispblk_lscr_config(ictx, ISP_BLK_ID_LSCR0, false);

			if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
				ispblk_blc_set_gain(ictx, ISP_BLC_ID_FE0_SE, 0x40f, 0x419, 0x419, 0x405);
				ispblk_blc_enable(ictx, ISP_BLC_ID_FE0_SE, true, false);

				ispblk_lscr_set_lut(ictx, ISP_BLK_ID_LSCR1, lscr_lut, ARRAY_SIZE(lscr_lut));
				ispblk_lscr_config(ictx, ISP_BLK_ID_LSCR1, false);
			}
		} else if (raw_num == ISP_PRERAW_B) {
			ispblk_blc_set_gain(ictx, ISP_BLC_ID_FE1_LE, 0x40f, 0x419, 0x419, 0x405);
			ispblk_blc_enable(ictx, ISP_BLC_ID_FE1_LE, true, false);

			ispblk_lscr_set_lut(ictx, ISP_BLK_ID_LSCR2, lscr_lut, ARRAY_SIZE(lscr_lut));
			ispblk_lscr_config(ictx, ISP_BLK_ID_LSCR2, false);

			if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
				ispblk_blc_set_gain(ictx, ISP_BLC_ID_FE1_SE, 0x40f, 0x419, 0x419, 0x405);
				ispblk_blc_enable(ictx, ISP_BLC_ID_FE1_SE, true, false);

				ispblk_lscr_set_lut(ictx, ISP_BLK_ID_LSCR3, lscr_lut, ARRAY_SIZE(lscr_lut));
				ispblk_lscr_config(ictx, ISP_BLK_ID_LSCR3, false);
			}
		}

		ispblk_rgbmap_config(ictx, ISP_BLK_ID_RGBMAP0, true, raw_num);
		ispblk_lmap_config(ictx, ISP_BLK_ID_LMP0, true, raw_num);

		if (ictx->isp_pipe_cfg[raw_num].is_hdr_on) {
			ispblk_rgbmap_config(ictx, ISP_BLK_ID_RGBMAP1, true, raw_num);
			ispblk_lmap_config(ictx, ISP_BLK_ID_LMP1, true, raw_num);
		} else {
			ispblk_rgbmap_config(ictx, ISP_BLK_ID_RGBMAP1, false, raw_num);
			ispblk_lmap_config(ictx, ISP_BLK_ID_LMP1, false, raw_num);
		}
	}
}

void _vi_ctrl_init(enum cvi_isp_raw raw_num, struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ictx = &vdev->ctx;

	if (ictx->is_ctrl_inited)
		return;

	if (vdev->snr_info[raw_num].snr_fmt.img_size[0].active_w != 0) { //MW config snr_info flow
		ictx->isp_pipe_cfg[raw_num].csibdg_width = vdev->snr_info[raw_num].snr_fmt.img_size[0].width;
		ictx->isp_pipe_cfg[raw_num].csibdg_height = vdev->snr_info[raw_num].snr_fmt.img_size[0].height;
		ictx->isp_pipe_cfg[raw_num].max_width =
						vdev->snr_info[raw_num].snr_fmt.img_size[0].max_width;
		ictx->isp_pipe_cfg[raw_num].max_height =
						vdev->snr_info[raw_num].snr_fmt.img_size[0].max_height;

		ictx->isp_pipe_cfg[raw_num].crop.w = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_w;
		ictx->isp_pipe_cfg[raw_num].crop.h = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_h;
		ictx->isp_pipe_cfg[raw_num].crop.x = vdev->snr_info[raw_num].snr_fmt.img_size[0].start_x;
		ictx->isp_pipe_cfg[raw_num].crop.y = vdev->snr_info[raw_num].snr_fmt.img_size[0].start_y;

		if (vdev->snr_info[raw_num].snr_fmt.frm_num > 1) { //HDR
			ictx->isp_pipe_cfg[raw_num].crop_se.w =
							vdev->snr_info[raw_num].snr_fmt.img_size[1].active_w;
			ictx->isp_pipe_cfg[raw_num].crop_se.h =
							vdev->snr_info[raw_num].snr_fmt.img_size[1].active_h;
			ictx->isp_pipe_cfg[raw_num].crop_se.x =
							vdev->snr_info[raw_num].snr_fmt.img_size[1].start_x;
			ictx->isp_pipe_cfg[raw_num].crop_se.y =
							vdev->snr_info[raw_num].snr_fmt.img_size[1].start_y;

			ictx->isp_pipe_cfg[raw_num].is_hdr_on = true;

			vdev->ctx.is_hdr_on = true;
		}

		ictx->rgb_color_mode[raw_num] = _mbus_remap(vdev->snr_info[raw_num].color_mode);

		if ((ictx->rgb_color_mode[raw_num] == ISP_BAYER_TYPE_BGRGI) ||
			(ictx->rgb_color_mode[raw_num] == ISP_BAYER_TYPE_RGBGI)) {
			ictx->is_rgbir_sensor = true;
			ictx->isp_pipe_cfg[raw_num].is_rgbir_sensor = true;
		}
	}

	if (ictx->isp_pipe_cfg[raw_num].is_patgen_en) {
		ictx->isp_pipe_cfg[raw_num].crop.w = vdev->usr_crop.width;
		ictx->isp_pipe_cfg[raw_num].crop.h = vdev->usr_crop.height;
		ictx->isp_pipe_cfg[raw_num].crop.x = vdev->usr_crop.left;
		ictx->isp_pipe_cfg[raw_num].crop.y = vdev->usr_crop.top;
		ictx->isp_pipe_cfg[raw_num].crop_se.w = vdev->usr_crop.width;
		ictx->isp_pipe_cfg[raw_num].crop_se.h = vdev->usr_crop.height;
		ictx->isp_pipe_cfg[raw_num].crop_se.x = vdev->usr_crop.left;
		ictx->isp_pipe_cfg[raw_num].crop_se.y = vdev->usr_crop.top;

		ictx->isp_pipe_cfg[raw_num].csibdg_width	= vdev->usr_fmt.width;
		ictx->isp_pipe_cfg[raw_num].csibdg_height	= vdev->usr_fmt.height;
		ictx->isp_pipe_cfg[raw_num].max_width		= vdev->usr_fmt.width;
		ictx->isp_pipe_cfg[raw_num].max_height		= vdev->usr_fmt.height;

		ictx->rgb_color_mode[raw_num] = vdev->usr_fmt.code;
	} else if (ictx->isp_pipe_cfg[raw_num].is_offline_preraw) {
		ictx->isp_pipe_cfg[raw_num].crop.w = vdev->usr_crop.width;
		ictx->isp_pipe_cfg[raw_num].crop.h = vdev->usr_crop.height;
		ictx->isp_pipe_cfg[raw_num].crop.x = vdev->usr_crop.left;
		ictx->isp_pipe_cfg[raw_num].crop.y = vdev->usr_crop.top;
		ictx->isp_pipe_cfg[raw_num].crop_se.w = vdev->usr_crop.width;
		ictx->isp_pipe_cfg[raw_num].crop_se.h = vdev->usr_crop.height;
		ictx->isp_pipe_cfg[raw_num].crop_se.x = vdev->usr_crop.left;
		ictx->isp_pipe_cfg[raw_num].crop_se.y = vdev->usr_crop.top;

		ictx->isp_pipe_cfg[raw_num].csibdg_width	= vdev->usr_fmt.width;
		ictx->isp_pipe_cfg[raw_num].csibdg_height	= vdev->usr_fmt.height;
		ictx->isp_pipe_cfg[raw_num].max_width		= vdev->usr_fmt.width;
		ictx->isp_pipe_cfg[raw_num].max_height		= vdev->usr_fmt.height;

		ictx->rgb_color_mode[raw_num] = vdev->usr_fmt.code;

		vip_pr(CVI_INFO, "csi_bdg=%d:%d, post_crop=%d:%d:%d:%d\n",
				vdev->usr_fmt.width, vdev->usr_fmt.height,
				vdev->usr_crop.width, vdev->usr_crop.height,
				vdev->usr_crop.left, vdev->usr_crop.top);
	}

	ictx->isp_pipe_cfg[raw_num].post_img_w = ictx->isp_pipe_cfg[raw_num].crop.w;
	ictx->isp_pipe_cfg[raw_num].post_img_h = ictx->isp_pipe_cfg[raw_num].crop.h;

	/* use csibdg crop */
	ictx->crop_x = 0;
	ictx->crop_y = 0;
	ictx->crop_se_x = 0;
	ictx->crop_se_y = 0;

	if (!ictx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) {
		//Postraw out size
		ictx->img_width = ictx->isp_pipe_cfg[ISP_PRERAW_A].crop.w;
		ictx->img_height = ictx->isp_pipe_cfg[ISP_PRERAW_A].crop.h;
	}

	if (raw_num == ISP_PRERAW_A) {
		if (ictx->is_tile)
			_isp_tile_cal_size(ictx);
		isp_init(ictx);
	}

	if ((ictx->is_dual_sensor && (raw_num == ISP_PRERAW_B)) ||
		!ictx->is_dual_sensor) {
		ictx->is_ctrl_inited = true;
	}
}

void _vi_sence_ctrl(struct cvi_isp_vdev *vdev, enum cvi_isp_raw *raw_max)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 raw_num = ISP_PRERAW_A;

	if (ctx->is_ctrl_inited) {
		// vi_sence_ctrl had been inited before.
		if (ctx->is_dual_sensor)
			*raw_max = ISP_PRERAW_MAX;
		else
			*raw_max = ISP_PRERAW_B;

		return;
	}

	if (viproc_en[1] == 1) {
		ctx->is_dual_sensor = true;
		ctx->is_offline_be = true;
		ctx->is_offline_postraw = false;
		*raw_max = ISP_PRERAW_MAX;
		//Only single sensor with non-tile can use two rgbmap buf, two sensors need 3 rgbmap
		RGBMAP_BUF_IDX = 3;
	} else { //Single sensor
		ctx->is_dual_sensor = false;
		if (ctx->is_offline_be || ctx->is_offline_postraw) {
			ctx->is_offline_be = false;
			ctx->is_offline_postraw = true;
		}
		*raw_max = ISP_PRERAW_B;
		//Only single sensor with non-tile can use two rgbmap buf
		RGBMAP_BUF_IDX = 2;

		//Currently don't support single yuv sensor online to scaler or on-the-fly
		if (ctx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path)
			ctx->isp_pipe_cfg[ISP_PRERAW_A].is_offline_scaler = true;
	}

	/* Check if go tile mode */
	if (vdev->snr_info[ISP_PRERAW_A].snr_fmt.img_size[0].active_w > 2304 || (tile_en == 1)) {
#if 0 //ToDo
		clk_set_rate(clk_get_parent(vdev->isp_clk[0]), 375000000);
#endif
		ctx->is_tile		= true;
		ctx->is_offline_be	= false;
		ctx->is_offline_postraw = true;
		//Tile sensor need 3 rgbmap
		RGBMAP_BUF_IDX = 3;
	}

	if (!ctx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) //RGB sensor
		ctx->rawb_chnstr_num = 1;
	else if (ctx->isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) //YUV sensor
		ctx->rawb_chnstr_num = ctx->isp_pipe_cfg[ISP_PRERAW_A].muxMode + 1;

	for (raw_num = ISP_PRERAW_A; raw_num < *raw_max; raw_num++) {
		if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) //RGB sensor
			ctx->total_chn_num++;
		else //YUV sensor
			ctx->total_chn_num += ctx->isp_pipe_cfg[raw_num].muxMode + 1;
	}

	if (ctx->total_chn_num > 4) {
		vip_pr(CVI_ERR, "[ERR] Total chn_num(%d) is wrong\n", ctx->total_chn_num);
		vip_pr(CVI_ERR, "[ERR] raw_A,infMode(%d),muxMode(%d)\n",
				ctx->isp_pipe_cfg[ISP_PRERAW_A].infMode, ctx->isp_pipe_cfg[ISP_PRERAW_A].muxMode);
		if (ctx->is_dual_sensor) {
			vip_pr(CVI_ERR, "[ERR] raw_B,infMode(%d),muxMode(%d)\n",
				ctx->isp_pipe_cfg[ISP_PRERAW_B].infMode, ctx->isp_pipe_cfg[ISP_PRERAW_B].muxMode);
		}
	}

	vip_pr(CVI_INFO, "Total_chn_num=%d, rawb_chnstr_num=%d\n",
			ctx->total_chn_num, ctx->rawb_chnstr_num);
}

static void _vi_suspend(struct cvi_isp_vdev *vdev)
{
	struct cvi_vi_ctx *pviProcCtx = NULL;

	pviProcCtx = (struct cvi_vi_ctx *)(vdev->shared_mem);

	if (pviProcCtx->vi_stt == VI_SUSPEND) {
		u8 i = 0;

		isp_streaming(&vdev->ctx, false, ISP_PRERAW_A);
		if (vdev->ctx.is_dual_sensor)
			isp_streaming(&vdev->ctx, false, ISP_PRERAW_B);

		cvi_isp_sw_init(vdev);

		for (i = 0; i < ARRAY_SIZE(vdev->isp_clk); ++i) {
			if (vdev->isp_clk[i])
				clk_disable_unprepare(vdev->isp_clk[i]);
		}

		for (i = 0; i < ARRAY_SIZE(vdev->mac_clk); ++i) {
			if (vdev->mac_clk[i])
				clk_disable_unprepare(vdev->mac_clk[i]);
		}
	}
}

static int _vi_resume(struct cvi_isp_vdev *vdev)
{
	struct cvi_vi_ctx *pviProcCtx = NULL;

	pviProcCtx = (struct cvi_vi_ctx *)(vdev->shared_mem);

	if (pviProcCtx->vi_stt == VI_SUSPEND) {
		_mempool_reset();
		//cvi_isp_sw_init(vdev);

		pviProcCtx->vi_stt = VI_RUNNING;
	}

	return 0;
}

void _viBWCalSet(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct cvi_vi_ctx *pviProcCtx = NULL;
	void __iomem *bw_limiter;
	u32 bwlwin = 0, data_size = 0, BW[2] = {0, 0}, total_bw = 0, bwltxn = 5, margin = 11, fps = 25;
	u32 width = ctx->isp_pipe_cfg[ISP_PRERAW_A].crop.w;
	u32 height = ctx->isp_pipe_cfg[ISP_PRERAW_A].crop.h;
	u8 raw_num = ISP_PRERAW_A;

#define DEFAULT_FPS 25

	pviProcCtx = (struct cvi_vi_ctx *)(vdev->shared_mem);

	fps = (pviProcCtx->devAttr[raw_num].snrFps) ? pviProcCtx->devAttr[raw_num].snrFps : DEFAULT_FPS;

	if (!ctx->isp_pipe_cfg[raw_num].is_hdr_on)
		data_size = (206 * width * height) / 64 + 30 * height + 49284;
	else
		data_size = (314 * width * height) / 64 + 60 * height + 49284;

	BW[0] = (fps * data_size) / 1000000 + 1;

	if (ctx->is_dual_sensor) {
		raw_num = ISP_PRERAW_B;
		fps = (pviProcCtx->devAttr[raw_num].snrFps) ? pviProcCtx->devAttr[raw_num].snrFps : DEFAULT_FPS;
		width = ctx->isp_pipe_cfg[raw_num].crop.w;
		height = ctx->isp_pipe_cfg[raw_num].crop.h;

		if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) {//RGB sensor
			if (!ctx->isp_pipe_cfg[raw_num].is_hdr_on)
				data_size += (206 * width * height) / 64 + 30 * height + 49284;
			else
				data_size += (314 * width * height) / 64 + 60 * height + 49284;
		} else { //YUV sensor
			data_size += (35 * width * height) / 10;
		}

		BW[1] = (fps * data_size) / 1000000 + 1;
	}

	total_bw = BW[0] + BW[1];

	bwlwin = bwltxn * 256000 / ((((total_bw * 33) / 10) * margin) / 10);

	//ISP rdma bandwidth limiter window size
	bw_limiter = ioremap(0x0A072020, 0x4);
	iowrite32(((bwltxn << 10) | bwlwin), bw_limiter);
	vip_pr(CVI_INFO, "isp rdma bw_limiter=0x%x, BW=%d, bwlwin=%d\n",
			ioread32(bw_limiter), total_bw, bwlwin);
	iounmap(bw_limiter);
}

static int cvi_isp_start_streaming(struct vb2_queue *vq, unsigned int count)
{
	struct cvi_isp_vdev *vdev = vb2_get_drv_priv(vq);
	struct cif_attr_s cif_attr;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	enum cvi_isp_raw raw_max = ISP_PRERAW_MAX - 1;
	int rc = 0;

	if (_vi_resume(vdev) != 0) {
		vip_pr(CVI_ERR, "vi resume failed\n");
		return -1;
	}

	_isp_tuning_clear();

#ifndef FPGA_EARLY_PORTING
	uint32_t v = 0;

	tee_cv_efuse_read(0x28, 4, &v);
	if (v & 0x00100000) {
		if (!(vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path ||
			vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path)) {
			cvi_isp_clk_disable();
			return -1;
		}
	}
#endif

	vip_pr(CVI_DBG, "+\n");

	_vi_sence_ctrl(vdev, &raw_max);

	/* cif lvds reset */
	cif_lvds_reset(vdev, ISP_PRERAW_A);
	if (vdev->ctx.is_dual_sensor) //two sensor mode
		cif_lvds_reset(vdev, ISP_PRERAW_B);

	vdev->vdev.dev_debug	= isp_v4l2_debug;

	for (raw_num = ISP_PRERAW_A; raw_num < raw_max; raw_num++) {
		/* Get stagger vsync info from cif */
		cif_attr.devno = raw_num;
		vip_sys_cif_cb(CVI_MIPI_GET_CIF_ATTR, &cif_attr);
		vdev->ctx.isp_pipe_cfg[raw_num].is_stagger_vsync = cif_attr.stagger_vsync;

		vdev->ctx.isp_pipe_cfg[raw_num].is_patgen_en = csi_patgen_en[raw_num];

		if (vdev->ctx.isp_pipe_cfg[raw_num].is_patgen_en) {
			vdev->usr_fmt.width = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_w;
			vdev->usr_fmt.height = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_h;
			vdev->usr_fmt.code = ISP_BAYER_TYPE_BG;
			vdev->usr_crop.width = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_w;
			vdev->usr_crop.height = vdev->snr_info[raw_num].snr_fmt.img_size[0].active_h;
			vdev->usr_crop.left = 0;
			vdev->usr_crop.top = 0;

			vip_pr(CVI_WARN, "patgen enable, w_h(%d:%d), color mode(%d)\n",
					vdev->usr_fmt.width, vdev->usr_fmt.height, vdev->usr_fmt.code);
		}

		_vi_ctrl_init(raw_num, vdev);
		_vi_pre_fe_ctrl_setup(raw_num, vdev);

		if (_is_all_online(&vdev->ctx)) {
			vip_pr(CVI_INFO, "on-the-fly mode\n");
			break;
		}

		if (!vdev->ctx.isp_pipe_cfg[raw_num].is_offline_preraw) {
			if (!vdev->ctx.isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB sensor
				isp_pre_trig(&vdev->ctx, raw_num, ISP_FE_CH0);
				if (vdev->ctx.isp_pipe_cfg[raw_num].is_hdr_on)
					isp_pre_trig(&vdev->ctx, raw_num, ISP_FE_CH1);
			} else { //YUV sensor
				u8 total_chn = (raw_num == ISP_PRERAW_A) ?
						vdev->ctx.rawb_chnstr_num :
						vdev->ctx.total_chn_num - vdev->ctx.rawb_chnstr_num;
				u8 chn_str = 0;

				for (; chn_str < total_chn; chn_str++)
					isp_pre_trig(&vdev->ctx, raw_num, chn_str);
			}
		}
	}

	_vi_preraw_be_init(vdev);
	_vi_postraw_ctrl_setup(vdev);
	_vi_dma_setup(&vdev->ctx, raw_max);

	vip_pr(CVI_INFO, "ISP scene path, be_off=%d, post_off=%d\n",
			vdev->ctx.is_offline_be, vdev->ctx.is_offline_postraw);

	if (_is_all_online(&vdev->ctx)) {
		const u8 raw_num = ISP_PRERAW_A;

		if (vdev->ctx.isp_pipe_cfg[raw_num].is_offline_scaler) { //offline mode
			if (!vdev->ctx.isp_pipe_cfg[raw_num].is_offline_preraw)
				isp_pre_trig(&vdev->ctx, raw_num, ISP_FE_CH0);

			_postraw_outbuf_enq(vdev, raw_num);
		} else { //online mode
			struct sc_cfg_cb post_para;

			post_para.dev = container_of(vdev, struct cvi_vip_dev, isp_vdev);
			post_para.snr_num = raw_num;
			post_para.is_tile = false;

			if (cvi_sc_cfg_cb(&post_para) != 0) {
				vip_pr(CVI_INFO, "sc is not ready. try later\n");
			} else {
				atomic_set(&vdev->ol_sc_frm_done, 0);

				if (!vdev->ctx.isp_pipe_cfg[raw_num].is_offline_preraw)
					isp_pre_trig(&vdev->ctx, raw_num, ISP_FE_CH0);
			}
		}
	}

	_viBWCalSet(vdev);

	isp_streaming(&vdev->ctx, true, ISP_PRERAW_A);
	if (vdev->ctx.is_dual_sensor) //two sensor mode
		isp_streaming(&vdev->ctx, true, ISP_PRERAW_B);

	return rc;
}

/* abort streaming and wait for last buffer */
static void cvi_isp_stop_streaming(struct vb2_queue *vq)
{
	struct cvi_isp_vdev *vdev = vb2_get_drv_priv(vq);
	struct cvi_isp_buf2 *cvi_vb2, *tmp;
	struct _isp_dqbuf_n *n = NULL;
	unsigned long flags;
	struct isp_buffer *isp_b;
	struct _isp_snr_i2c_node *i2c_n;
	struct _isp_raw_num_n    *raw_n;
	u8 i = 0, count = 5;

	vip_pr(CVI_DBG, "+\n");

	atomic_set(&vdev->isp_streamoff, 1);

	// disable load-from-dram at streamoff
	vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw = false;
	vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].is_offline_preraw = false;
	usr_pic_time_remove();

	// wait to make sure hw stopped.
	while (--count > 0) {
		if (atomic_read(&vdev->postraw_state) == ISP_POSTRAW_IDLE &&
			atomic_read(&vdev->pre_fe_state[ISP_PRERAW_A][ISP_FE_CH0]) == ISP_PRERAW_IDLE &&
			atomic_read(&vdev->pre_fe_state[ISP_PRERAW_A][ISP_FE_CH1]) == ISP_PRERAW_IDLE &&
			atomic_read(&vdev->pre_fe_state[ISP_PRERAW_B][ISP_FE_CH0]) == ISP_PRERAW_IDLE &&
			atomic_read(&vdev->pre_fe_state[ISP_PRERAW_B][ISP_FE_CH1]) == ISP_PRERAW_IDLE &&
			atomic_read(&vdev->pre_be_state[ISP_BE_CH0]) == ISP_PRERAW_IDLE &&
			atomic_read(&vdev->pre_be_state[ISP_BE_CH1]) == ISP_PRERAW_IDLE)
			break;
		vip_pr(CVI_WARN, "wait count(%d)\n", count);
#ifndef FPGA_EARLY_PORTING
		usleep_range(5 * 1000, 10 * 1000);
#else
		msleep(200);
#endif
	}

	if (count == 0) {
		vip_pr(CVI_ERR, "isp status fe_0(ch0:%d, ch1:%d) fe_1(ch0:%d, ch1:%d) be(ch0:%d, ch1:%d) postraw(%d)\n",
				atomic_read(&vdev->pre_fe_state[ISP_PRERAW_A][ISP_FE_CH0]),
				atomic_read(&vdev->pre_fe_state[ISP_PRERAW_A][ISP_FE_CH1]),
				atomic_read(&vdev->pre_fe_state[ISP_PRERAW_B][ISP_FE_CH0]),
				atomic_read(&vdev->pre_fe_state[ISP_PRERAW_B][ISP_FE_CH1]),
				atomic_read(&vdev->pre_be_state[ISP_BE_CH0]),
				atomic_read(&vdev->pre_be_state[ISP_BE_CH1]),
				atomic_read(&vdev->postraw_state));
	}

#if 0
	for (i = 0; i < 2; i++) {
		/*
		 * Release all the buffers enqueued to driver
		 * when streamoff is issued
		 */
		spin_lock_irqsave(&vdev->rdy_lock, flags);
		list_for_each_entry_safe(cvi_vb2, tmp, &(vdev->rdy_queue[i]), list) {
			vfree(cvi_vb2);
		}
		vdev->num_rdy[i] = 0;
		INIT_LIST_HEAD(&vdev->rdy_queue[i]);
		spin_unlock_irqrestore(&vdev->rdy_lock, flags);
	}
#endif

	for (i = 0; i < ISP_FE_CHN_MAX; i++) {
		/*
		 * Release all the buffers enqueued to driver
		 * when streamoff is issued
		 */
		spin_lock_irqsave(&vdev->qbuf_lock, flags);
		list_for_each_entry_safe(cvi_vb2, tmp, &(vdev->qbuf_list[i]), list) {
			kfree(cvi_vb2);
		}
		vdev->qbuf_num[i] = 0;
		INIT_LIST_HEAD(&vdev->qbuf_list[i]);
		spin_unlock_irqrestore(&vdev->qbuf_lock, flags);
	}

	spin_lock_irqsave(&dq_lock, flags);
	while (!list_empty(&dqbuf_q.list)) {
		n = list_first_entry(&dqbuf_q.list, struct _isp_dqbuf_n, list);
		list_del_init(&n->list);
		kfree(n);
	}
	spin_unlock_irqrestore(&dq_lock, flags);

	for (i = 0; i < ISP_CHN_MAX; i++) {
		while ((isp_b = isp_buf_remove(&pre_out_queue[i])) != NULL)
			vfree(isp_b);
		while ((isp_b = isp_buf_remove(&pre_out_se_queue[i])) != NULL)
			vfree(isp_b);
	}

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		while ((isp_b = isp_buf_remove(&raw_dump_b_dq[i])) != NULL)
			vfree(isp_b);
		while ((isp_b = isp_buf_remove(&raw_dump_b_se_dq[i])) != NULL)
			vfree(isp_b);
		while ((isp_b = isp_buf_remove(&raw_dump_b_q[i])) != NULL)
			vfree(isp_b);
		while ((isp_b = isp_buf_remove(&raw_dump_b_se_q[i])) != NULL)
			vfree(isp_b);

		spin_lock_irqsave(&snr_node_lock[i], flags);
		while (!list_empty(&isp_snr_i2c_queue[i].list)) {
			i2c_n = list_first_entry(&isp_snr_i2c_queue[i].list, struct _isp_snr_i2c_node, list);
			list_del_init(&i2c_n->list);
			kfree(i2c_n);
		}
		spin_unlock_irqrestore(&snr_node_lock[i], flags);

		while ((isp_b = isp_buf_remove(&pre_be_in_se_q[i])) != NULL)
			vfree(isp_b);
	}

	while ((isp_b = isp_buf_remove(&pre_be_in_q)) != NULL)
		vfree(isp_b);
	while ((isp_b = isp_buf_remove(&pre_be_out_q)) != NULL)
		vfree(isp_b);
	while ((isp_b = isp_buf_remove(&pre_be_out_se_q)) != NULL)
		vfree(isp_b);

	while ((isp_b = isp_buf_remove(&post_in_queue)) != NULL)
		vfree(isp_b);
	while ((isp_b = isp_buf_remove(&post_in_se_queue)) != NULL)
		vfree(isp_b);

	spin_lock_irqsave(&raw_num_lock, flags);
	while (!list_empty(&pre_raw_num_q.list)) {
		raw_n = list_first_entry(&pre_raw_num_q.list, struct _isp_raw_num_n, list);
		list_del_init(&raw_n->list);
		kfree(raw_n);
	}
	spin_unlock_irqrestore(&raw_num_lock, flags);

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		kfree(isp_bufpool[i].fswdr_rpt);
		isp_bufpool[i].fswdr_rpt = 0;
	}

	// reset at stop for next run.
	isp_reset(&vdev->ctx);

	_vi_suspend(vdev);
}

static void cvi_isp_buf_queue(struct vb2_buffer *vb)
{
}

const struct vb2_ops cvi_isp_qops = {
//    .buf_init           =
	.queue_setup        = cvi_isp_queue_setup,
//    .buf_finish         = cvi_isp_buf_finish,
	.buf_queue          = cvi_isp_buf_queue,
	.start_streaming    = cvi_isp_start_streaming,
	.stop_streaming     = cvi_isp_stop_streaming,
//    .wait_prepare       = vb2_ops_wait_prepare,
//    .wait_finish        = vb2_ops_wait_finish,
};

/*************************************************************************
 *	VB2-MEM-OPS definition
 *************************************************************************/
static void *isp_get_userptr(struct device *dev, unsigned long vaddr,
			     unsigned long size,
			     enum dma_data_direction dma_dir)
{
	return (void *)0xdeadbeef;
}

static void isp_put_userptr(void *buf_priv)
{
}

static const struct vb2_mem_ops cvi_isp_vb2_mem_ops = {
	.get_userptr = isp_get_userptr,
	.put_userptr = isp_put_userptr,
};

/*************************************************************************
 *	FOPS definition
 *************************************************************************/
static int cvi_isp_open(struct file *file)
{
	int rc = 0;
	struct cvi_isp_vdev *vdev = video_drvdata(file);

	WARN_ON(!vdev);

	rc = v4l2_fh_open(file);
	if (rc) {
		dprintk(VIP_ERR, "v4l2_fh_open failed(%d)\n", rc);
		return rc;
	}

	if (v4l2_fh_is_singular_file(file)) {
		u8 i = 0;

		for (i = 0; i < ARRAY_SIZE(vdev->isp_clk); ++i) {
			if (vdev->isp_clk[i]) {
				if (clk_prepare_enable(vdev->isp_clk[i])) {
					vip_pr(CVI_ERR, "[ERR] ISP_CLK(%s) enable fail\n", CLK_ISP_NAME[i]);
					rc = -EAGAIN;
					goto EXIT;
				}
			} else {
				vip_pr(CVI_ERR, "[ERR] ISP_CLK(%s) is null\n", CLK_ISP_NAME[i]);
				rc = -EAGAIN;
				goto EXIT;
			}
		}

		for (i = 0; i < ARRAY_SIZE(vdev->mac_clk); ++i) {
			if (vdev->mac_clk[i]) {
				if (clk_prepare_enable(vdev->mac_clk[i])) {
					vip_pr(CVI_ERR, "[ERR] MAC_CLK(%s) enable fail\n", CLK_MAC_NAME[i]);
					rc = -EAGAIN;
					goto EXIT;
				}
			} else {
				vip_pr(CVI_ERR, "[ERR] MAC_CLK(%s) is null\n", CLK_MAC_NAME[i]);
				rc = -EAGAIN;
				goto EXIT;
			}
		}

		// ldc clk use vip_sys_2 if mac_clk on
		vip_sys_reg_write_mask(VIP_SYS_VIP_CLK_CTRL1, BIT(20), BIT(20));

		_mempool_reset();

		cvi_isp_sw_init(vdev);
	}

	return rc;

EXIT:
	vb2_fop_release(file);

	return rc;
}

static int cvi_isp_release(struct file *file)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);

	WARN_ON(!vdev);

	if (v4l2_fh_is_singular_file(file)) {
		u8 i = 0;

		usr_pic_time_remove();

		isp_streaming(&vdev->ctx, false, ISP_PRERAW_A);
		if (vdev->ctx.is_dual_sensor)
			isp_streaming(&vdev->ctx, false, ISP_PRERAW_B);

		vdev->isp_pre_int_flag = 3;
		wake_up(&vdev->isp_pre_wait_q);
		while (atomic_read(&isp_pre_exit) == 0) {
			pr_info("wait for preraw_thread exit\n");
			usleep_range(5 * 1000, 10 * 1000);
		}

		isp_pre_th = NULL;

		vdev->isp_err_int_flag = 3;
		wake_up(&vdev->isp_err_wait_q);
		while (atomic_read(&isp_err_handler_exit) == 0) {
			pr_info("wait for isp_err_handler_thread exit\n");
			usleep_range(5 * 1000, 10 * 1000);
		}

		isp_err_handler_th = NULL;

		if (vb2_is_streaming(&vdev->vb_q))
			vb2_streamoff(&vdev->vb_q, vdev->vb_q.type);

		for (i = 0; i < ARRAY_SIZE(vdev->isp_clk); ++i) {
			if (vdev->isp_clk[i])
				clk_disable_unprepare(vdev->isp_clk[i]);
		}

		for (i = 0; i < ARRAY_SIZE(vdev->mac_clk); ++i) {
			if (vdev->mac_clk[i])
				clk_disable_unprepare(vdev->mac_clk[i]);
		}

		// ldc clk the same with sc's if mac_clk off
		vip_sys_reg_write_mask(VIP_SYS_VIP_CLK_CTRL1, BIT(20), 0x0);
	}

	vb2_fop_release(file);

	vip_pr(CVI_WARN, "-\n");
	return 0;
}

static int cvi_isp_mmap(struct file *file, struct vm_area_struct *vma)
{
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	unsigned long vm_start = vma->vm_start;
	unsigned int vm_size = vma->vm_end - vma->vm_start;
	unsigned int offset = vma->vm_pgoff << PAGE_SHIFT;
	void *pos = vdev->shared_mem;

	if (offset < 0 || (vm_size + offset) > VI_SHARE_MEM_SIZE)
		return -EINVAL;

	while (vm_size > 0) {
		if (remap_pfn_range(vma, vm_start, virt_to_pfn(pos), PAGE_SIZE, vma->vm_page_prot))
			return -EAGAIN;
		vip_pr(CVI_DBG, "vi proc mmap vir(%p) phys(%#llx)\n", pos, virt_to_phys((void *) pos));
		vm_start += PAGE_SIZE;
		pos += PAGE_SIZE;
		vm_size -= PAGE_SIZE;
	}

	return 0;
}

static unsigned int _cvi_isp_poll(struct file *file, struct poll_table_struct *wait)
{
	struct video_device *vfd = video_devdata(file);
	struct cvi_isp_vdev *vdev = video_drvdata(file);
	unsigned long req_events = poll_requested_events(wait);
	unsigned int res = 0;
	unsigned long flags;

	WARN_ON(!vdev);

	if (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags)) {
		struct v4l2_fh *fh = file->private_data;

		if (!(req_events & POLLIN)) {
			if (v4l2_event_pending(fh))
				return POLLPRI;
			poll_wait(file, &fh->wait, wait);
		}
	}

	if (req_events & POLLIN) {
		/*
		 * If buffer is not empty, then notify MW to DQ.
		 * Otherwise poll_wait.
		 */
		spin_lock_irqsave(&dq_lock, flags);
		if (!list_empty(&dqbuf_q.list))
			res = POLLIN | POLLRDNORM;
		else
			poll_wait(file, &vdev->isp_dq_wait_q, wait);
		spin_unlock_irqrestore(&dq_lock, flags);
	}

	return res;
}

unsigned int cvi_isp_poll(struct file *file, poll_table *wait)
{
	struct video_device *vdev = video_devdata(file);
	struct vb2_queue *q = vdev->queue;
	struct mutex *lock = q->lock ? q->lock : vdev->lock;
	unsigned int res = 0;
	void *fileio;

	/*
	 * If this helper doesn't know how to lock, then you shouldn't be using
	 * it but you should write your own.
	 */
	WARN_ON(!lock);

	if (lock && mutex_lock_interruptible(lock))
		return POLLERR;

	fileio = q->fileio;

	res = _cvi_isp_poll(file, wait);

	/* If fileio was started, then we have a new queue owner. */
	if (!fileio && q->fileio)
		q->owner = file->private_data;
	if (lock)
		mutex_unlock(lock);

	return res;
}

static struct v4l2_file_operations cvi_isp_fops = {
	.owner = THIS_MODULE,
	.open = cvi_isp_open,
	.release = cvi_isp_release,
	.poll = cvi_isp_poll,//vb2_fop_poll
	.mmap = cvi_isp_mmap,
	.unlocked_ioctl = video_ioctl2,
#ifdef CONFIG_COMPAT
	.compat_ioctl32 = video_ioctl2,
#endif
};

/*************************************************************************
 *	Proc functions
 *************************************************************************/
static inline void _vi_dbg_proc_show(struct seq_file *m, void *v)
{
	struct cvi_isp_vdev *vdev = m->private;
	struct isp_ctx *ctx = &vdev->ctx;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	enum cvi_isp_raw raw_max = ISP_PRERAW_MAX - 1;

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	struct timespec64 ts1, ts2;
#else
	struct timeval tv1, tv2;
#endif
	u32 frmCnt1, frmCnt2, sofCnt1, sofCnt2;
	u32 frmCnt1_b, frmCnt2_b, sofCnt1_b, sofCnt2_b;
	u64 t2 = 0, t1 = 0;

	if (ctx->is_dual_sensor)
		raw_max = ISP_PRERAW_MAX;

	sofCnt1 = vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0];
	if (vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) //YUV sensor
		frmCnt1 = vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0];
	else //RGB sensor
		frmCnt1 = vdev->postraw_frame_number[ISP_PRERAW_A];
	sofCnt1_b = vdev->pre_fe_sof_cnt[ISP_PRERAW_B][ISP_FE_CH0];
	if (vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) //YUV sensor
		frmCnt1_b = vdev->pre_fe_frm_num[ISP_PRERAW_B][ISP_FE_CH0];
	else //RGB sensor
		frmCnt1_b = vdev->postraw_frame_number[ISP_PRERAW_B];

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	ktime_get_real_ts64(&ts1);
	t1 = ts1.tv_sec * 1000000 + ts1.tv_nsec / 1000;
#else
	do_gettimeofday(&tv1);
	t1 = tv1.tv_sec * 1000000 + tv1.tv_usec;
#endif
	msleep(940);
	do {
		sofCnt2 = vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0];
		if (vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) //YUV sensor
			frmCnt2 = vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0];
		else //RGB sensor
			frmCnt2 = vdev->postraw_frame_number[ISP_PRERAW_A];
		sofCnt2_b = vdev->pre_fe_sof_cnt[ISP_PRERAW_B][ISP_FE_CH0];
		if (vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) //YUV sensor
			frmCnt2_b = vdev->pre_fe_frm_num[ISP_PRERAW_B][ISP_FE_CH0];
		else //RGB sensor
			frmCnt2_b = vdev->postraw_frame_number[ISP_PRERAW_B];
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
		ktime_get_real_ts64(&ts2);
		t2 = ts2.tv_sec * 1000000 + ts2.tv_nsec / 1000;
#else
		do_gettimeofday(&tv2);
		t2 = tv2.tv_sec * 1000000 + tv2.tv_usec;
#endif
	} while ((t2 - t1) < 1000000);

	for (; raw_num < raw_max; raw_num++) {
		if (raw_num == ISP_PRERAW_A) {
			seq_puts(m, "[VI BE_Dbg_Info]\n");
			seq_printf(m, "VIPreBEDoneSts\t\t:0x%x\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.be_sts.be_done_sts);
			seq_puts(m, "[VI Post_Dbg_Info]\n");
			seq_printf(m, "VIIspTopStatus\t\t:0x%x\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.post_sts.top_sts);
			seq_puts(m, "[VI DMA_Dbg_Info]\n");
			seq_printf(m, "VIWdmaErrStatus\t\t:0x%x\tVIWdmaIdleStatus\t:0x%x\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.wdma_err_sts,
					ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.wdma_idle);
			seq_printf(m, "VIRdmaErrStatus\t\t:0x%x\tVIRdmaIdleStatus\t:0x%x\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.rdma_err_sts,
					ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.rdma_idle);
		}

		seq_printf(m, "[VI ISP_PIPE_%c FE_Dbg_Info]\n", raw_num == ISP_PRERAW_A ? 'A' : 'B');
		seq_printf(m, "VIPreFERawDbgSts\t:0x%x\t\tVIPreFEDbgInfo\t\t:0x%x\n",
				ctx->isp_pipe_cfg[raw_num].dg_info.fe_sts.fe_idle_sts,
				ctx->isp_pipe_cfg[raw_num].dg_info.fe_sts.fe_done_sts);

		seq_printf(m, "[VI ISP_PIPE_%c]\n", raw_num == ISP_PRERAW_A ? 'A' : 'B');
		seq_printf(m, "VIOutImgWidth\t\t:%4d\n", ctx->isp_pipe_cfg[raw_num].post_img_w);
		seq_printf(m, "VIOutImgHeight\t\t:%4d\n", ctx->isp_pipe_cfg[raw_num].post_img_h);
		seq_printf(m, "VIInImgWidth\t\t:%4d\n", ctx->isp_pipe_cfg[raw_num].csibdg_width);
		seq_printf(m, "VIInImgHeight\t\t:%4d\n", ctx->isp_pipe_cfg[raw_num].csibdg_height);

		if (raw_num == ISP_PRERAW_A) {
			seq_printf(m, "VIDevFPS\t\t:%4d\n", sofCnt2 - sofCnt1);
			seq_printf(m, "VIFPS\t\t\t:%4d\n", frmCnt2 - frmCnt1);
		} else {
			seq_printf(m, "VIDevFPS\t\t:%4d\n", sofCnt2_b - sofCnt1_b);
			seq_printf(m, "VIFPS\t\t\t:%4d\n", frmCnt2_b - frmCnt1_b);
		}

		seq_printf(m, "VISofCh0Cnt\t\t:%4d\n", vdev->pre_fe_sof_cnt[raw_num][ISP_FE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
			seq_printf(m, "VISofCh1Cnt\t\t:%4d\n", vdev->pre_fe_sof_cnt[raw_num][ISP_FE_CH1]);

		seq_printf(m, "VIPreFECh0Cnt\t\t:%4d\n", vdev->pre_fe_frm_num[raw_num][ISP_FE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
			seq_printf(m, "VIPreFECh1Cnt\t\t:%4d\n", vdev->pre_fe_frm_num[raw_num][ISP_FE_CH1]);

		seq_printf(m, "VIPreBECh0Cnt\t\t:%4d\n", vdev->pre_be_frm_num[raw_num][ISP_BE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
			seq_printf(m, "VIPreBECh1Cnt\t\t:%4d\n", vdev->pre_be_frm_num[raw_num][ISP_BE_CH1]);
		seq_printf(m, "VIPostCnt\t\t:%4d\n", vdev->postraw_frame_number[raw_num]);

		seq_printf(m, "VIPreBEAwbCh0Cnt\t:%4d\n", vdev->pre_be_awb_frm_num[raw_num][ISP_BE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
			seq_printf(m, "VIPreBEAwbCh1Cnt\t:%4d\n", vdev->pre_be_awb_frm_num[raw_num][ISP_BE_CH1]);

		seq_printf(m, "[VI ISP_PIPE_%c Csi_Dbg_Info]\n", raw_num == ISP_PRERAW_A ? 'A' : 'B');
		seq_printf(m, "VICsiIntStatus0\t\t:0x%x\n", ctx->isp_pipe_cfg[raw_num].dg_info.bdg_int_sts_0);
		seq_printf(m, "VICsiIntStatus1\t\t:0x%x\n", ctx->isp_pipe_cfg[raw_num].dg_info.bdg_int_sts_1);
		seq_printf(m, "VICsiCh0Dbg\t\t:0x%x\n", ctx->isp_pipe_cfg[raw_num].dg_info.bdg_chn_debug[ISP_FE_CH0]);
		seq_printf(m, "VICsiCh1Dbg\t\t:0x%x\n", ctx->isp_pipe_cfg[raw_num].dg_info.bdg_chn_debug[ISP_FE_CH1]);
		seq_printf(m, "VICsiOverFlowCnt\t:%4d\n", ctx->isp_pipe_cfg[raw_num].dg_info.bdg_fifo_of_cnt);

		seq_printf(m, "VICsiCh0WidthGTCnt\t:%4d\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_gt_cnt[ISP_FE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			seq_printf(m, "VICsiCh1WidthGTCnt\t:%4d\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_gt_cnt[ISP_FE_CH1]);
		}

		seq_printf(m, "VICsiCh0WidthLSCnt\t:%4d\n",
					ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_ls_cnt[ISP_FE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			seq_printf(m, "VICsiCh1WidthLSCnt\t:%4d\n",
						ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_ls_cnt[ISP_FE_CH1]);
		}

		seq_printf(m, "VICsiCh0HeightGTCnt\t:%4d\n",
						ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_gt_cnt[ISP_FE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			seq_printf(m, "VICsiCh1HeightGTCnt\t:%4d\n",
						ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_gt_cnt[ISP_FE_CH1]);
		}

		seq_printf(m, "VICsiCh0HeightLSCnt\t:%4d\n",
						ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_ls_cnt[ISP_FE_CH0]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			seq_printf(m, "VICsiCh1HeightLSCnt\t:%4d\n",
							ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_ls_cnt[ISP_FE_CH1]);
		}
	}
}

static int vi_dbg_proc_show(struct seq_file *m, void *v)
{
	//struct cvi_isp_vdev *isp_vdev = m->private;

	if (proc_isp_mode == 0)
		_vi_dbg_proc_show(m, v);
#if 0
	else
		isp_register_dump(&isp_vdev->ctx, m, proc_isp_mode);
#endif
	return 0;
}

static ssize_t vi_dbg_proc_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
{
	if (kstrtoint(user_buf, 10, &proc_isp_mode))
		proc_isp_mode = 0;
	return count;
}

static int vi_dbg_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, vi_dbg_proc_show, PDE_DATA(inode));
}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
static const struct proc_ops vi_dbg_proc_fops = {
	.proc_open = vi_dbg_proc_open,
	.proc_read = seq_read,
	.proc_write = vi_dbg_proc_write,
	.proc_lseek = seq_lseek,
	.proc_release = single_release,
};
#else
static const struct file_operations vi_dbg_proc_fops = {
	.owner = THIS_MODULE,
	.open = vi_dbg_proc_open,
	.read = seq_read,
	.write = vi_dbg_proc_write,
	.llseek = seq_lseek,
	.release = single_release,
};
#endif

/*************************************************************************
 *	General functions
 *************************************************************************/
int isp_create_instance(struct platform_device *pdev)
{
	int rc = 0;
	struct cvi_vip_dev *bdev;
	struct video_device *vfd;
	struct cvi_isp_vdev *vdev;
	struct vb2_queue *q;
	u8 i = 0;

	bdev = dev_get_drvdata(&pdev->dev);
	if (!bdev) {
		vip_pr(CVI_ERR, "invalid data\n");
		return -EINVAL;
	}
	vdev = &bdev->isp_vdev;
	vdev->fmt = cvi_vip_get_format(V4L2_PIX_FMT_NV12M);
	vdev->vid_caps = V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_STREAMING;
	spin_lock_init(&vdev->rdy_lock);

	vfd = &(vdev->vdev);
	snprintf(vfd->name, sizeof(vfd->name), "vip-isp");
	vfd->fops = &cvi_isp_fops;
	vfd->ioctl_ops = &cvi_isp_ioctl_ops;
	vfd->vfl_dir = VFL_DIR_RX;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	vfd->vfl_type = VFL_TYPE_VIDEO;
#else
	vfd->vfl_type = VFL_TYPE_GRABBER;
#endif
	vfd->minor = -1;
	vfd->device_caps = vdev->vid_caps;
	vfd->release = video_device_release_empty;
	vfd->v4l2_dev = &bdev->v4l2_dev;
	vfd->queue = &vdev->vb_q;

	// vb2_queue init
	q = &vdev->vb_q;
	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
	q->io_modes = VB2_USERPTR;
	q->buf_struct_size = sizeof(struct cvi_vip_buffer);
	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
	q->min_buffers_needed = 0;
	q->drv_priv = vdev;
	q->dev = bdev->v4l2_dev.dev;
	q->ops = &cvi_isp_qops;
	q->mem_ops = &cvi_isp_vb2_mem_ops;
	//q->lock = &vdev->mutex;
	rc = vb2_queue_init(q);
	if (rc) {
		dprintk(VIP_ERR, "vb2_queue_init failed, ret=%d\n", rc);
		return rc;
	}
#if 0
	for (i = 0; i < 2; i++) {
		INIT_LIST_HEAD(&vdev->rdy_queue[i]);
		vdev->num_rdy[i] = 0;
	}
#endif
	for (i = 0; i < ISP_FE_CHN_MAX; i++) {
		INIT_LIST_HEAD(&vdev->qbuf_list[i]);
		vdev->qbuf_num[i] = 0;
	}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	rc = video_register_device(vfd, VFL_TYPE_VIDEO, ISP_DEVICE_IDX);
#else
	rc = video_register_device(vfd, VFL_TYPE_GRABBER, ISP_DEVICE_IDX);
#endif
	if (rc) {
		vip_pr(CVI_ERR, "Failed to register isp-device\n");
		goto err_register;
	}

	vfd->lock = &bdev->mutex;
	video_set_drvdata(vfd, vdev);

	isp_init_param(vdev);

	vdev->shared_mem = kzalloc(VI_SHARE_MEM_SIZE, GFP_ATOMIC);
	if (!vdev->shared_mem)
		return -ENOMEM;

	if (vi_proc_init(&bdev->isp_vdev, vdev->shared_mem) < 0)
		pr_err("vi proc init failed\n");

	if (proc_create_data(VI_DBG_PROC_NAME, 0644, NULL, &vi_dbg_proc_fops, &bdev->isp_vdev) == NULL)
		dprintk(VIP_ERR, "vi dbg proc creation failed\n");

	if (isp_proc_init(&bdev->isp_vdev) < 0)
		pr_err("isp proc init failed\n");

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		vdev->isp_int_flag[i]		= false;
		init_waitqueue_head(&vdev->isp_int_wait_q[i]);
	}

	for (i = 0; i < ARRAY_SIZE(CLK_ISP_NAME); ++i) {
		vdev->isp_clk[i] = devm_clk_get(&pdev->dev, CLK_ISP_NAME[i]);
		if (IS_ERR(vdev->isp_clk[i])) {
			vip_pr(CVI_ERR, "Cannot get clk for %s\n", CLK_ISP_NAME[i]);
			vdev->isp_clk[i] = NULL;
		}
	}

	for (i = 0; i < ARRAY_SIZE(CLK_MAC_NAME); ++i) {
		vdev->mac_clk[i] = devm_clk_get(&pdev->dev, CLK_MAC_NAME[i]);
		if (IS_ERR(vdev->mac_clk[i])) {
			vip_pr(CVI_ERR, "Cannot get clk for %s\n", CLK_MAC_NAME[i]);
			vdev->mac_clk[i] = NULL;
		}
	}

	for (i = 0; i < ISP_PRERAW_MAX; i++)
		sync_task_init(i);

	tasklet_init(&vdev->job_work, isp_post_tasklet, (unsigned long)vdev);

	vip_pr(CVI_INFO, "isp registered as %s\n",
		video_device_node_name(vfd));
	return rc;

err_register:
	return rc;
}

int isp_destroy_instance(struct platform_device *pdev)
{
	struct cvi_vip_dev *bdev;
	struct cvi_isp_vdev *vdev;
	int i;

	bdev = dev_get_drvdata(&pdev->dev);
	if (!bdev) {
		dprintk(VIP_ERR, "invalid data\n");
		return -EINVAL;
	}
	vdev = &bdev->isp_vdev;

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		if (ptr[i] != NULL)
			kfree(ptr[i]);
	}

	vi_proc_remove();
	kfree(vdev->shared_mem);
	remove_proc_entry(VI_DBG_PROC_NAME, NULL);
	isp_proc_remove();

	isp_pre_th = NULL;
	isp_err_handler_th = NULL;

	for (i = 0; i < ISP_PRERAW_MAX; i++) {
		sync_task_exit(i);
		kfree(isp_bufpool[i].fswdr_rpt);
		isp_bufpool[i].fswdr_rpt = 0;
	}

	tasklet_kill(&vdev->job_work);

	return 0;
}

void _isp_v4l2_event_queue(
	struct cvi_isp_vdev *vdev, const u32 type, const u32 frame_num)
{
	struct v4l2_event event = {
		.type = type,
		.u.frame_sync.frame_sequence = frame_num,
	};

	v4l2_event_queue(&vdev->vdev, &event);
}

static int _pre_be_outbuf_enque(
	struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num,
	const u8 hw_chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;

	if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB sensor
		struct isp_queue *be_out_q = (hw_chn_num == ISP_BE_CH0) ? &pre_be_out_q : &pre_be_out_se_q;
		enum ISP_BLK_ID_T pre_be_dma = (hw_chn_num == ISP_BE_CH0) ? ISP_BLK_ID_WDMA24 : ISP_BLK_ID_WDMA25;
		struct isp_buffer *b = NULL;

		b = isp_next_buf(be_out_q);
		if (!b) {
			vip_pr(CVI_DBG, "pre_be chn_num_%d outbuf is empty\n", hw_chn_num);
			return 0;
		}

		ispblk_dma_setaddr(ctx, pre_be_dma, b->addr);
		if (ctx->isp_pipe_cfg[raw_num].is_rgbir_sensor) {
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA14, isp_bufpool[raw_num].ir_le[b->ir_idx]);
			if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
				ispblk_dma_config(ctx, ISP_BLK_ID_WDMA15, isp_bufpool[raw_num].ir_se[b->ir_idx]);
		}
	} else if (ctx->is_dual_sensor &&
		   ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB+YUV sensor
		u8 buf_chn = vdev->ctx.rawb_chnstr_num + hw_chn_num;
		u32 dma = (buf_chn == ctx->rawb_chnstr_num) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7;
		struct isp_queue *fe_out_q = &pre_out_queue[buf_chn];

		struct isp_buffer *b = NULL;

		b = isp_next_buf(fe_out_q);
		if (!b) {
			vip_pr(CVI_DBG, "pre_fe_%d buf_chn_num_%d outbuf is empty\n", raw_num, buf_chn);
			return 0;
		}

		ispblk_dma_setaddr(ctx, dma, b->addr);
	}

	return 1;
}

static int _pre_fe_outbuf_enque(
	struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num,
	const enum cvi_isp_pre_chn_num fe_chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;

	if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB sensor
		struct isp_queue *fe_out_q = (fe_chn_num == ISP_FE_CH0) ?
						&pre_out_queue[raw_num] : &pre_out_se_queue[raw_num];
		enum ISP_BLK_ID_T pre_fe_dma = (raw_num == ISP_PRERAW_A) ?
						((fe_chn_num == ISP_FE_CH0) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA1) :
						((fe_chn_num == ISP_FE_CH0) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7);
		struct isp_buffer *b = NULL;
		u8 trigger = false;

		if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 1) {//raw_dump flow
			if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
				trigger = vdev->pre_fe_frm_num[raw_num][ISP_FE_CH0] ==
						vdev->pre_fe_frm_num[raw_num][ISP_FE_CH1];
			} else {
				trigger = true;
			}

			if (trigger) {
				struct isp_buffer *b_se = NULL;
				struct isp_queue *fe_out_q = &raw_dump_b_q[raw_num];
				u32 dmaid = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA6;
				u32 dmaid_se = (raw_num == ISP_PRERAW_A) ? ISP_BLK_ID_WDMA1 : ISP_BLK_ID_WDMA7;

				vip_pr(CVI_DBG, "pre_fe raw_dump cfg start\n");

				b = isp_next_buf(fe_out_q);
				if (b == NULL) {
					vip_pr(CVI_ERR, "Pre_fe_%d LE raw_dump outbuf is empty\n", raw_num);
					return 0;
				}

				ispblk_dma_config(ctx, dmaid, b->addr);

				if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
					struct isp_queue *fe_out_q_se = &raw_dump_b_se_q[raw_num];

					b_se = isp_next_buf(fe_out_q_se);
					if (b_se == NULL) {
						vip_pr(CVI_ERR, "Pre_fe_%d SE raw_dump outbuf is empty\n", raw_num);
						return 0;
					}

					ispblk_dma_config(ctx, dmaid_se, b_se->addr);
				}

				atomic_set(&vdev->isp_raw_dump_en[raw_num], 2);
			}
		} else {

			b = isp_next_buf(fe_out_q);
			if (!b) {
				vip_pr(CVI_DBG, "pre_fe_%d chn_num_%d outbuf is empty\n", raw_num, fe_chn_num);
				return 0;
			}

			ispblk_dma_setaddr(ctx, pre_fe_dma, b->addr);
		}
	} else if (ctx->is_dual_sensor &&
		   ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB+YUV sensor
		u8 buf_chn = vdev->ctx.rawb_chnstr_num + fe_chn_num;
		u32 dma = (buf_chn == ctx->rawb_chnstr_num) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7;
		struct isp_queue *fe_out_q = &pre_out_queue[buf_chn];

		struct isp_buffer *b = NULL;

		b = isp_next_buf(fe_out_q);
		if (!b) {
			vip_pr(CVI_DBG, "pre_fe_%d buf_chn_num_%d outbuf is empty\n", raw_num, buf_chn);
			return 0;
		}

		ispblk_dma_setaddr(ctx, dma, b->addr);
	}

	return 1;
}

static int _postraw_inbuf_enq_check(struct cvi_isp_vdev *vdev,
						enum cvi_isp_raw *raw_num,
						enum cvi_isp_chn_num *chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct isp_queue *in_q = NULL, *in_se_q = NULL;
	struct isp_buffer *b = NULL, *b_se = NULL;
	int ret = 0;

	if (_is_fe_be_online(ctx)) { //fe->be->dram->post
		in_q = &post_in_queue;
	} else { //fe->dram->be->post
		in_q = &pre_be_in_q;
	}

	b = isp_next_buf(in_q);
	if (b == NULL) {
		if (_is_fe_be_online(ctx)) //fe->be->dram->post
			vip_pr(CVI_DBG, "Postraw input buf is empty\n");
		else
			vip_pr(CVI_DBG, "Pre_be input buf is empty\n");
		ret = 1;
		return ret;
	}

	*raw_num = b->raw_num;
	*chn_num = (b->is_yuv_frm) ? b->chn_num : b->raw_num;

	vdev->ctx.isp_pipe_cfg[b->raw_num].crop.x = b->crop_le.x;
	vdev->ctx.isp_pipe_cfg[b->raw_num].crop.y = b->crop_le.y;
	vdev->ctx.isp_pipe_cfg[b->raw_num].crop.w = vdev->ctx.img_width =
							ctx->isp_pipe_cfg[b->raw_num].post_img_w;
	vdev->ctx.isp_pipe_cfg[b->raw_num].crop.h = vdev->ctx.img_height =
							ctx->isp_pipe_cfg[b->raw_num].post_img_h;

	//YUV sensor, offline return error, online than config rawtop read dma.
	if (ctx->isp_pipe_cfg[b->raw_num].is_yuv_bypass_path) {
		if (ctx->isp_pipe_cfg[b->raw_num].is_offline_scaler) {
			ret = 1;
		} else {
			ispblk_dma_yuv_bypass_config(ctx, ISP_BLK_ID_RDMA5, b->addr, b->raw_num);
		}

		return ret;
	}

	isp_bufpool[b->raw_num].post_ir_busy_idx = b->ir_idx;

	if (_is_fe_be_online(ctx)) { //fe->be->dram->post
		in_se_q = &post_in_se_queue;
	} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
		in_se_q = &pre_be_in_se_q[b->raw_num];
	}

	if (ctx->isp_pipe_cfg[b->raw_num].is_hdr_on) {
		b_se = isp_next_buf(in_se_q);
		if (b_se == NULL) {
			if (_is_fe_be_online(ctx)) //fe->be->dram->post
				vip_pr(CVI_DBG, "Postraw se input buf is empty\n");
			else //fe->dram->be->post
				vip_pr(CVI_DBG, "Pre_be se input buf is empty\n");
			ret = 1;
			return ret;
		}
	}

	if ((ctx->is_dual_sensor) && (!ctx->isp_pipe_cfg[b->raw_num].is_yuv_bypass_path)) {
		if ((tuning_dis[0] > 0) && ((tuning_dis[0] - 1) != b->raw_num)) {
			vip_pr(CVI_DBG, "input buf is not equal to current tuning number\n");

			if (_is_fe_be_online(ctx)) { //fe->be->dram->post
				b = isp_buf_remove(in_q);
				isp_buf_queue(&pre_be_out_q, b);
			} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
				b = isp_buf_remove(in_q);
				isp_buf_queue(&pre_out_queue[*chn_num], b);
			}

			if (ctx->isp_pipe_cfg[b->raw_num].is_hdr_on) {
				if (_is_fe_be_online(ctx)) { //fe->be->dram->post
					b_se = isp_buf_remove(in_se_q);
					isp_buf_queue(&pre_be_out_se_q, b_se);
				} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
					b_se = isp_buf_remove(in_se_q);
					isp_buf_queue(&pre_out_se_queue[*chn_num], b_se);
				}
			}

			ret = 1;
			return ret;
		}
	}

	vdev->ctx.isp_pipe_cfg[b->raw_num].rgbmap_i.w_bit = b->rgbmap_i.w_bit;
	vdev->ctx.isp_pipe_cfg[b->raw_num].rgbmap_i.h_bit = b->rgbmap_i.h_bit;

	vdev->ctx.isp_pipe_cfg[b->raw_num].lmap_i.w_bit = b->lmap_i.w_bit;
	vdev->ctx.isp_pipe_cfg[b->raw_num].lmap_i.h_bit = b->lmap_i.h_bit;

	if (_is_fe_be_online(ctx)) { //fe->be->dram->post

		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA5, b->addr);
		if (ctx->isp_pipe_cfg[b->raw_num].is_hdr_on) {
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.x = b_se->crop_se.x;
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.y = b_se->crop_se.y;
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.w = vdev->ctx.img_width;
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.h = vdev->ctx.img_height;

			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA6, b_se->addr);
		}
	} else { //fe->dram->be->post

		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA4, b->addr);
		if (ctx->isp_pipe_cfg[b->raw_num].is_hdr_on) {
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.x = b_se->crop_se.x;
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.y = b_se->crop_se.y;
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.w = vdev->ctx.img_width;
			vdev->ctx.isp_pipe_cfg[b->raw_num].crop_se.h = vdev->ctx.img_height;

			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA18, b_se->addr);
		}
	}

	return ret;
}

static void _postraw_outbuf_enque(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	struct cvi_vip_buffer2 *vb2_buf;
	struct cvi_isp_buf2 *b = NULL;
	struct isp_ctx *ctx = &vdev->ctx;
	u64 tmp_addr = 0, i;

	//Get the buffer for postraw output buffer
	b = _cvi_isp_next_buf2(vdev, raw_num);
	vb2_buf = &b->buf;

	vip_pr(CVI_DBG, "update isp-buf: 0x%llx-0x%llx\n",
		vb2_buf->planes[0].addr, vb2_buf->planes[1].addr);

	for (i = 0; i < 2; i++) {
		tmp_addr = (u64)vb2_buf->planes[i].addr;
		ispblk_dma_config(ctx, ISP_BLK_ID_WDMA30 + i, tmp_addr);
	}
}

static u8 _postraw_outbuf_empty(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	u8 ret = 0;

	if (cvi_isp_rdy_buf_empty2(vdev, raw_num)) {
		vip_pr(CVI_DBG, "postraw chn_%d output buffer is empty\n", raw_num);
		ret = 1;
	}

	return ret;
}

void _postraw_outbuf_enq(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	cvi_isp_rdy_buf_pop2(vdev, raw_num);
	_postraw_outbuf_enque(vdev, raw_num);
}

/*
 * for postraw offline only.
 *  trig preraw if there is output buffer in preraw output.
 */
void _pre_hw_enque(
	struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num,
	const u8 chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;

	//ISP frame error handling
	if (atomic_read(&vdev->isp_err_handle_flag) == 1)
		return;

	if (atomic_read(&vdev->isp_streamoff) == 0) {
		if (_is_fe_be_online(ctx)) { //fe->be->dram->post
			if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB sensor
				if (atomic_cmpxchg(&vdev->pre_be_state[chn_num],
							ISP_PRE_BE_IDLE, ISP_PRE_BE_RUNNING) ==
							ISP_PRE_BE_RUNNING) {
					vip_pr(CVI_DBG, "Pre_be chn_num_%d is running\n", chn_num);
					return;
				}
			} else { //YUV sensor
				if (atomic_cmpxchg(&vdev->pre_fe_state[raw_num][chn_num],
							ISP_PRERAW_IDLE, ISP_PRERAW_RUNNING) ==
							ISP_PRERAW_RUNNING) {
					vip_pr(CVI_DBG, "Pre_fe_%d chn_num_%d is running\n", raw_num, chn_num);
					return;
				}
			}

			// only if fe->be->dram
			if (_pre_be_outbuf_enque(vdev, raw_num, chn_num)) {
				if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 1) //raw_dump flow
					_isp_fe_be_raw_dump_cfg(vdev, raw_num, chn_num);
				isp_pre_trig(ctx, raw_num, chn_num);
			} else {
				if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) //RGB sensor
					atomic_set(&vdev->pre_be_state[chn_num], ISP_PRE_BE_IDLE);
				else  //YUV sensor
					atomic_set(&vdev->pre_fe_state[raw_num][chn_num], ISP_PRERAW_IDLE);
			}
		} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
			if (atomic_cmpxchg(&vdev->pre_fe_state[raw_num][chn_num],
						ISP_PRERAW_IDLE, ISP_PRERAW_RUNNING) ==
						ISP_PRERAW_RUNNING) {
				vip_pr(CVI_DBG, "Pre_fe_%d chn_num_%d is running\n", raw_num, chn_num);
				return;
			}

			// only if fe->dram
			if (_pre_fe_outbuf_enque(vdev, raw_num, chn_num))
				isp_pre_trig(ctx, raw_num, chn_num);
			else
				atomic_set(&vdev->pre_fe_state[raw_num][chn_num], ISP_PRERAW_IDLE);
		} else if (_is_all_online(ctx)) {
			if (atomic_cmpxchg(&vdev->postraw_state, ISP_POSTRAW_IDLE, ISP_POSTRAW_RUNNING)
						!= ISP_POSTRAW_IDLE) {
				vip_pr(CVI_DBG, "Postraw is running\n");
				return;
			}

			if (ctx->isp_pipe_cfg[raw_num].is_offline_scaler) { //Scaler onffline mode
				if (_postraw_outbuf_empty(vdev, raw_num)) {
					atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
					return;
				}

				_postraw_outbuf_enq(vdev, raw_num);
			}

			if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 1) //raw_dump flow
				_isp_fe_be_raw_dump_cfg(vdev, raw_num, chn_num);

			isp_pre_trig(ctx, raw_num, chn_num);
		}
	}
}

static void _pre_fe_tuning_update(
	struct cvi_isp_vdev *vdev,
	struct cvi_vip_isp_fe_tun_cfg *fe_tun,
	enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 idx = 0;
	static int stop_update = -1;

	if (tuning_dis[1]) {
		if (stop_update > 0)
			return;
		else if (tuning_dis[0] == 0) {
			stop_update = 1;
			return;
		} else if ((tuning_dis[0] - 1) == raw_num)
			stop_update = 1; // stop on next
	} else
		stop_update = 0;

	for (idx = 0; idx < 4; idx++) {
		struct cvi_vip_isp_blc_config	*blc_cfg;
		struct cvi_vip_isp_lscr_config	*lscr_cfg;
		struct cvi_vip_isp_wbg_config	*wbg_cfg;

		if (idx < 2) {
			blc_cfg  = &fe_tun->blc_cfg[idx];
			lscr_cfg = &fe_tun->lscr_cfg[idx];

			ispblk_blc_tun_cfg(ctx, blc_cfg, raw_num);
			ispblk_lscr_tun_cfg(ctx, lscr_cfg, raw_num);
		}

		wbg_cfg = &fe_tun->wbg_cfg[idx];
		ispblk_wbg_tun_cfg(ctx, wbg_cfg, raw_num);
	}
}

static void _pre_be_tuning_update(
	struct cvi_isp_vdev *vdev,
	struct cvi_vip_isp_be_tun_cfg *be_tun,
	enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 idx = 0;
	static int stop_update = -1;

	if (tuning_dis[2]) {
		if (stop_update > 0)
			return;
		else if (tuning_dis[0] == 0) {
			stop_update = 1;
			return;
		} else if ((tuning_dis[0] - 1) == raw_num)
			stop_update = 1; // stop on next
	} else
		stop_update = 0;

	for (idx = 0; idx < 4; idx++) {
		struct cvi_vip_isp_blc_config	*blc_cfg;
		struct cvi_vip_isp_dpc_config	*dpc_cfg;
		struct cvi_vip_isp_lscr_config	*lscr_cfg;
		struct cvi_vip_isp_ae_config	*ae_cfg;
		struct cvi_vip_isp_ge_config	*ge_cfg;
		struct cvi_vip_isp_wbg_config	*wbg_cfg;

		if (idx < 2) {
			blc_cfg = &be_tun->blc_cfg[idx];
			dpc_cfg = &be_tun->dpc_cfg[idx];
			lscr_cfg = &be_tun->lscr_cfg[idx];
			ae_cfg = &be_tun->ae_cfg[idx];
			ge_cfg = &be_tun->ge_cfg[idx];

			ispblk_blc_tun_cfg(ctx, blc_cfg, raw_num);
			ispblk_dpc_tun_cfg(ctx, dpc_cfg, raw_num);
			ispblk_lscr_tun_cfg(ctx, lscr_cfg, raw_num);
			ispblk_ae_tun_cfg(ctx, ae_cfg, raw_num);
			ispblk_ge_tun_cfg(ctx, ge_cfg, raw_num);
		}

		wbg_cfg = &be_tun->wbg_cfg[idx];
		ispblk_wbg_tun_cfg(ctx, wbg_cfg, raw_num);
	}

	BE_RUNTIME_TUN(preproc);
	BE_RUNTIME_TUN(af);
	BE_RUNTIME_TUN(awb);
	BE_RUNTIME_TUN(gms);
}

static void _postraw_tuning_update(
	struct cvi_isp_vdev *vdev,
	struct cvi_vip_isp_post_tun_cfg *post_tun,
	enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 idx = 0;
	static int stop_update = -1;

	if (tuning_dis[3]) {
		if (stop_update > 0)
			return;
		else if (tuning_dis[0] == 0) {
			stop_update = 1;
			return;
		} else if ((tuning_dis[0] - 1) == raw_num)
			stop_update = 1; // stop on next
	} else
		stop_update = 0;

	POST_RUNTIME_TUN(bnr);
	POST_RUNTIME_TUN(demosiac);
	POST_RUNTIME_TUN(rgbcac);
	POST_RUNTIME_TUN(lsc);

	for (idx = 0; idx < 5; idx++) {
		struct cvi_vip_isp_ccm_config *cfg;

		cfg = &post_tun->ccm_cfg[idx];
		ispblk_ccm_tun_cfg(ctx, cfg, raw_num);
	}

	POST_RUNTIME_TUN(fswdr);
	POST_RUNTIME_TUN(drc);
	POST_RUNTIME_TUN(hist_edge_v);
	POST_RUNTIME_TUN(gamma);
	POST_RUNTIME_TUN(dhz);

	POST_RUNTIME_TUN(clut);
	POST_RUNTIME_TUN(csc);
	POST_RUNTIME_TUN(dci);
	POST_RUNTIME_TUN(cacp);
	POST_RUNTIME_TUN(preyee);

	POST_RUNTIME_TUN(tnr);
	POST_RUNTIME_TUN(ynr);
	POST_RUNTIME_TUN(cnr);
	POST_RUNTIME_TUN(cac);
	POST_RUNTIME_TUN(ee);
	POST_RUNTIME_TUN(ycur);
	POST_RUNTIME_TUN(ca2);

	{
		struct cvi_vip_isp_mono_config *cfg;
		static u8 mono_mode_sts[ISP_PRERAW_MAX];

		cfg = &post_tun->mono_cfg;
		ispblk_mono_tun_cfg(ctx, cfg, raw_num);

		if (cfg->force_mono_enable != mono_mode_sts[raw_num]) {
			isp_first_frm_reset(ctx, 1);
		} else {
			isp_first_frm_reset(ctx, 0);
		}

		mono_mode_sts[raw_num] = cfg->force_mono_enable;
	}
}

static inline void _swap_post_sts_buf(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num)
{
	struct _membuf *pool;
	unsigned long flags;
	uint8_t idx;

	pool = &isp_bufpool[raw_num];

	spin_lock_irqsave(&pool->post_sts_lock, flags);
	if (pool->post_sts_in_use == 1) {
		spin_unlock_irqrestore(&pool->post_sts_lock, flags);
		return;
	}
	pool->post_sts_busy_idx ^= 1;
	spin_unlock_irqrestore(&pool->post_sts_lock, flags);

	idx = pool->post_sts_busy_idx;

	//ispblk_dma_config(ctx, ISP_BLK_ID_WDMA22, pool->sts_mem[idx].awb_post.phy_addr);
	//dci dma is fixed size
	ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA27, pool->sts_mem[idx].dci.phy_addr);
	//hist edge v dma is fixed size
	ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA20, pool->sts_mem[idx].hist_edge_v.phy_addr);
}

static inline void _post_rgbmap_update(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num, const u32 frm_num)
{
	u64 rdma10, rdma11, rdma8, rdma9;
	u8 cur_idx = (frm_num - 1) % RGBMAP_BUF_IDX;
	u8 pre_idx = (frm_num - 1 + RGBMAP_BUF_IDX - ctx->rgbmap_prebuf_idx) % RGBMAP_BUF_IDX;

	rdma10 = isp_bufpool[raw_num].rgbmap_le[cur_idx];
	if (frm_num <= ctx->rgbmap_prebuf_idx)
		rdma8 = isp_bufpool[raw_num].rgbmap_le[0];
	else
		rdma8 = isp_bufpool[raw_num].rgbmap_le[pre_idx];

	ispblk_dma_setaddr(ctx, ISP_BLK_ID_RDMA10, rdma10);
	ispblk_dma_setaddr(ctx, ISP_BLK_ID_RDMA8, rdma8);

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
		rdma11 = isp_bufpool[raw_num].rgbmap_se[cur_idx];
		if (frm_num <= ctx->rgbmap_prebuf_idx)
			rdma9 = isp_bufpool[raw_num].rgbmap_se[0];
		else
			rdma9 = isp_bufpool[raw_num].rgbmap_se[pre_idx];

		ispblk_dma_setaddr(ctx, ISP_BLK_ID_RDMA11, rdma11);
		ispblk_dma_setaddr(ctx, ISP_BLK_ID_RDMA9, rdma9);
	}
}

static inline void _post_lmap_update(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num)
{
	u64 lmap_le = isp_bufpool[raw_num].lmap_le;
	u64 lmap_se = isp_bufpool[raw_num].lmap_se;

	ispblk_dma_config(ctx, ISP_BLK_ID_RDMA13, lmap_le);

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on && !ctx->isp_pipe_cfg[raw_num].is_hdr_detail_en)
		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA14, lmap_se);
	else
		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA14, lmap_le);
}

static inline void _post_mlsc_update(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num)
{
	uint64_t lsc_dma = isp_bufpool[raw_num].lsc;

	ispblk_dma_setaddr(ctx, ISP_BLK_ID_RDMA7, lsc_dma);
}

static inline void _post_ir_merge_update(struct isp_ctx *ctx, const enum cvi_isp_raw raw_num)
{
	u8 idx = isp_bufpool[raw_num].post_ir_busy_idx;

	if (_is_be_post_online(ctx)) { //fe->dram->be->post
		ispblk_dma_config(ctx, ISP_BLK_ID_WDMA14, isp_bufpool[raw_num].ir_le[idx]);
		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA15, isp_bufpool[raw_num].ir_se[idx]);
	}
	ispblk_dma_config(ctx, ISP_BLK_ID_RDMA15, isp_bufpool[raw_num].ir_le[idx]);
}

static inline void _post_dma_update(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	uint64_t manr_addr = isp_bufpool[raw_num].manr;
	u32 fbc_frm_num = vdev->postraw_frame_number[raw_num] % 2;
	uint64_t r_uv_addr, r_y_addr;
	uint64_t w_uv_addr, w_y_addr;

	if (ctx->is_fbc_on) {
		w_uv_addr = (fbc_frm_num == 0) ? isp_bufpool[raw_num].tdnr[0] : isp_bufpool[raw_num].tdnr[2];
		w_y_addr = (fbc_frm_num == 0) ? isp_bufpool[raw_num].tdnr[1] : isp_bufpool[raw_num].tdnr[3];
		r_uv_addr = (fbc_frm_num == 1) ? isp_bufpool[raw_num].tdnr[0] : isp_bufpool[raw_num].tdnr[2];
		r_y_addr = (fbc_frm_num == 1) ? isp_bufpool[raw_num].tdnr[1] : isp_bufpool[raw_num].tdnr[3];
	} else {
		r_uv_addr = w_uv_addr = isp_bufpool[raw_num].tdnr[0];
		r_y_addr  = w_y_addr  = isp_bufpool[raw_num].tdnr[1];
	}

	//Update rgbmap dma addr
	_post_rgbmap_update(ctx, raw_num, vdev->pre_fe_frm_num[raw_num][ISP_FE_CH0]);

	//update lmap dma
	_post_lmap_update(ctx, raw_num);

	//update mlsc dma
	_post_mlsc_update(ctx, raw_num);

	//update ir merge dma
	_post_ir_merge_update(ctx, raw_num);

	if (ctx->is_3dnr_on) {
		//3dnr y
		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA16, r_y_addr);
		ispblk_dma_config(ctx, ISP_BLK_ID_WDMA28, w_y_addr);

		//3dnr uv
		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA17, r_uv_addr);
		ispblk_dma_config(ctx, ISP_BLK_ID_WDMA29, w_uv_addr);

		//manr
		ispblk_dma_config(ctx, ISP_BLK_ID_RDMA12, manr_addr);
		ispblk_dma_config(ctx, ISP_BLK_ID_WDMA26, manr_addr);
	}
}

static inline void _post_ctrl_update(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;

	ispblk_post_cfg_update(ctx, raw_num);

	ispblk_fusion_hdr_cfg(ctx, raw_num);

	if (ctx->is_3dnr_on)
		ispblk_tnr_post_chg(ctx, raw_num);

	if (ctx->is_dual_sensor) {
		//To set apply the prev frm or not for manr/3dnr
		if (vdev->preraw_first_frm[raw_num]) {
			vdev->preraw_first_frm[raw_num] = false;
			isp_first_frm_reset(ctx, 1);
		} else {
			isp_first_frm_reset(ctx, 0);
		}
	}
}

static uint8_t _pre_be_sts_in_use_chk(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 chn_num)
{
	unsigned long flags;
	static u8 be_in_use;

	if (chn_num == ISP_BE_CH0) {
		spin_lock_irqsave(&isp_bufpool[raw_num].pre_be_sts_lock, flags);
		if (isp_bufpool[raw_num].pre_be_sts_in_use == 1) {
			be_in_use = 1;
		} else {
			be_in_use = 0;
			isp_bufpool[raw_num].pre_be_sts_busy_idx ^= 1;
		}
		spin_unlock_irqrestore(&isp_bufpool[raw_num].pre_be_sts_lock, flags);
	}

	return be_in_use;
}

static inline void _swap_pre_be_sts_buf(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct _membuf *pool;
	uint8_t idx;

	if (_pre_be_sts_in_use_chk(vdev, raw_num, chn_num) == 0) {
		pool = &isp_bufpool[raw_num];
		idx = isp_bufpool[raw_num].pre_be_sts_busy_idx;

		if (chn_num == ISP_BE_CH0) {
			//af dma
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA16, pool->sts_mem[idx].af.phy_addr);
			//gms dma
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA17, pool->sts_mem[idx].gms.phy_addr);
			//ae le dma
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA18, pool->sts_mem[idx].ae_le.phy_addr);
		}

		if (_is_fe_be_online(ctx)) { //fe->be->dram->post
			if (chn_num == ISP_BE_CH1) {
				//ae se dma
				ispblk_dma_config(ctx, ISP_BLK_ID_WDMA21, pool->sts_mem[idx].ae_se.phy_addr);
			}
		} else if (_is_be_post_online(ctx)) {//dram->be->post
			//ae se dma
			ispblk_dma_config(ctx, ISP_BLK_ID_WDMA21, pool->sts_mem[idx].ae_se.phy_addr);
		}
	}
}

static inline void _pre_be_ctrl_update(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u32 frm_num = vdev->pre_be_frm_num[raw_num][ISP_BE_CH0];

	ispblk_pre_be_cfg_update(ctx, raw_num);

	//AWB source change set by shadow update by U02 chip
	isp_be_awb_source_chg(ctx, raw_num, frm_num);
}

/*
 * - postraw offline -
 *  trig postraw if there is in/out buffer for postraw
 * - postraw online -
 *  trig preraw if there is output buffer for postraw
 */
static void _post_hw_enque(
	struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct cvi_vip_isp_post_cfg *post_cfg = NULL;
	struct cvi_vip_isp_be_cfg   *be_cfg = NULL;
	u8 tun_idx = 0;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	enum cvi_isp_chn_num chn_num = ISP_CHN0;

	if (atomic_read(&vdev->isp_streamoff) == 1)
		return;

	if (atomic_read(&vdev->isp_err_handle_flag) == 1)
		return;

	if (_is_fe_be_online(ctx)) { //fe->be->dram->post
		if (atomic_cmpxchg(&vdev->postraw_state, ISP_POSTRAW_IDLE, ISP_POSTRAW_RUNNING) != ISP_POSTRAW_IDLE) {
			vip_pr(CVI_DBG, "Postraw is running\n");
			return;
		}

		if (_postraw_inbuf_enq_check(vdev, &raw_num, &chn_num)) {
			atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
			return;
		}

		if (!ctx->isp_pipe_cfg[raw_num].is_offline_scaler) { //Scaler online mode
			struct sc_cfg_cb post_para;

			post_para.dev = container_of(vdev, struct cvi_vip_dev, isp_vdev);
			post_para.snr_num = raw_num;
			post_para.is_tile = (ctx->isp_pipe_cfg[raw_num].post_img_w > 2304) ? true : false;
			if (post_para.is_tile || (tile_en && !ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path)) {
				post_para.is_tile			= true;
				post_para.is_left_tile			= true;
				post_para.ol_tile_cfg.l_in.start	= ctx->tile_cfg.l_in.start;
				post_para.ol_tile_cfg.l_in.end		= ctx->tile_cfg.l_in.end;
				post_para.ol_tile_cfg.l_out.start	= ctx->tile_cfg.l_out.start;
				post_para.ol_tile_cfg.l_out.end		= ctx->tile_cfg.l_out.end;
				post_para.ol_tile_cfg.r_in.start	= ctx->tile_cfg.r_in.start;
				post_para.ol_tile_cfg.r_in.end		= ctx->tile_cfg.r_in.end;
				post_para.ol_tile_cfg.r_out.start	= ctx->tile_cfg.r_out.start;
				post_para.ol_tile_cfg.r_out.end		= ctx->tile_cfg.r_out.end;
			}

			if (cvi_sc_cfg_cb(&post_para) != 0) {
				atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
				return;
			}

			atomic_set(&vdev->ol_sc_frm_done, 0);
			ctx->is_tile = post_para.is_tile;
		} else { //Scaler offline mode
			if (_postraw_outbuf_empty(vdev, raw_num)) {
				atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
				return;
			}

			_postraw_outbuf_enq(vdev, raw_num);
		}

		ispblk_post_yuv_cfg_update(ctx, raw_num);

		if (ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) //YUV sensor online mode
			goto YUV_POSTRAW_TILE;

		post_cfg = (struct cvi_vip_isp_post_cfg *)tuning_buf_addr.post_vir[raw_num];
		tun_idx  = post_cfg->tun_idx;

		vip_pr(CVI_DBG, "Postraw_%d tuning update(%d):idx(%d)\n",
				raw_num, post_cfg->tun_update[tun_idx], tun_idx);
		if ((tun_idx < TUNING_NODE_NUM) && (post_cfg->tun_update[tun_idx] == 1))
			_postraw_tuning_update(vdev, &post_cfg->tun_cfg[tun_idx], raw_num);

		//Update postraw size/ctrl flow
		_post_ctrl_update(vdev, raw_num);
		//Update postraw dma size/addr
		_post_dma_update(vdev, raw_num);
		//Update postraw stt awb/dci/hist_edge_v dma size/addr
		_swap_post_sts_buf(ctx, raw_num);

		if (ctx->is_tile)
			_isp_left_tile(vdev, raw_num);
#if 0
		if (ctx->is_3dnr_on && ctx->is_fbc_on && vdev->postraw_frame_number[raw_num] == 0) {
			ispblk_fbcd_enable(ctx, false);
		} else if (ctx->is_3dnr_on && ctx->is_fbc_on && vdev->postraw_frame_number[raw_num] == 1) {
			ispblk_fbcd_enable(ctx, true);
			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA16, 0);
			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA17, 0);
		}
#endif
YUV_POSTRAW_TILE:
		vdev->offline_raw_num = raw_num;

		ctx->cam_id = raw_num;

		isp_post_trig(ctx, raw_num);
#ifdef ISP_PERF_MEASURE
		if (vdev->postraw_frame_number[ISP_PRERAW_A] < ISP_MEASURE_FRM) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
			struct timespec64 ts;

			ktime_get_real_ts64(&ts);

			time_chk.post_trig[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_sec = ts.tv_sec;
			time_chk.post_trig[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_nsec = ts.tv_nsec;
#else
			struct timeval tv;

			do_gettimeofday(&tv);

			time_chk.post_trig[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_sec = tv.tv_sec;
			time_chk.post_trig[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_usec = tv.tv_usec;
#endif
		}
#endif
	} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
		if (atomic_cmpxchg(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE, ISP_PRE_BE_RUNNING)
										!= ISP_PRE_BE_IDLE) {
			vip_pr(CVI_DBG, "Pre_be ch_num_%d is running\n", ISP_BE_CH0);
			return;
		}

		if (atomic_cmpxchg(&vdev->postraw_state, ISP_POSTRAW_IDLE, ISP_POSTRAW_RUNNING) != ISP_POSTRAW_IDLE) {
			atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);
			vip_pr(CVI_DBG, "Postraw is running\n");
			return;
		}

		if (_postraw_inbuf_enq_check(vdev, &raw_num, &chn_num)) {
			atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);
			atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
			return;
		}

		if (!ctx->isp_pipe_cfg[raw_num].is_offline_scaler) { //Scaler online mode
			struct sc_cfg_cb post_para;

			post_para.dev = container_of(vdev, struct cvi_vip_dev, isp_vdev);
			post_para.snr_num = chn_num;
			post_para.is_tile = false;
			if (cvi_sc_cfg_cb(&post_para) != 0) {
				vip_pr(CVI_INFO, "snr_num_%d, SC is running\n", raw_num);
				atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);
				atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
				return;
			}

			atomic_set(&vdev->ol_sc_frm_done, 0);
		} else { //Scaler offline mode
			if (_postraw_outbuf_empty(vdev, raw_num)) {
				atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);
				atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
				return;
			}

			_postraw_outbuf_enq(vdev, raw_num);
		}

		ispblk_post_yuv_cfg_update(ctx, raw_num);

		if (ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) //YUV sensor online mode
			goto YUV_POSTRAW;

		be_cfg = (struct cvi_vip_isp_be_cfg *)tuning_buf_addr.be_vir[raw_num];
		tun_idx  = be_cfg->tun_idx;

		vip_pr(CVI_DBG, "Pre_be_%d tuning update(%d):idx(%d)\n",
				raw_num, be_cfg->tun_update[tun_idx], tun_idx);
		if ((tun_idx < TUNING_NODE_NUM) && (be_cfg->tun_update[tun_idx] == 1))
			_pre_be_tuning_update(vdev, &be_cfg->tun_cfg[tun_idx], raw_num);

		//Update pre be size/ctrl flow
		_pre_be_ctrl_update(vdev, raw_num);
		//Update pre be sts size/addr
		_swap_pre_be_sts_buf(vdev, raw_num, ISP_BE_CH0);

		post_cfg = (struct cvi_vip_isp_post_cfg *)tuning_buf_addr.post_vir[raw_num];
		tun_idx  = post_cfg->tun_idx;

		vip_pr(CVI_DBG, "Postraw_%d tuning update(%d):idx(%d)\n",
				raw_num, post_cfg->tun_update[tun_idx], tun_idx);
		if ((tun_idx < TUNING_NODE_NUM) && (post_cfg->tun_update[tun_idx] == 1))
			_postraw_tuning_update(vdev, &post_cfg->tun_cfg[tun_idx], raw_num);

		//Update postraw size/ctrl flow
		_post_ctrl_update(vdev, raw_num);
		//Update postraw dma size/addr
		_post_dma_update(vdev, raw_num);
		//Update postraw sts awb/dci/hist_edge_v dma size/addr
		_swap_post_sts_buf(ctx, raw_num);
#if 0
		if (ctx->is_3dnr_on && ctx->is_fbc_on && vdev->postraw_frame_number[raw_num] == 0) {
			ispblk_fbcd_enable(ctx, false);
		} else if (ctx->is_3dnr_on && ctx->is_fbc_on && vdev->postraw_frame_number[raw_num] == 1) {
			ispblk_fbcd_enable(ctx, true);
			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA16, 0);
			ispblk_dma_config(ctx, ISP_BLK_ID_RDMA17, 0);
		}
#endif
YUV_POSTRAW:
		vdev->offline_raw_num = raw_num;

		ctx->cam_id = raw_num;

		isp_post_trig(ctx, raw_num);
	} else if (_is_all_online(ctx)) { //on-the-fly

		if (atomic_read(&vdev->postraw_state) == ISP_POSTRAW_RUNNING)
			return;

		if (!ctx->isp_pipe_cfg[raw_num].is_offline_scaler) { //Scaler online mode
			struct sc_cfg_cb post_para;

			post_para.dev = container_of(vdev, struct cvi_vip_dev, isp_vdev);
			post_para.snr_num = raw_num;
			post_para.is_tile = false;

			if (cvi_sc_cfg_cb(&post_para) != 0) {
				vip_pr(CVI_INFO, "snr_num_%d, SC is running\n", raw_num);
				atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
				return;
			}

			atomic_set(&vdev->ol_sc_frm_done, 0);
			ctx->is_tile = post_para.is_tile;
		}

		if (!ctx->isp_pipe_cfg[raw_num].is_offline_preraw)
			_pre_hw_enque(vdev, raw_num, ISP_FE_CH0);
	}
}

static uint8_t _awb_sts_in_use_chk(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	uint8_t in_use = 0;
	unsigned long flags;

	spin_lock_irqsave(&isp_bufpool[raw_num].awb_sts_lock, flags);
	if (isp_bufpool[raw_num].awb_sts_in_use == 1) {
		in_use = 1;
	} else
		isp_bufpool[raw_num].awb_sts_busy_idx ^= 1;
	spin_unlock_irqrestore(&isp_bufpool[raw_num].awb_sts_lock, flags);

	return in_use;
}

static inline void _swap_awb_sts_buf(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct _membuf *pool;
	uint8_t idx;
	u8 next_raw = raw_num;

	if (_is_be_post_online(ctx)) //fe->dram->be->post
		next_raw = (raw_num == ISP_PRERAW_A) ? ISP_PRERAW_B : ISP_PRERAW_A;

	if (_awb_sts_in_use_chk(vdev, next_raw) == 0) {
		pool = &isp_bufpool[next_raw];
		idx = isp_bufpool[next_raw].awb_sts_busy_idx;

		//awb dma
		ispblk_dma_config(ctx, ISP_BLK_ID_WDMA19, pool->sts_mem[idx].awb.phy_addr);

		vip_pr(CVI_DBG, "awb sts next_raw=%d, buf_idx=%d, addr=0x%llx\n",
				next_raw, idx, pool->sts_mem[idx].awb.phy_addr);
	}
}

static void _pre_fe_rgbmap_update(
	struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num,
	const enum cvi_isp_pre_chn_num chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 rgbmap_idx = (vdev->pre_fe_frm_num[raw_num][chn_num]) % RGBMAP_BUF_IDX;

	if (chn_num == ISP_FE_CH0) {
		if (raw_num == ISP_PRERAW_A)
			ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA2, isp_bufpool[raw_num].rgbmap_le[rgbmap_idx]);
		else
			ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA8, isp_bufpool[raw_num].rgbmap_le[rgbmap_idx]);

	} else if (chn_num == ISP_FE_CH1) {
		if (raw_num == ISP_PRERAW_A)
			ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA4, isp_bufpool[raw_num].rgbmap_se[rgbmap_idx]);
		else
			ispblk_dma_setaddr(ctx, ISP_BLK_ID_WDMA10, isp_bufpool[raw_num].rgbmap_se[rgbmap_idx]);
	}

}

#ifdef ISP_PERF_MEASURE
void _isp_perf_time_dump(void)
{
	u64 time_0 = 0, time_1 = 0;
	u32 i = 0, post_str_cnt = 0, post_eof_cnt = 0;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
	u64 sof_first = (time_chk.sof_time[0].tv_sec * STOUS) + time_chk.sof_time[0].tv_nsec / 1000;
	u64 sof_last  = (time_chk.sof_time[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.sof_time[ISP_MEASURE_FRM - 1].tv_nsec / 1000;
	u64 fe_eof_first = (time_chk.pre_fe_eof[0].tv_sec * STOUS) + time_chk.pre_fe_eof[0].tv_nsec / 1000;
	u64 fe_eof_last  = (time_chk.pre_fe_eof[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.pre_fe_eof[ISP_MEASURE_FRM - 1].tv_nsec / 1000;
	u64 be_eof_first = (time_chk.pre_be_eof[0].tv_sec * STOUS) + time_chk.pre_be_eof[0].tv_nsec / 1000;
	u64 be_eof_last  = (time_chk.pre_be_eof[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.pre_be_eof[ISP_MEASURE_FRM - 1].tv_nsec / 1000;
	u64 post_eof_first = (time_chk.post_eof[0].tv_sec * STOUS) + time_chk.post_eof[0].tv_nsec / 1000;
	u64 post_eof_last = (time_chk.post_eof[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.post_eof[ISP_MEASURE_FRM - 1].tv_nsec / 1000;

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.sof_time[i].tv_sec * STOUS) + time_chk.sof_time[i].tv_nsec / 1000; //us
		time_1 = (time_chk.sof_time[i + 1].tv_sec * STOUS) + time_chk.sof_time[i + 1].tv_nsec / 1000; //us
		vip_pr(CVI_ERR, "SOF_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.pre_fe_eof[i].tv_sec * STOUS) + time_chk.pre_fe_eof[i].tv_nsec / 1000; //us
		time_1 = (time_chk.pre_fe_eof[i + 1].tv_sec * STOUS) + time_chk.pre_fe_eof[i + 1].tv_nsec / 1000; //us
		vip_pr(CVI_ERR, "Pre_fe_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.pre_be_eof[i].tv_sec * STOUS) + time_chk.pre_be_eof[i].tv_nsec / 1000; //us
		time_1 = (time_chk.pre_be_eof[i + 1].tv_sec * STOUS) + time_chk.pre_be_eof[i + 1].tv_nsec / 1000; //us
		vip_pr(CVI_ERR, "Pre_be_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.post_trig[i].tv_sec * STOUS) + time_chk.post_trig[i].tv_nsec / 1000; //us
		time_1 = (time_chk.post_eof[i].tv_sec * STOUS) + time_chk.post_eof[i].tv_nsec / 1000; //us
		vip_pr(CVI_ERR, "Post_duration=%llu\n", (time_1 - time_0));
	}
#else
	u64 sof_first = (time_chk.sof_time[0].tv_sec * STOUS) + time_chk.sof_time[0].tv_usec;
	u64 sof_last  = (time_chk.sof_time[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.sof_time[ISP_MEASURE_FRM - 1].tv_usec;
	u64 fe_eof_first = (time_chk.pre_fe_eof[0].tv_sec * STOUS) + time_chk.pre_fe_eof[0].tv_usec;
	u64 fe_eof_last  = (time_chk.pre_fe_eof[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.pre_fe_eof[ISP_MEASURE_FRM - 1].tv_usec;
	u64 be_eof_first = (time_chk.pre_be_eof[0].tv_sec * STOUS) + time_chk.pre_be_eof[0].tv_usec;
	u64 be_eof_last  = (time_chk.pre_be_eof[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.pre_be_eof[ISP_MEASURE_FRM - 1].tv_usec;
	u64 post_eof_first = (time_chk.post_eof[0].tv_sec * STOUS) + time_chk.post_eof[0].tv_usec;
	u64 post_eof_last = (time_chk.post_eof[ISP_MEASURE_FRM - 1].tv_sec * STOUS) +
			time_chk.post_eof[ISP_MEASURE_FRM - 1].tv_usec;

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.sof_time[i].tv_sec * STOUS) + time_chk.sof_time[i].tv_usec; //us
		time_1 = (time_chk.sof_time[i + 1].tv_sec * STOUS) + time_chk.sof_time[i + 1].tv_usec; //us
		vip_pr(CVI_ERR, "SOF_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.pre_fe_eof[i].tv_sec * STOUS) + time_chk.pre_fe_eof[i].tv_usec; //us
		time_1 = (time_chk.pre_fe_eof[i + 1].tv_sec * STOUS) + time_chk.pre_fe_eof[i + 1].tv_usec; //us
		vip_pr(CVI_ERR, "Pre_fe_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.pre_be_eof[i].tv_sec * STOUS) + time_chk.pre_be_eof[i].tv_usec; //us
		time_1 = (time_chk.pre_be_eof[i + 1].tv_sec * STOUS) + time_chk.pre_be_eof[i + 1].tv_usec; //us
		vip_pr(CVI_ERR, "Pre_be_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.post_trig[i].tv_sec * STOUS) + time_chk.post_trig[i].tv_usec; //us
		time_1 = (time_chk.post_eof[i].tv_sec * STOUS) + time_chk.post_eof[i].tv_usec; //us
		vip_pr(CVI_ERR, "Post_duration=%llu\n", (time_1 - time_0));
	}
#endif

	vip_pr(CVI_ERR, "AVG time: sof(%llu) fe_eof(%llu) be_eof(%llu) post_eof(%llu)",
			(sof_last - sof_first) / ISP_MEASURE_FRM - 1,
			(fe_eof_last - fe_eof_first) / ISP_MEASURE_FRM - 1,
			(be_eof_last - be_eof_first) / ISP_MEASURE_FRM - 1,
			(post_eof_last - post_eof_first) / ISP_MEASURE_FRM - 1);

#if 0
	for (i = 0; i < ISP_MEASURE_FRM; i++) {
		time_0 = (time_chk.postraw_str[i].time.tv_sec * STOUS) + time_chk.postraw_str[i].time.tv_usec; //us
		time_1 = (time_chk.postraw_eof[i].time.tv_sec * STOUS) + time_chk.postraw_eof[i].time.tv_usec; //us
		post_str_cnt = time_chk.postraw_str[i].cnt;
		post_eof_cnt = time_chk.postraw_eof[i].cnt;

		dprintk(VIP_INFO, "Post_diff=%llu\n", (time_1 - time_0));
	}

	u64 time_2 = 0, time_3 = 0;

	for (i = 0; i < ISP_MEASURE_FRM; i += 2) {
		time_0 = (time_chk.postraw_str[i].time.tv_sec * STOUS) + time_chk.postraw_str[i].time.tv_usec; //us
		time_1 = (time_chk.postraw_eof[i].time.tv_sec * STOUS) + time_chk.postraw_eof[i].time.tv_usec; //us

		dprintk(VIP_INFO, "left_tile_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 1; i < ISP_MEASURE_FRM; i += 2) {
		time_0 = (time_chk.postraw_str[i].time.tv_sec * STOUS) + time_chk.postraw_str[i].time.tv_usec; //us
		time_1 = (time_chk.postraw_eof[i].time.tv_sec * STOUS) + time_chk.postraw_eof[i].time.tv_usec; //us

		dprintk(VIP_INFO, "right_tile_diff=%llu\n", (time_1 - time_0));
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.sof_time[i].tv_sec * STOUS) + time_chk.sof_time[i].tv_usec; //us
		time_1 = (time_chk.postraw_eof[i].time.tv_sec * STOUS) + time_chk.postraw_eof[i].time.tv_usec; //us

		dprintk(VIP_INFO, "SOF_Post_diff=%llu\n", time_1 - time_0);
	}

	for (i = 0; i < ISP_MEASURE_FRM - 1; i++) {
		time_0 = (time_chk.preraw_eof[i].tv_sec * STOUS) + time_chk.preraw_eof[i].tv_usec; //us
		time_1 = (time_chk.postraw_eof[i].time.tv_sec * STOUS) + time_chk.postraw_eof[i].time.tv_usec; //us

		dprintk(VIP_INFO, "Pre_Post_diff=%llu\n", time_1 - time_0);
	}
#endif
	time_chk.post_end = false;
	time_chk.pre_be_end = false;
	time_chk.pre_fe_end = false;
	time_chk.sof_end = false;
}
#endif

void isp_ol_sc_trig_post(struct cvi_isp_vdev *vdev)
{
	vip_pr(CVI_DBG, "isp_ol_sc_trig_post\n");

	tasklet_hi_schedule(&vdev->job_work);
}

void isp_ol_sc_r_tile_cfg(struct cvi_isp_vdev *vdev)
{
	vip_pr(CVI_DBG, "sc frm done cb\n");

	atomic_set(&vdev->ol_sc_frm_done, 1);
	tasklet_hi_schedule(&vdev->job_work);
}

void _isp_err_handler(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw err_raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u8 wait_fe = ISP_PRERAW_A, count = 10;

	//Stop pre/postraw trigger go
	atomic_set(&vdev->isp_err_handle_flag, 1);

	//step 1 : set frm vld = 0
	isp_frm_err_handler(ctx, err_raw_num, 1);

	if (ctx->is_dual_sensor)
		wait_fe = (err_raw_num == ISP_PRERAW_A) ? ISP_PRERAW_B : ISP_PRERAW_A;

	//step 2 : wait to make sure post and the other fe is done.
	while (--count > 0) {
		if (_is_be_post_online(ctx)) {
			if (atomic_read(&vdev->postraw_state) == ISP_POSTRAW_IDLE &&
				atomic_read(&vdev->pre_fe_state[wait_fe][ISP_FE_CH0]) == ISP_PRERAW_IDLE &&
				atomic_read(&vdev->pre_fe_state[wait_fe][ISP_FE_CH1]) == ISP_PRERAW_IDLE &&
				atomic_read(&vdev->pre_be_state[ISP_BE_CH0]) == ISP_PRE_BE_IDLE &&
				atomic_read(&vdev->pre_be_state[ISP_BE_CH1]) == ISP_PRE_BE_IDLE)
				break;
			vip_pr(CVI_WARN, "wait fe_%d, be and post idle count(%d) for be_post online\n", wait_fe, count);
		} else if (_is_fe_be_online(ctx)) {
			if (ctx->is_dual_sensor) {
				if (err_raw_num == ISP_PRERAW_A) {
					wait_fe = ISP_PRERAW_B;

					if (atomic_read(&vdev->postraw_state) == ISP_POSTRAW_IDLE &&
					atomic_read(&vdev->pre_fe_state[wait_fe][ISP_FE_CH0]) == ISP_PRERAW_IDLE &&
					atomic_read(&vdev->pre_fe_state[wait_fe][ISP_FE_CH1]) == ISP_PRERAW_IDLE)
						break;
					vip_pr(CVI_WARN, "wait fe_%d and post idle count(%d) for fe_be online dual\n",
							wait_fe, count);
				} else {
					if (atomic_read(&vdev->postraw_state) == ISP_POSTRAW_IDLE &&
						atomic_read(&vdev->pre_be_state[ISP_BE_CH0]) == ISP_PRE_BE_IDLE &&
						atomic_read(&vdev->pre_be_state[ISP_BE_CH1]) == ISP_PRE_BE_IDLE)
						break;
					vip_pr(CVI_WARN, "wait be and post idle count(%d) for fe_be online dual\n",
							count);
				}
			} else {
				if (atomic_read(&vdev->postraw_state) == ISP_POSTRAW_IDLE)
					break;
				vip_pr(CVI_WARN, "wait post idle(%d) count(%d) for fe_be online single\n",
						atomic_read(&vdev->postraw_state), count);
			}
		}

		usleep_range(5 * 1000, 10 * 1000);
	}

	//If fe/be/post not done;
	if (count == 0) {
		if (ctx->is_dual_sensor) {
			vip_pr(CVI_ERR, "isp status fe_%d(ch0:%d, ch1:%d) be(ch0:%d, ch1:%d) postraw(%d)\n",
					wait_fe,
					atomic_read(&vdev->pre_fe_state[wait_fe][ISP_FE_CH0]),
					atomic_read(&vdev->pre_fe_state[wait_fe][ISP_FE_CH1]),
					atomic_read(&vdev->pre_be_state[ISP_BE_CH0]),
					atomic_read(&vdev->pre_be_state[ISP_BE_CH1]),
					atomic_read(&vdev->postraw_state));
		} else {
			vip_pr(CVI_ERR, "isp status post(%d)\n", atomic_read(&vdev->postraw_state));
		}
		return;
	}

	//step 3 : set csibdg sw abort and wait abort done
	if (isp_frm_err_handler(ctx, err_raw_num, 3) < 0)
		return;

	//step 4 : isp sw reset
	isp_frm_err_handler(ctx, err_raw_num, 4);

	//step 5 : wait ISP idle
	if (isp_frm_err_handler(ctx, err_raw_num, 5) < 0)
		return;

	//step 6 : reset sw state to idle
	if (_is_be_post_online(ctx)) {
		atomic_set(&vdev->pre_fe_state[err_raw_num][ISP_FE_CH0], ISP_PRERAW_IDLE);
		atomic_set(&vdev->pre_fe_state[err_raw_num][ISP_FE_CH1], ISP_PRERAW_IDLE);
	} else if (_is_fe_be_online(ctx)) {
		if (ctx->is_dual_sensor) {
			if (err_raw_num == ISP_PRERAW_A) {
				atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);
				atomic_set(&vdev->pre_be_state[ISP_BE_CH1], ISP_PRE_BE_IDLE);
			} else {
				atomic_set(&vdev->pre_fe_state[err_raw_num][ISP_FE_CH0], ISP_PRERAW_IDLE);
				atomic_set(&vdev->pre_fe_state[err_raw_num][ISP_FE_CH1], ISP_PRERAW_IDLE);
			}
		} else {
			atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);
			atomic_set(&vdev->pre_be_state[ISP_BE_CH1], ISP_PRE_BE_IDLE);
		}
	}

	//Let postraw trigger go
	atomic_set(&vdev->isp_err_handle_flag, 0);
}

static int _isp_err_handler_thread(void *arg)
{
	struct cvi_isp_vdev *vdev = (struct cvi_isp_vdev *)arg;
	enum cvi_isp_raw err_raw_num;

	while (1) {
		wait_event(vdev->isp_err_wait_q, vdev->isp_err_int_flag != 0);
		err_raw_num = (vdev->isp_err_int_flag == 1) ? ISP_PRERAW_A : ISP_PRERAW_B;

		if (vdev->isp_err_int_flag == 3) {
			pr_info("isp_err_handler_thread exit\n");
			atomic_set(&isp_err_handler_exit, 1);
			do_exit(1);
		}

		vdev->isp_err_int_flag = 0;

		_isp_err_handler(vdev, err_raw_num);
	}

	return 0;
}

static inline void isp_err_wake_up_th(struct cvi_isp_vdev *vdev, enum cvi_isp_raw err_raw)
{
	vdev->isp_err_int_flag = (err_raw == ISP_PRERAW_A) ? 1 : 2;
	wake_up(&vdev->isp_err_wait_q);
}

u32 isp_err_chk(
	struct cvi_isp_vdev *vdev,
	struct isp_ctx *ctx,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_0 cbdg_0_sts,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_1 cbdg_1_sts,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_0 cbdg_0_sts_b,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_1 cbdg_1_sts_b)
{
	u32 ret = 0;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	enum cvi_isp_pre_chn_num fe_chn = ISP_FE_CH0;

	if (cbdg_1_sts.bits.FIFO_OVERFLOW_INT) {
		vip_pr(CVI_ERR, "CSIBDG_A fifo overflow\n");
		ctx->isp_pipe_cfg[raw_num].dg_info.bdg_fifo_of_cnt++;
		isp_err_wake_up_th(vdev, raw_num);
		ret = -1;
	}

	if (cbdg_1_sts.bits.FRAME_RESOLUTION_OVER_MAX_INT) {
		vip_pr(CVI_ERR, "CSIBDG_A frm size over max\n");
		ret = -1;
	}

	if (cbdg_1_sts.bits.DMA_ERROR_INT) {
		u32 wdma_err = ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.wdma_err_sts;
		u32 rdma_err = ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.rdma_err_sts;
		u32 wdma_idle = ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.wdma_idle;
		u32 rdma_idle = ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts.rdma_idle;

		if ((wdma_err & 0x10) || (rdma_err & 0x10)) {
			vip_pr(CVI_ERR, "DMA axi error wdma_status0(0x%x) rdma_status0(0x%x)\n",
					wdma_err, rdma_err);
			ret = -1;
		} else if ((wdma_err & 0x20)) {
			vip_pr(CVI_ERR, "DMA size mismatch\n wdma_status0(0x%x) rdma_status0(0x%x)\n",
					wdma_err, rdma_err);
			vip_pr(CVI_ERR, "wdma_idle(0x%x) rdma_idle(0x%x)\n",
					wdma_idle, rdma_idle);
			ret = -1;
		} else if ((wdma_err & 0x40)) {
			vip_pr(CVI_WARN, "WDMA buffer full\n");
		}
	}

	if (cbdg_0_sts.bits.CH0_FRAME_WIDTH_GT_INT) {
		vip_pr(CVI_ERR, "CSIBDG_A CH%d frm width greater than setting(%d)\n",
				fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
		ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_gt_cnt[fe_chn]++;
		isp_err_wake_up_th(vdev, raw_num);
		ret = -1;
	}

	if (cbdg_0_sts.bits.CH0_FRAME_WIDTH_LS_INT) {
		vip_pr(CVI_ERR, "CSIBDG_A CH%d frm width less than setting(%d)\n",
				fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
		ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_ls_cnt[fe_chn]++;
		isp_err_wake_up_th(vdev, raw_num);
		ret = -1;
	}

	if (cbdg_0_sts.bits.CH0_FRAME_HEIGHT_GT_INT) {
		vip_pr(CVI_ERR, "CSIBDG_A CH%d frm height greater than setting(%d)\n",
				fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
		ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_gt_cnt[fe_chn]++;
		isp_err_wake_up_th(vdev, raw_num);
		ret = -1;
	}

	if (cbdg_0_sts.bits.CH0_FRAME_HEIGHT_LS_INT) {
		vip_pr(CVI_ERR, "CSIBDG_A CH%d frm height less than setting(%d)\n",
				fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
		ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_ls_cnt[fe_chn]++;
		isp_err_wake_up_th(vdev, raw_num);
		ret = -1;
	}

	if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
		fe_chn = ISP_FE_CH1;

		if (cbdg_0_sts.bits.CH1_FRAME_WIDTH_GT_INT) {
			vip_pr(CVI_ERR, "CSIBDG_A CH%d frm width greater than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_gt_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_0_sts.bits.CH1_FRAME_WIDTH_LS_INT) {
			vip_pr(CVI_ERR, "CSIBDG_A CH%d frm width less than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_ls_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_0_sts.bits.CH1_FRAME_HEIGHT_GT_INT) {
			vip_pr(CVI_ERR, "CSIBDG_A CH%d frm height greater than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_gt_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_0_sts.bits.CH1_FRAME_HEIGHT_LS_INT) {
			vip_pr(CVI_ERR, "CSIBDG_A CH%d frm height less than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_ls_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}
	}

	if (ctx->is_dual_sensor) {
		raw_num = ISP_PRERAW_B;
		fe_chn = ISP_FE_CH0;

		if (cbdg_1_sts_b.bits.FIFO_OVERFLOW_INT) {
			vip_pr(CVI_ERR, "CSIBDG_B fifo overflow\n");
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_fifo_of_cnt++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_1_sts_b.bits.FRAME_RESOLUTION_OVER_MAX_INT) {
			vip_pr(CVI_ERR, "CSIBDG_B frm size over max\n");
			ret = -1;
		}

		if (cbdg_0_sts_b.bits.CH0_FRAME_WIDTH_GT_INT) {
			vip_pr(CVI_ERR, "CSIBDG_B CH%d frm width greater than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_gt_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_0_sts_b.bits.CH0_FRAME_WIDTH_LS_INT) {
			vip_pr(CVI_ERR, "CSIBDG_B CH%d frm width less than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_ls_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_0_sts_b.bits.CH0_FRAME_HEIGHT_GT_INT) {
			vip_pr(CVI_ERR, "CSIBDG_B CH%d frm height greater than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_gt_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (cbdg_0_sts_b.bits.CH0_FRAME_HEIGHT_LS_INT) {
			vip_pr(CVI_ERR, "CSIBDG_B CH%d frm height less than setting(%d)\n",
					fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_ls_cnt[fe_chn]++;
			isp_err_wake_up_th(vdev, raw_num);
			ret = -1;
		}

		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			fe_chn = ISP_FE_CH1;

			if (cbdg_0_sts_b.bits.CH1_FRAME_WIDTH_GT_INT) {
				vip_pr(CVI_ERR, "CSIBDG_B CH%d frm width greater than setting(%d)\n",
						fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
				ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_gt_cnt[fe_chn]++;
				isp_err_wake_up_th(vdev, raw_num);
				ret = -1;
			}

			if (cbdg_0_sts_b.bits.CH1_FRAME_WIDTH_LS_INT) {
				vip_pr(CVI_ERR, "CSIBDG_B CH%d frm width less than setting(%d)\n",
						fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_width);
				ctx->isp_pipe_cfg[raw_num].dg_info.bdg_w_ls_cnt[fe_chn]++;
				isp_err_wake_up_th(vdev, raw_num);
				ret = -1;
			}

			if (cbdg_0_sts_b.bits.CH1_FRAME_HEIGHT_GT_INT) {
				vip_pr(CVI_ERR, "CSIBDG_B CH%d frm height greater than setting(%d)\n",
						fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
				ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_gt_cnt[fe_chn]++;
				isp_err_wake_up_th(vdev, raw_num);
				ret = -1;
			}

			if (cbdg_0_sts_b.bits.CH1_FRAME_HEIGHT_LS_INT) {
				vip_pr(CVI_ERR, "CSIBDG_B CH%d frm height less than setting(%d)\n",
						fe_chn, ctx->isp_pipe_cfg[raw_num].csibdg_height);
				ctx->isp_pipe_cfg[raw_num].dg_info.bdg_h_ls_cnt[fe_chn]++;
				isp_err_wake_up_th(vdev, raw_num);
				ret = -1;
			}
		}
	}

	return ret;
}

void isp_post_tasklet(unsigned long data)
{
	struct cvi_isp_vdev *vdev = (struct cvi_isp_vdev *)data;
	struct isp_ctx *ctx = &vdev->ctx;
	u8 raw_num = ISP_PRERAW_A;
	int ret = 0;

	if (vdev->postraw_proc_num == 1) { //Left tile to trigger right tile
		//SC online mode to trigger right tile
		if (!ctx->isp_pipe_cfg[raw_num].is_offline_scaler &&
			ctx->is_work_on_r_tile &&
			atomic_read(&vdev->ol_sc_frm_done) == 1) {
			struct sc_cfg_cb post_para;

			if (atomic_cmpxchg(&vdev->postraw_state, ISP_POSTRAW_IDLE, ISP_POSTRAW_RUNNING)
						!= ISP_POSTRAW_IDLE) {
				vip_pr(CVI_INFO, "Postraw is running for right tile\n");
				return;
			}

			post_para.dev = container_of(vdev, struct cvi_vip_dev, isp_vdev);
			post_para.snr_num			= raw_num;
			post_para.is_tile			= true;
			post_para.is_left_tile			= false;
			post_para.ol_tile_cfg.l_in.start	= ctx->tile_cfg.l_in.start;
			post_para.ol_tile_cfg.l_in.end		= ctx->tile_cfg.l_in.end;
			post_para.ol_tile_cfg.l_out.start	= ctx->tile_cfg.l_out.start;
			post_para.ol_tile_cfg.l_out.end		= ctx->tile_cfg.l_out.end;
			post_para.ol_tile_cfg.r_in.start	= ctx->tile_cfg.r_in.start;
			post_para.ol_tile_cfg.r_in.end		= ctx->tile_cfg.r_in.end;
			post_para.ol_tile_cfg.r_out.start	= ctx->tile_cfg.r_out.start;
			post_para.ol_tile_cfg.r_out.end		= ctx->tile_cfg.r_out.end;

			ret = cvi_sc_cfg_cb(&post_para);
			if (ret != 0) {
				vip_pr(CVI_ERR, "SC is not idle for right tile\n");
				atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
			} else {
				vip_pr(CVI_DBG, "Trigger for right tile\n");
				_isp_right_tile(vdev, raw_num);
				isp_post_trig(ctx, raw_num);
				ctx->is_work_on_r_tile = false;
			}
		}
	} else { //Only if right tile done or normal frm done
		_post_hw_enque(vdev);
	}
}

static int _isp_preraw_thread(void *arg)
{
	struct cvi_isp_vdev *vdev = (struct cvi_isp_vdev *)arg;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	struct isp_ctx *ctx = &vdev->ctx;
	struct cvi_vip_isp_fe_cfg *fe_cfg;
	struct cvi_vip_isp_be_cfg *be_cfg;
	u8 tun_idx = 0;

	struct list_head *pos, *temp;
	struct _isp_raw_num_n  *n[10];
	unsigned long flags;
	u32 enq_num = 0, i = 0;

	while (1) {
		wait_event(vdev->isp_pre_wait_q, vdev->isp_pre_int_flag != 0);
		if (vdev->isp_pre_int_flag == 3) {
			pr_info("preraw_thread exit\n");
			atomic_set(&isp_pre_exit, 1);
			do_exit(1);
		}

		vdev->isp_pre_int_flag = 0;

		spin_lock_irqsave(&raw_num_lock, flags);
		list_for_each_safe(pos, temp, &pre_raw_num_q.list) {
			n[enq_num] = list_entry(pos, struct _isp_raw_num_n, list);
			enq_num++;
		}
		spin_unlock_irqrestore(&raw_num_lock, flags);

		for (i = 0; i < enq_num; i++) {
			raw_num = n[i]->raw_num;

			spin_lock_irqsave(&raw_num_lock, flags);
			list_del_init(&n[i]->list);
			kfree(n[i]);
			spin_unlock_irqrestore(&raw_num_lock, flags);

			_isp_snr_cfg_deq_and_fire(vdev, raw_num);

			fe_cfg  = (struct cvi_vip_isp_fe_cfg *)tuning_buf_addr.fe_vir[raw_num];
			tun_idx = fe_cfg->tun_idx;

			vip_pr(CVI_DBG, "Pre_fe_%d tuning update(%d):idx(%d)\n",
					raw_num, fe_cfg->tun_update[tun_idx], tun_idx);
			if ((tun_idx < TUNING_NODE_NUM) && (fe_cfg->tun_update[tun_idx] == 1))
				_pre_fe_tuning_update(vdev, &fe_cfg->tun_cfg[tun_idx], raw_num);

			if (_is_fe_be_online(ctx) || _is_all_online(ctx)) { //fe->be->dram->post or on the fly
				be_cfg  = (struct cvi_vip_isp_be_cfg *)tuning_buf_addr.be_vir[raw_num];
				tun_idx = be_cfg->tun_idx;

				vip_pr(CVI_DBG, "Pre_be_%d tuning update(%d):idx(%d)\n",
						raw_num, be_cfg->tun_update[tun_idx], tun_idx);
				if ((tun_idx < TUNING_NODE_NUM) && (be_cfg->tun_update[tun_idx] == 1))
					_pre_be_tuning_update(vdev, &be_cfg->tun_cfg[tun_idx], raw_num);

				if (_is_all_online(ctx)) { //on the fly
					struct cvi_vip_isp_post_cfg *post_cfg;

					post_cfg = (struct cvi_vip_isp_post_cfg *)tuning_buf_addr.post_vir[raw_num];
					tun_idx  = post_cfg->tun_idx;

					vip_pr(CVI_DBG, "Postraw_%d tuning update(%d):idx(%d)\n",
							raw_num, post_cfg->tun_update[tun_idx], tun_idx);
					if ((tun_idx < TUNING_NODE_NUM) && (post_cfg->tun_update[tun_idx] == 1))
						_postraw_tuning_update(vdev, &post_cfg->tun_cfg[tun_idx], raw_num);
				}
			}

			//_isp_v4l2_event_queue(vdev, (raw_num == ISP_PRERAW_A) ?
			//			V4L2_EVENT_CVI_VIP_PRE0_TUN_IDX : V4L2_EVENT_CVI_VIP_PRE1_TUN_IDX,
			//			tun_idx);
		}

		enq_num = 0;
	}

	return 0;
}

static void _isp_yuv_online_handler(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 hw_chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct isp_buffer *b = NULL;
	u8 buf_chn = (raw_num == ISP_PRERAW_A) ? hw_chn_num : vdev->ctx.rawb_chnstr_num + hw_chn_num;

	atomic_set(&vdev->pre_fe_state[raw_num][hw_chn_num], ISP_PRERAW_IDLE);

	b = isp_buf_remove(&pre_out_queue[buf_chn]);
	if (b == NULL) {
		vip_pr(CVI_INFO, "YUV_chn_%d done outbuf is empty\n", buf_chn);
		return;
	}

	b->crop_le.x = 0;
	b->crop_le.y = 0;
	b->crop_le.w = ctx->isp_pipe_cfg[raw_num].post_img_w;
	b->crop_le.h = ctx->isp_pipe_cfg[raw_num].post_img_h;
	b->is_yuv_frm = 1;
	b->raw_num = raw_num;
	b->chn_num = buf_chn;

	if (_is_be_post_online(ctx))
		isp_buf_queue(&pre_be_in_q, b);
	else if (_is_fe_be_online(ctx))
		isp_buf_queue(&post_in_queue, b);

	// if preraw offline, let usr_pic_timer_handler do it.
	if (!ctx->isp_pipe_cfg[raw_num].is_offline_preraw)
		_pre_hw_enque(vdev, raw_num, hw_chn_num);
}

static void _isp_yuv_bypass_handler(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num, const u8 hw_chn_num)
{
	u8 buf_chn = (raw_num == ISP_PRERAW_A) ? hw_chn_num : vdev->ctx.rawb_chnstr_num + hw_chn_num;

	atomic_set(&vdev->pre_fe_state[raw_num][hw_chn_num], ISP_PRERAW_IDLE);

	cvi_isp_rdy_buf_remove2(vdev, buf_chn);

	cvi_isp_dqbuf_list(vdev, vdev->pre_fe_frm_num[raw_num][hw_chn_num], buf_chn);
	wake_up(&vdev->isp_dq_wait_q);

	if (cvi_isp_rdy_buf_empty2(vdev, buf_chn))
		vip_pr(CVI_INFO, "fe_%d chn_num_%d yuv bypass outbuf is empty\n", raw_num, buf_chn);
	else
		_isp_yuv_bypass_trigger(vdev, raw_num, hw_chn_num);
}

static void _isp_sof_handler(struct cvi_isp_vdev *vdev, const enum cvi_isp_raw raw_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	struct _isp_raw_num_n  *n;
	unsigned long flags;

	if (atomic_read(&vdev->isp_streamoff) == 1)
		return;

	n = kmalloc(sizeof(*n), GFP_ATOMIC);
	if (n == NULL) {
		vip_pr(CVI_ERR, "pre_raw_num_q kmalloc size(%d) fail\n", sizeof(*n));
		return;
	}
	n->raw_num = raw_num;
	pre_raw_num_enq(&pre_raw_num_q, n);

	vdev->isp_pre_int_flag = (raw_num == ISP_PRERAW_A) ? 1 : 2;
	wake_up(&vdev->isp_pre_wait_q);

	if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 2) //raw_dump flow
		atomic_set(&vdev->isp_raw_dump_en[raw_num], 3);

	tasklet_hi_schedule(&vdev->job_work);

	if (ctx->isp_pipe_cfg[raw_num].is_offline_scaler) {
		spin_lock_irqsave(&dq_lock, flags);
		if (!list_empty(&dqbuf_q.list))
			wake_up(&vdev->isp_dq_wait_q);
		spin_unlock_irqrestore(&dq_lock, flags);
	}

	isp_sync_task_process(raw_num);
}

static inline void _isp_awb_frm_done_handler(
	struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u32 type;
	u8 is_se = isp_is_awb_se(ctx);
	u8 raw_num = ISP_PRERAW_A;

	if (_is_all_online(ctx) || _is_fe_be_online(ctx)) { //fly mode && fe->be->dram->post
		if (isp_is_fe02be_enable(ctx))
			raw_num = ISP_PRERAW_A;
		else
			raw_num = ISP_PRERAW_B;
	} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
		raw_num = vdev->offline_raw_num;
	}

	vip_pr(CVI_DBG, "_isp_awb_frm_done_handler, raw_num=%d, is_se(%d)\n", raw_num, is_se);

	vdev->pre_be_awb_frm_num[raw_num][is_se]++;
	ctx->isp_pipe_cfg[raw_num].is_awb_sts_se = is_se;

	_swap_awb_sts_buf(vdev, raw_num);

	type = (raw_num == ISP_PRERAW_A) ? V4L2_EVENT_CVI_VIP_AWB0_DONE : V4L2_EVENT_CVI_VIP_AWB1_DONE;

	_isp_v4l2_event_queue(vdev, type, vdev->pre_be_awb_frm_num[raw_num][is_se]);
}

static inline void _isp_pre_fe_done_handler(
	struct cvi_isp_vdev *vdev,
	const enum cvi_isp_raw raw_num,
	const enum cvi_isp_pre_chn_num chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	u32 trigger = false;

	if (ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) {
		if (ctx->isp_pipe_cfg[raw_num].is_offline_scaler) { //offline mode
			vip_pr(CVI_DBG, "pre_fe_%d chn_num_%d yuv offline done\n", raw_num, chn_num);
			_isp_yuv_bypass_handler(vdev, raw_num, chn_num);
		} else { //YUV sensor online mode
			vip_pr(CVI_DBG, "pre_fe_%d chn_num_%d yuv online done\n", raw_num, chn_num);
			_isp_yuv_online_handler(vdev, raw_num, chn_num);
		}
		return;
	}

	vip_pr(CVI_DBG, "pre_fe_%d frm_done chn_num=%d frm_num=%d\n",
			raw_num, chn_num, vdev->pre_fe_frm_num[raw_num][chn_num]);

	if (!_is_all_online(ctx)) { // Not on the fly mode
		ispblk_tnr_rgbmap_chg(ctx, raw_num, chn_num);
		_pre_fe_rgbmap_update(vdev, raw_num, chn_num);
		ispblk_lmap_chg_size(ctx, raw_num, chn_num);
	}

	if (_is_fe_be_online(ctx) || _is_all_online(ctx)) { //fe->be->dram->post or on the fly mode
		if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 3) { //raw_dump flow
			struct isp_buffer *b = NULL;
			struct isp_queue *fe_out_q = (chn_num == ISP_FE_CH0) ?
							&raw_dump_b_q[raw_num] :
							&raw_dump_b_se_q[raw_num];
			struct isp_queue *raw_d_q = (chn_num == ISP_FE_CH0) ?
							&raw_dump_b_dq[raw_num] :
							&raw_dump_b_se_dq[raw_num];
			u32 dmaid = (raw_num == ISP_PRERAW_A) ?
					((chn_num == ISP_FE_CH0) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA1) :
					((chn_num == ISP_FE_CH0) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7);
			u32 w = (chn_num == ISP_FE_CH0) ?
				ctx->isp_pipe_cfg[raw_num].crop.w :
				ctx->isp_pipe_cfg[raw_num].crop_se.w;
			u32 h = (chn_num == ISP_FE_CH0) ?
				ctx->isp_pipe_cfg[raw_num].crop.h :
				ctx->isp_pipe_cfg[raw_num].crop_se.h;

			ispblk_csidbg_dma_wr_en(ctx, raw_num, chn_num, 0);

			b = isp_buf_remove(fe_out_q);
			if (b == NULL) {
				vip_pr(CVI_ERR, "Pre_fe_%d chn_num_%d outbuf is empty\n", raw_num, chn_num);
				return;
			}

			b->crop_le.x = b->crop_se.x = 0;
			b->crop_le.y = b->crop_se.y = 0;
			b->crop_le.w = b->crop_se.w = ctx->isp_pipe_cfg[raw_num].crop.w;
			b->crop_le.h = b->crop_se.h = ctx->isp_pipe_cfg[raw_num].crop.h;
			b->byr_size = ispblk_dma_get_size(ctx, dmaid, w, h);

			isp_buf_queue(raw_d_q, b);

			if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
				trigger = (vdev->pre_fe_frm_num[raw_num][ISP_FE_CH0] ==
						vdev->pre_fe_frm_num[raw_num][ISP_FE_CH1]);
			} else
				trigger = true;

			if (trigger) {
				vip_pr(CVI_DBG, "wake up wait_q\n");

				vdev->isp_int_flag[raw_num] = 1;
				wake_up_interruptible(&vdev->isp_int_wait_q[raw_num]);

				atomic_set(&vdev->isp_raw_dump_en[raw_num], 0);
			}
		}

		if (_is_all_online(ctx)) {
			struct isp_grid_s_info m_info;

			m_info = ispblk_rgbmap_info(ctx, raw_num);
			ctx->isp_pipe_cfg[raw_num].rgbmap_i.w_bit = m_info.w_bit;
			ctx->isp_pipe_cfg[raw_num].rgbmap_i.h_bit = m_info.h_bit;

			m_info = ispblk_lmap_info(ctx, raw_num);
			ctx->isp_pipe_cfg[raw_num].lmap_i.w_bit = m_info.w_bit;
			ctx->isp_pipe_cfg[raw_num].lmap_i.h_bit = m_info.h_bit;
		}
	} else if (_is_be_post_online(ctx)) { //fe->dram->be->post
		struct isp_buffer *b = NULL;
		struct isp_grid_s_info m_info;
		struct isp_queue *fe_out_q = (chn_num == ISP_FE_CH0) ?
						&pre_out_queue[raw_num] : &pre_out_se_queue[raw_num];
		struct isp_queue *be_in_q = (chn_num == ISP_FE_CH0) ? &pre_be_in_q : &pre_be_in_se_q[raw_num];
		struct isp_queue *raw_d_q = (chn_num == ISP_FE_CH0) ?
					    &raw_dump_b_dq[raw_num] :
					    &raw_dump_b_se_dq[raw_num];

		if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 3) //raw dump enable
			fe_out_q = (chn_num == ISP_FE_CH0) ? &raw_dump_b_q[raw_num] : &raw_dump_b_se_q[raw_num];

		b = isp_buf_remove(fe_out_q);
		if (b == NULL) {
			vip_pr(CVI_DBG, "Pre_fe_%d chn_num_%d outbuf is empty\n", raw_num, chn_num);
			return;
		}

		if (atomic_read(&vdev->isp_raw_dump_en[raw_num]) == 3) { //raw dump enable
			u32 dmaid = (raw_num == ISP_PRERAW_A) ?
					((chn_num == ISP_FE_CH0) ? ISP_BLK_ID_WDMA0 : ISP_BLK_ID_WDMA1) :
					((chn_num == ISP_FE_CH0) ? ISP_BLK_ID_WDMA6 : ISP_BLK_ID_WDMA7);
			u32 w = (chn_num == ISP_FE_CH0) ?
				ctx->isp_pipe_cfg[raw_num].crop.w :
				ctx->isp_pipe_cfg[raw_num].crop_se.w;
			u32 h = (chn_num == ISP_FE_CH0) ?
				ctx->isp_pipe_cfg[raw_num].crop.h :
				ctx->isp_pipe_cfg[raw_num].crop_se.h;

			b->crop_le.x = b->crop_se.x = 0;
			b->crop_le.y = b->crop_se.y = 0;
			b->crop_le.w = b->crop_se.w = ctx->isp_pipe_cfg[raw_num].crop.w;
			b->crop_le.h = b->crop_se.h = ctx->isp_pipe_cfg[raw_num].crop.h;
			b->byr_size = ispblk_dma_get_size(ctx, dmaid, w, h);

			isp_buf_queue(raw_d_q, b);
		} else {
			m_info = ispblk_rgbmap_info(ctx, raw_num);
			b->rgbmap_i.w_bit = m_info.w_bit;
			b->rgbmap_i.h_bit = m_info.h_bit;

			m_info = ispblk_lmap_info(ctx, raw_num);
			b->lmap_i.w_bit = m_info.w_bit;
			b->lmap_i.h_bit = m_info.h_bit;

			b->is_yuv_frm	= 0;
			b->chn_num	= 0;

			isp_buf_queue(be_in_q, b);
		}

		atomic_set(&vdev->pre_fe_state[raw_num][chn_num], ISP_PRERAW_IDLE);

		if (!ctx->isp_pipe_cfg[raw_num].is_offline_preraw)
			_pre_hw_enque(vdev, raw_num, chn_num);

		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			trigger = (vdev->pre_fe_frm_num[raw_num][ISP_FE_CH0] ==
					vdev->pre_fe_frm_num[raw_num][ISP_FE_CH1]);
		} else
			trigger = true;

		if (trigger) {
			//vip_pr(CVI_DBG, "fe->dram->be->post trigger raw_num=%d\n", raw_num);

			if (atomic_cmpxchg(&vdev->isp_raw_dump_en[raw_num], 3, 0) == 3) { //raw dump flow
				vip_pr(CVI_DBG, "raw_num=%d, wake up wait_q\n", raw_num);

				vdev->isp_int_flag[raw_num] = 1;
				wake_up_interruptible(&vdev->isp_int_wait_q[raw_num]);
			} else {
				tasklet_hi_schedule(&vdev->job_work);
			}
		}
	}
}

static inline void _isp_pre_be_done_handler(
	struct cvi_isp_vdev *vdev,
	const u8 chn_num)
{
	struct isp_ctx *ctx = &vdev->ctx;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	u32 type;
	u32 trigger = false;

	if (_is_fe_be_online(ctx)) { // fe->be->dram->post
		struct isp_buffer *b = NULL;
		struct isp_grid_s_info m_info;
		struct isp_queue *be_out_q = (chn_num == ISP_FE_CH0) ?
						&pre_be_out_q : &pre_be_out_se_q;
		struct isp_queue *post_in_q = (chn_num == ISP_FE_CH0) ?
						&post_in_queue : &post_in_se_queue;

		++vdev->pre_be_frm_num[raw_num][chn_num];
		type = (raw_num == ISP_PRERAW_A) ? V4L2_EVENT_CVI_VIP_PRE0_EOF : V4L2_EVENT_CVI_VIP_PRE1_EOF;

		vip_pr(CVI_DBG, "pre_be frm_done chn_num=%d frm_num=%d\n",
				chn_num, vdev->pre_be_frm_num[raw_num][chn_num]);

		b = isp_buf_remove(be_out_q);
		if (b == NULL) {
			vip_pr(CVI_ERR, "Pre_be chn_num_%d outbuf is empty\n", chn_num);
			return;
		}

		m_info = ispblk_rgbmap_info(ctx, raw_num);
		b->rgbmap_i.w_bit = m_info.w_bit;
		b->rgbmap_i.h_bit = m_info.h_bit;

		m_info = ispblk_lmap_info(ctx, raw_num);
		b->lmap_i.w_bit = m_info.w_bit;
		b->lmap_i.h_bit = m_info.h_bit;

		isp_buf_queue(post_in_q, b);

		//Pre_be done for tuning to get stt.
		_swap_pre_be_sts_buf(vdev, raw_num, chn_num);

		atomic_set(&vdev->pre_be_state[chn_num], ISP_PRE_BE_IDLE);

		if (!ctx->isp_pipe_cfg[raw_num].is_offline_preraw)
			_pre_hw_enque(vdev, raw_num, chn_num);

		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			trigger = (vdev->pre_be_frm_num[raw_num][ISP_BE_CH0] ==
					vdev->pre_be_frm_num[raw_num][ISP_BE_CH1]);
		} else
			trigger = true;

		if (trigger) {
			_isp_v4l2_event_queue(vdev, type, vdev->pre_be_frm_num[raw_num][ISP_BE_CH0]);

			tasklet_hi_schedule(&vdev->job_work);
		}
	} else if (_is_be_post_online(ctx)) { // fe->dram->be->post
		struct isp_buffer *b = NULL;
		struct isp_queue *be_in_q = (chn_num == ISP_BE_CH0) ?
						&pre_be_in_q : &pre_be_in_se_q[vdev->ctx.cam_id];
		struct isp_queue *pre_out_q = NULL;

		b = isp_buf_remove(be_in_q);
		if (b == NULL) {
			vip_pr(CVI_ERR, "Pre_be chn_num_%d outbuf is empty\n", chn_num);
			return;
		}
		if (b->raw_num >= ISP_PRERAW_MAX) {
			vip_pr(CVI_ERR, "buf raw_num_%d is wrong\n", b->raw_num);
			return;
		}
		raw_num = b->raw_num;

		++vdev->pre_be_frm_num[raw_num][chn_num];
		type = (raw_num == ISP_PRERAW_A) ? V4L2_EVENT_CVI_VIP_PRE0_EOF : V4L2_EVENT_CVI_VIP_PRE1_EOF;

		vip_pr(CVI_DBG, "pre_be_%d frm_done chn_num=%d frm_num=%d\n",
				raw_num, chn_num, vdev->pre_be_frm_num[raw_num][chn_num]);

		pre_out_q = (chn_num == ISP_BE_CH0) ? &pre_out_queue[raw_num] : &pre_out_se_queue[raw_num];
		isp_buf_queue(pre_out_q, b);

		atomic_set(&vdev->pre_be_state[chn_num], ISP_PRE_BE_IDLE);

		if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
			trigger = (vdev->pre_be_frm_num[raw_num][ISP_BE_CH0] ==
					vdev->pre_be_frm_num[raw_num][ISP_BE_CH1]);
		} else
			trigger = true;

		if (trigger)
			_isp_v4l2_event_queue(vdev, type, vdev->pre_be_frm_num[raw_num][ISP_BE_CH0]);
	} else if (_is_all_online(ctx)) { // fly-mode
		++vdev->pre_be_frm_num[raw_num][chn_num];
		type = (raw_num == ISP_PRERAW_A) ? V4L2_EVENT_CVI_VIP_PRE0_EOF : V4L2_EVENT_CVI_VIP_PRE1_EOF;

		//Pre_be done for tuning to get stt.
		_swap_pre_be_sts_buf(vdev, raw_num, chn_num);

		_isp_v4l2_event_queue(vdev, type, vdev->pre_be_frm_num[raw_num][ISP_BE_CH0]);
	}
}

static void _isp_postraw_done_handler(struct cvi_isp_vdev *vdev)
{
	struct isp_ctx *ctx = &vdev->ctx;
	enum cvi_isp_raw raw_num = ISP_PRERAW_A;
	u32 type = V4L2_EVENT_CVI_VIP_POST_EOF;

	if (_is_fe_be_online(ctx)) {
		raw_num = ctx->cam_id;

		if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //RGB sensor
			if (ctx->is_tile && (++vdev->postraw_proc_num == 2))
				vdev->postraw_proc_num = 0;
			else if (!ctx->is_tile)
				vdev->postraw_proc_num = 0;
		} else { //YUV sensor
			vdev->postraw_proc_num = 0;
		}
	} else {
		vdev->postraw_proc_num = 0;
	}

	if (vdev->postraw_proc_num == 0) { //Tile:The second postraw done, then notify MW to DQ.

		if (_is_fe_be_online(ctx)) { //fe->be->dram->post
			struct isp_buffer *ispb, *ispb_se;

			ispb = isp_buf_remove(&post_in_queue);
			if (ispb == NULL) {
				vip_pr(CVI_ERR, "post_in_q is empty\n");
				return;
			}
			if (ispb->raw_num >= ISP_PRERAW_MAX) {
				vip_pr(CVI_ERR, "buf raw_num_%d is wrong\n", ispb->raw_num);
				return;
			}
			raw_num = ispb->raw_num;

			if (ispb->is_yuv_frm) {
				isp_buf_queue(&pre_out_queue[ispb->chn_num], ispb);
			} else {
				isp_buf_queue(&pre_be_out_q, ispb);

				if (ctx->isp_pipe_cfg[raw_num].is_hdr_on) {
					ispb_se = isp_buf_remove(&post_in_se_queue);
					if (ispb_se == NULL) {
						vip_pr(CVI_ERR, "post_in_se_q is empty\n");
						return;
					}
					isp_buf_queue(&pre_be_out_se_q, ispb_se);
				}
			}
		} else if (_is_be_post_online(ctx)) {
			raw_num = ctx->cam_id;

			if (ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) {
				struct isp_buffer *b = NULL;
				struct isp_queue *be_in_q = &pre_be_in_q;
				struct isp_queue *pre_out_q = NULL;
				u8 chn_num = 0;

				b = isp_buf_remove(be_in_q);
				if (b == NULL) {
					vip_pr(CVI_ERR, "pre_be_in_q is empty\n");
					return;
				}
				if (b->chn_num >= ISP_CHN_MAX) {
					vip_pr(CVI_ERR, "buf chn_num_%d is wrong\n", b->chn_num);
					return;
				}
				chn_num = b->chn_num;

				pre_out_q = &pre_out_queue[chn_num];
				isp_buf_queue(pre_out_q, b);
			}
		} else if (_is_all_online(ctx)) {
			//Update postraw stt awb/dci/hist_edge_v dma size/addr
			_swap_post_sts_buf(ctx, raw_num);
		}

		atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
		if (_is_be_post_online(ctx) && ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path)
			atomic_set(&vdev->pre_be_state[ISP_BE_CH0], ISP_PRE_BE_IDLE);

		++vdev->postraw_frame_number[raw_num];

		vip_pr(CVI_DBG, "Postraw_%d frm_done frm_num=%d\n", raw_num, vdev->postraw_frame_number[raw_num]);

		if (_is_all_online(ctx))
			tasklet_hi_schedule(&vdev->job_work);

		if (!ctx->isp_pipe_cfg[raw_num].is_yuv_bypass_path) { //ISP team no need yuv post done
			if (isp_bufpool[raw_num].fswdr_rpt)
				ispblk_fswdr_update_rpt(ctx, isp_bufpool[raw_num].fswdr_rpt);

			if (raw_num == ISP_PRERAW_B)
				type = V4L2_EVENT_CVI_VIP_POST1_EOF;

			ctx->mmap_grid_size[raw_num] = ctx->isp_pipe_cfg[raw_num].rgbmap_i.w_bit;

			_isp_v4l2_event_queue(vdev, type, vdev->postraw_frame_number[raw_num]);
		}

		if (ctx->isp_pipe_cfg[raw_num].is_offline_scaler) {
			cvi_isp_rdy_buf_remove2(vdev, raw_num);

			cvi_isp_dqbuf_list(vdev, vdev->postraw_frame_number[raw_num], raw_num);
			wake_up(&vdev->isp_dq_wait_q);
		}

		if (!_is_all_online(ctx)) {
			tasklet_hi_schedule(&vdev->job_work);

			if (!ctx->isp_pipe_cfg[raw_num].is_offline_preraw) {
				_pre_hw_enque(vdev, raw_num, ISP_FE_CH0);
				if (ctx->isp_pipe_cfg[raw_num].is_hdr_on)
					_pre_hw_enque(vdev, raw_num, ISP_FE_CH1);
			}
		}
	} else { //Trigger Right tile
		if (ctx->isp_pipe_cfg[raw_num].is_offline_scaler) { //SC offline
			_isp_right_tile(vdev, raw_num);
			isp_post_trig(ctx, raw_num);
		} else { //SC online mode
			atomic_set(&vdev->postraw_state, ISP_POSTRAW_IDLE);
			ctx->is_work_on_r_tile = true;
			vip_pr(CVI_DBG, "postraw frm done for right tile\n");
			tasklet_hi_schedule(&vdev->job_work);
		}
	}
}

void isp_irq_handler(
	struct cvi_vip_dev *bdev,
	union REG_ISP_TOP_0 top_sts,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_0 cbdg_0_sts,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_1 cbdg_1_sts,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_0 cbdg_0_sts_b,
	union REG_ISP_CSI_BDG_INTERRUPT_STATUS_1 cbdg_1_sts_b)
{
	struct cvi_isp_vdev *vdev;
	struct isp_ctx *ctx = NULL;
	union REG_ISP_TOP_9 top_sts_1 = isp_int_event1_status(&bdev->isp_vdev.ctx);
	u8 i = 0, raw_num = ISP_PRERAW_A;

	if (!bdev) {
		vip_pr(CVI_ERR, "%s dev is null\n", __func__);
		return;
	}

	vdev = &bdev->isp_vdev;
	ctx = &vdev->ctx;

#ifdef ISP_PERF_MEASURE
	if (time_chk.sof_end && time_chk.pre_fe_end && time_chk.pre_be_end && time_chk.post_end)
		_isp_perf_time_dump();
#endif

	for (raw_num = ISP_PRERAW_A; raw_num < ISP_PRERAW_MAX; raw_num++) {
		if (raw_num == ISP_PRERAW_A) {
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_int_sts_0 = cbdg_0_sts.raw;
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_int_sts_1 = cbdg_1_sts.raw;
		} else {
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_int_sts_0 = cbdg_0_sts_b.raw;
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_int_sts_1 = cbdg_1_sts_b.raw;
		}

		ctx->isp_pipe_cfg[raw_num].dg_info.fe_sts = ispblk_fe_dbg_info(ctx, raw_num);
		if (raw_num == ISP_PRERAW_A) {
			ctx->isp_pipe_cfg[raw_num].dg_info.be_sts = ispblk_be_dbg_info(ctx);
			ctx->isp_pipe_cfg[raw_num].dg_info.post_sts = ispblk_post_dbg_info(ctx);
			ctx->isp_pipe_cfg[raw_num].dg_info.dma_sts = ispblk_dma_dbg_info(ctx);
		}

		for (i = 0; i < ISP_FE_CHN_MAX; i++)
			ctx->isp_pipe_cfg[raw_num].dg_info.bdg_chn_debug[i] = ispblk_csibdg_chn_dbg(ctx, raw_num, i);
	}

	//vip_pr(CVI_INFO, "isp status=0x%x\n", top_sts.raw);

	if (isp_err_chk(vdev, ctx, cbdg_0_sts, cbdg_1_sts, cbdg_0_sts_b, cbdg_1_sts_b) == -1)
		return;

	//if (top_sts.bits.INT_DMA_ERR)
	//	vip_pr(CVI_ERR, "DMA error\n");

	/* pre_fe0 ch0 frame start */
	if (top_sts.bits.FRAME_START_FE0 & 0x1) {
		if (!vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw)
			++vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0];

#ifdef ISP_PERF_MEASURE
		if (vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0] < ISP_MEASURE_FRM + 1) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
			struct timespec64 ts;

			ktime_get_real_ts64(&ts);

			time_chk.sof_time[vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_sec = ts.tv_sec;
			time_chk.sof_time[vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_nsec = ts.tv_nsec;
#else
			struct timeval tv;

			do_gettimeofday(&tv);

			time_chk.sof_time[vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_sec = tv.tv_sec;
			time_chk.sof_time[vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_usec = tv.tv_usec;
#endif

			if (vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0] == ISP_MEASURE_FRM)
				time_chk.sof_end = true;
		}
#endif
		if (!vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_yuv_bypass_path) { //RGB sensor
			if (!vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_offline_preraw) {
				_isp_sof_handler(vdev, ISP_PRERAW_A);
				_isp_v4l2_event_queue(vdev, V4L2_EVENT_CVI_VIP_PRE0_SOF,
							vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH0]);
			}
		} else if (!vdev->ctx.isp_pipe_cfg[ISP_PRERAW_A].is_offline_scaler) { //YUV sensor online mode
			//ISP team no need sof event by yuv sensor
			//_post_hw_enque(vdev);
			tasklet_hi_schedule(&vdev->job_work);
		}
	}

	/* pre_fe0 ch1 frame start */
	if (top_sts.bits.FRAME_START_FE0 & 0x2) {
		++vdev->pre_fe_sof_cnt[ISP_PRERAW_A][ISP_FE_CH1];

		//_isp_sof_handler(ISP_PRERAW_A);
		//_isp_v4l2_event_queue(vdev, V4L2_EVENT_CVI_VIP_PRE0_SOF, 0);
	}

	/* pre_fe1 ch0 frame start */
	if (top_sts.bits.FRAME_START_FE1 & 0x1) {
		++vdev->pre_fe_sof_cnt[ISP_PRERAW_B][ISP_FE_CH0];

		if (!vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].is_yuv_bypass_path) { //RGB sensor
			_isp_sof_handler(vdev, ISP_PRERAW_B);
			_isp_v4l2_event_queue(vdev, V4L2_EVENT_CVI_VIP_PRE1_SOF, 0);
		} else if (!vdev->ctx.isp_pipe_cfg[ISP_PRERAW_B].is_offline_scaler) { //YUV sensor online mode
			//ISP team no need sof event by yuv sensor
			//_post_hw_enque(vdev);
			tasklet_hi_schedule(&vdev->job_work);
		}
	}

	/* pre_fe1 ch1 frame start */
	if (top_sts.bits.FRAME_START_FE1 & 0x2) {
		++vdev->pre_fe_sof_cnt[ISP_PRERAW_B][ISP_FE_CH1];

		//_isp_sof_handler(ISP_PRERAW_B);
		//_isp_v4l2_event_queue(vdev, V4L2_EVENT_CVI_VIP_PRE1_SOF, 0);
	}

	/* pre_fe0 ch0 frm_done */
	if (top_sts.bits.FRAME_DONE_FE0 & 0x1) {
		++vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0];

#ifdef ISP_PERF_MEASURE
		if (vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] < ISP_MEASURE_FRM + 1) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
			struct timespec64 ts;

			ktime_get_real_ts64(&ts);

			time_chk.pre_fe_eof[vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_sec = ts.tv_sec;
			time_chk.pre_fe_eof[vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_nsec = ts.tv_nsec;
#else
			struct timeval tv;

			do_gettimeofday(&tv);

			time_chk.pre_fe_eof[vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_sec = tv.tv_sec;
			time_chk.pre_fe_eof[vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] - 1].tv_usec = tv.tv_usec;
#endif

			if (vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH0] == ISP_MEASURE_FRM)
				time_chk.pre_fe_end = true;
		}
#endif

		_isp_pre_fe_done_handler(vdev, ISP_PRERAW_A, ISP_FE_CH0);
	}

	/* pre_fe0 ch1 frm_done */
	if (top_sts.bits.FRAME_DONE_FE0 & 0x2) {
		++vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH1];

		_isp_pre_fe_done_handler(vdev, ISP_PRERAW_A, ISP_FE_CH1);
	}

	/* pre_fe0 ch2 frm_done */
	if (top_sts.bits.FRAME_DONE_FE0 & 0x4) {
		++vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH2];

		_isp_pre_fe_done_handler(vdev, ISP_PRERAW_A, ISP_FE_CH2);
	}

	/* pre_fe0 ch3 frm_done */
	if (top_sts.bits.FRAME_DONE_FE0 & 0x8) {
		++vdev->pre_fe_frm_num[ISP_PRERAW_A][ISP_FE_CH3];

		_isp_pre_fe_done_handler(vdev, ISP_PRERAW_A, ISP_FE_CH3);
	}

	/* pre_fe1 ch0 frm_done */
	if (top_sts.bits.FRAME_DONE_FE1 & 0x1) {
		++vdev->pre_fe_frm_num[ISP_PRERAW_B][ISP_FE_CH0];

		_isp_pre_fe_done_handler(vdev, ISP_PRERAW_B, ISP_FE_CH0);
	}

	/* pre_fe1 ch1 frm_done */
	if (top_sts.bits.FRAME_DONE_FE1 & 0x2) {
		++vdev->pre_fe_frm_num[ISP_PRERAW_B][ISP_FE_CH1];

		_isp_pre_fe_done_handler(vdev, ISP_PRERAW_B, ISP_FE_CH1);
	}

	/* awb frm done */
	if (top_sts_1.bits.FRAME_DONE_AWB)
		_isp_awb_frm_done_handler(vdev);

	/* pre_be ch0 frm done */
	if (top_sts.bits.FRAME_DONE_BE & 0x1) {
#ifdef ISP_PERF_MEASURE
		if (vdev->pre_be_frm_num[ISP_PRERAW_A][ISP_BE_CH0] < ISP_MEASURE_FRM) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
			struct timespec64 ts;

			ktime_get_real_ts64(&ts);

			time_chk.pre_be_eof[vdev->pre_be_frm_num[ISP_PRERAW_A][ISP_BE_CH0]].tv_sec = ts.tv_sec;
			time_chk.pre_be_eof[vdev->pre_be_frm_num[ISP_PRERAW_A][ISP_BE_CH0]].tv_nsec = ts.tv_nsec;
#else
			struct timeval tv;

			do_gettimeofday(&tv);

			time_chk.pre_be_eof[vdev->pre_be_frm_num[ISP_PRERAW_A][ISP_BE_CH0]].tv_sec = tv.tv_sec;
			time_chk.pre_be_eof[vdev->pre_be_frm_num[ISP_PRERAW_A][ISP_BE_CH0]].tv_usec = tv.tv_usec;
#endif

			if (vdev->pre_be_frm_num[ISP_PRERAW_A][ISP_BE_CH0] == ISP_MEASURE_FRM - 1)
				time_chk.pre_be_end = true;
		}
#endif
		_isp_pre_be_done_handler(vdev, ISP_BE_CH0);
	}

	/* pre_be ch1 frm done */
	if (top_sts.bits.FRAME_DONE_BE & 0x2) {
		_isp_pre_be_done_handler(vdev, ISP_BE_CH1);
	}

	/* post frm done */
	if (top_sts.bits.FRAME_DONE_POST) {
#ifdef ISP_PERF_MEASURE
		if (vdev->postraw_frame_number[ISP_PRERAW_A] < ISP_MEASURE_FRM) {
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
			struct timespec64 ts;

			ktime_get_real_ts64(&ts);

			time_chk.post_eof[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_sec = ts.tv_sec;
			time_chk.post_eof[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_nsec = ts.tv_nsec;
#else
			struct timeval tv;

			do_gettimeofday(&tv);

			time_chk.post_eof[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_sec = tv.tv_sec;
			time_chk.post_eof[vdev->postraw_frame_number[ISP_PRERAW_A]].tv_usec = tv.tv_usec;
#endif

			if (vdev->postraw_frame_number[ISP_PRERAW_A] == ISP_MEASURE_FRM - 1)
				time_chk.post_end = true;
		}
#endif
		_isp_postraw_done_handler(vdev);
	}
}
