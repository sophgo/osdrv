#ifndef _DPU_MODULE_
#define _DPU_MODULE_

//#include <stdio.h>
#include <linux/cvi_errno.h>
#include <linux/cvi_base_ctx.h>
#include <linux/cvi_buffer.h>
#include <linux/cvi_comm_vb.h>
#include "linux/kernel.h"
#include <linux/errno.h>
#include <linux/cvi_defines.h>
#include <linux/cvi_comm_dpu.h>
#include "dpu_reg.h"
#include "dpu_core.h"
#include "../../common/dpu_debug.h"

#include "../../common/reg.h"
#include <linux/dpu_uapi.h>
#include <linux/module.h>
#include "linux/kernel.h"
#include <linux/kthread.h>
#include <linux/miscdevice.h>
#include <linux/spinlock.h>
#include <linux/wait.h>
#include <linux/mutex.h>
#include <linux/types.h>
#include <linux/timex.h>
#include <base_ctx.h>

#undef DPU_ALIGN
#define DPU_ALIGN(src,align) ((src+(align-1)) & ~((align-1)))


typedef struct _CVI_DPU_REG_{
    u32 reg_dpu_enable ;
    u32 reg_dpu_sgbm_enable ;
    u32 reg_dpu_img_width ;
    u32 reg_dpu_img_height ;
    u32 reg_dpu_min_d ;
    u32 reg_dpu_rshift1 ;
    u32 reg_dpu_rshift2 ;
    u32 reg_dpu_ca_p1 ;
    u32 reg_dpu_ca_p2 ;
    u32 reg_dpu_uniq_ratio ;
    u32 reg_dpu_disp_shift ;
    u32 reg_dpu_bfw_size;
    u32 reg_dpu_census_shift ;
    u32 reg_dpu_nd_ds ;
    u32 reg_dpu_fxbaseline ;
    u32 reg_dpu_disp_range ;
    u32 reg_dpu_dcc_a234 ;
    u32 reg_dpu_invalid_def ;
    u32 reg_dpu_data_sel;

    u32 reg_dpu_fgs_enable ;
    u32 reg_dpu_fgs_max_count ;
    u32 reg_dpu_fgs_max_t ;
    u32 reg_dpu_fgs_w_scale ;
    u32 reg_dpu_fgs_c_scale ;
    u32 reg_dpu_fgs_f_scale ;
    u32 reg_dpu_fgs_img_width ;
    u32 reg_dpu_fgs_img_height ;
    u32 reg_dpu_fgs_output_bit_choose ;
    u32 reg_dpu_fgs_output_unit_choose ;
    u32 reg_dpu_src_disp_mux ;

    u32 reg_sgbm_bf_st_dma_enable;
    u32 reg_sgbm_ld1_dma_enable;
    u32 reg_sgbm_ld2_dma_enable;
    u32 reg_sgbm_mux_st_dma_enable;
    u32 reg_dma_enable_fgs1;
    u32 reg_dma_enable_fgs2;
    u32 reg_dma_enable_fgs3;
    u32 reg_dma_enable_fgs4;

    u32 reg_sgbm_bf_st_crop_enable;
    u32 reg_sgbm_ld1_crop_enable;
    u32 reg_sgbm_ld2_crop_enable;
    u32 reg_sgbm_mux_st_crop_enable;

    u32 reg_crop_enable_fgs_independent;
    u32 reg_crop_enable_fgs_chfh;
    u32 reg_crop_enable_fgs_gx;
    u32 reg_crop_enable_fgs_ux;

    u32 reg_sgbm2fgs_online;

	struct mutex lock;

} CVI_DPU_REG;

enum handler_state {
	HANDLER_STATE_STOP = 0,
	HANDLER_STATE_RUN,
	HANDLER_STATE_SUSPEND,
	HANDLER_STATE_RESUME,
	HANDLER_STATE_MAX
};

enum dpu_grp_state {
	GRP_STATE_IDLE = 0x0,
	GRP_STATE_BUF_FILLED = 0x1,
	GRP_STATE_HW_STARTED = 0x2,
	GPP_MAX_STATE
};

typedef enum CVI_DPU_INTR_STATE_E{
	DPU_INTR_STATE_DONE = 0x0,
	DPU_INTR_STATE_OTHERS = 0x1,
	DPU_INTR_STATE_BUTT
}DPU_INTR_STATE_E;

struct DPU_JOB_QUEUE_STATUS_S{
	u32 BusyNum ; //numbers of busy nodes
	u32 FreeNum ; //numbers of free nodes
};

struct DPU_GRP_WORK_STATUS_S {
	u8 GrpID;
	u32 FrameRate;   		// Output frame rate
	u32 StartCnt;    		//Number of times of task startup
	u32 StartFailCnt; 		//Number of times of task startup failure
	u32 SendPicCnt;  		//Number of times of successful image transmission
	u32 CurTaskCostTm; 		//Time taken to complete the current task
	u32 MaxTaskCostTm; 		//Historical maximum time taken to complete a task
};

struct DPU_RUN_TIME_INFO_S {
	s32 CntPerSec; 			//Number of interrupts performed in the last second
	u32 MaxCntPerSec; 		//Historical maximum number of interrupts performed in one second
	u32 TotalIntCntLastSec; //Number of interrupts reported in the last second
	u32 TotalIntCnt; 		//Number of interrupts generated by the DPU
	u32 CostTm;      		//Time taken to performed the last interrupt /us
	u32 MCostTm;      		//Maximum time taken to performed the last interrupt /us
	u32 CostTmPerSec;      	//Time taken to performed in the last interrupt /us
	u32 MCostTmPerSec;      //Maximum time taken to performed in the last interrupt /us
	u32 TotalIntCostTm;     //Total time taken to performed all the interrupt /us
	u32 CostTmPerFrm;     	//Time taken to process a single frame of image  /us
	u32 HwCostTmPerFrm;     //Time taken by the hardware to process a single frame of image
	u64 RunTm;              //Total running time of DPU /s
};

struct DPU_CHN_CFG {
	u8 isEnabled;
	u8 isMuted;
	DPU_CHN_ATTR_S stChnAttr;
	PIXEL_FORMAT_E enPixelFormat;
	u32 blk_size;
	u32 align;
	u32 VbPool;
	u32 stride;
	u8 is_cfg_changed;
	VB_CAL_CONFIG_S stVbCalConfig;
};

struct cvi_dpu_ctx {
	u8 isCreated;
	u8 isStarted;
	DPU_GRP_ATTR_S stGrpAttr;
	struct DPU_CHN_CFG stChnCfgs[DPU_MAX_CHN_NUM];
	struct mutex lock;
	struct DPU_GRP_WORK_STATUS_S stGrpWorkStatus;
	u32 grp_state;
	u8 u8DpuDev;
	u8 is_dma_cfg;
	u32 u32Stride[2];
	u32 chnNum;
	PIXEL_FORMAT_E enPixelFormat;
	struct DPU_JOB_QUEUE_STATUS_S stInputJobStatus;
	struct DPU_JOB_QUEUE_STATUS_S stWorkingJobStatus;
	struct DPU_JOB_QUEUE_STATUS_S stOutputJobStatus;
	VB_BLK chfhBlk;
	s32 frameNum;
	s32 costTimeForSec;
	uint64_t phyAddr_chfh;
	void *   virAddr_chfh;
};

struct cvi_dpu_handle_info {
	struct list_head list;
	struct file *file;
	u8 useGrp[8];
	pid_t open_pid;
};

struct cvi_dpu_dev {
	struct miscdevice miscdev;
	spinlock_t lock;
	struct mutex mutex;
	unsigned int irq_num;
	struct clk *clk_sys[2];
	u32 clk_sys1_freq;
	void *shared_mem;
	wait_queue_head_t wait;
	wait_queue_head_t sendFrame_wait;
	wait_queue_head_t reset_wait;
	u8 reset_done;
	struct task_struct *thread;
	struct DPU_RUN_TIME_INFO_S stRunTimeInfo;
	struct timespec64 timeTotalForSec;
	u32 timeForSec;
	u32 IntNumPerSec;
	struct timespec64 timeStart;
	u32 timeEnd;
	u32 costTimeForSec ;
	u32 IntTimePerSec;
	u8 bBusy;
	uint64_t phyAddr_chfh;
	void *   virAddr_chfh;
	struct list_head handle_list;
	struct mutex dpuLock;
};

s32 cvi_dpu_get_assist_buf_size(u16 u16_disp_num,u32 u32_dst_height,u32 * pu32_size);

s32 cvi_dpu_create_grp(DPU_GRP DpuGrp,DPU_GRP_ATTR_S *pstGrpAttr);

s32 cvi_dpu_destroy_grp(DPU_GRP DpuGrp);

DPU_GRP cvi_dpu_get_available_grp(void);

s32 cvi_dpu_set_grp_attr(DPU_GRP DpuGrp,const DPU_GRP_ATTR_S *pstGrpAttr);

s32 cvi_dpu_get_grp_attr(DPU_GRP DpuGrp,DPU_GRP_ATTR_S *pstGrpAttr);

s32 cvi_dpu_start_grp(DPU_GRP DpuGrp);

s32 cvi_dpu_stop_grp(DPU_GRP DpuGrp);

s32 cvi_dpu_set_chn_attr(DPU_GRP DpuGrp,DPU_CHN  DpuChn,const DPU_CHN_ATTR_S *pstChnAttr);

s32 cvi_dpu_get_chn_attr(DPU_GRP DpuGrp,DPU_CHN DpuChn,DPU_CHN_ATTR_S *pstChnAttr);

s32 cvi_dpu_enable_chn(DPU_GRP DpuGrp,DPU_CHN DpuChn);

s32 cvi_dpu_disable_chn(DPU_GRP DpuGrp,DPU_CHN DpuChn);

s32 cvi_dpu_send_frame(DPU_GRP DpuGrp,\
                                const VIDEO_FRAME_INFO_S *pst_left_frame,\
                                const VIDEO_FRAME_INFO_S *pst_right_frame,\
                                s32 s32Millisec);

s32 cvi_dpu_send_chn_frame(DPU_GRP DpuGrp,\
							DPU_CHN DpuChn,\
                            const VIDEO_FRAME_INFO_S *pstVideoFrame,\
							s32 s32Millisec);

s32 cvi_dpu_get_frame(DPU_GRP DpuGrp,\
							DPU_CHN DpuChn,\
							VIDEO_FRAME_INFO_S *pstFrameInfo,\
							s32 s32Millisec);

s32 cvi_dpu_release_frame(DPU_GRP DpuGrp,\
							DPU_CHN DpuChn,\
                            const VIDEO_FRAME_INFO_S *pstVideoFrame);

void dpu_check_reg_write(void);

void dpu_check_reg_read(void);

void getsgbm_status(void);

void getfgs_status(void);

void dpu_irq_handler(u8 intr_status, struct cvi_dpu_dev *wdev);

void dpu_set_base_addr(void *base);

void dpu_set_base_addr_sgbm_dma(void *base1,void *base2,void *base3,void *base4);

void dpu_set_base_addr_fgs_dma(void *base1,void *base2,void *base3,void *base4);

int dpu_get_handle_info(struct cvi_dpu_dev *dpu_wdev, struct file *file, struct cvi_dpu_handle_info **f_list);

void dpu_mode_deinit(DPU_GRP DpuGrp);

void dpu_init(void *arg);

void dpu_deinit(void *arg);

void dpu_reset(void);

void dpu_engine(DPU_GRP workingGrpID);

void dpu_intr_ctrl(u8 intr_mask);

void dpu_intr_clr(void);

u8 dpu_intr_status(void);

void dpu_notify_isr_evt(void);

struct cvi_dpu_ctx **dpu_get_shdw_ctx(void);

struct cvi_dpu_dev *dpu_get_dev(void);

struct dpu_handler_ctx *dpu_get_handler_ctx(void);

#define DPU_GRP_SUPPORT_FMT(fmt) \
	((fmt == PIXEL_FORMAT_YUV_400))

#define DPU_CHN_SUPPORT_FMT(fmt) \
	((fmt == PIXEL_FORMAT_YUV_400))

#define FRC_INVALID(ctx, DpuChn)	\
	(ctx->stChnCfgs[DpuChn].stChnAttr.stFrameRate.s32DstFrameRate <= 0 ||		\
		ctx->stChnCfgs[DpuChn].stChnAttr.stFrameRate.s32SrcFrameRate <= 0 ||		\
		ctx->stChnCfgs[DpuChn].stChnAttr.stFrameRate.s32DstFrameRate >=		\
		ctx->stChnCfgs[DpuChn].stChnAttr.stFrameRate.s32SrcFrameRate)

#define IS_FRAME_OFFSET_INVALID(f) \
	((f).s16OffsetLeft < 0 || (f).s16OffsetRight < 0 || \
	 (f).s16OffsetTop < 0 || (f).s16OffsetBottom < 0 || \
	 ((u32)((f).s16OffsetLeft + (f).s16OffsetRight) > (f).u32Width) || \
	 ((u32)((f).s16OffsetTop + (f).s16OffsetBottom) > (f).u32Height))

static inline s32 MOD_CHECK_NULL_PTR(MOD_ID_E mod, const void *ptr)
{
	if (mod >= CVI_ID_BUTT)
		return CVI_FAILURE;
	if (!ptr) {
		CVI_TRACE_DPU(CVI_DBG_ERR, "NULL pointer\n");
		return CVI_ERR_DPU_NULL_PTR;
	}
	return CVI_SUCCESS;
}

static inline s32 CHECK_DPU_CHN_FMT(DPU_CHN ChnIn, enum _PIXEL_FORMAT_E fmt)
{

	if (!DPU_CHN_SUPPORT_FMT(fmt)) {
	CVI_TRACE_DPU(CVI_DBG_ERR, "Chn(%d) enPixelFormat(%d) unsupported\n"
	, ChnIn, fmt);
	return CVI_ERR_DPU_ILLEGAL_PARAM;
	}
	return CVI_SUCCESS;

}

#endif//_DPU_MODULE_
